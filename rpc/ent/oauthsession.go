// Code generated by ent, DO NOT EDIT.

package ent

import (
	"encoding/json"
	"fmt"
	"strings"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/coder-lulu/newbee-core/rpc/ent/oauthprovider"
	"github.com/coder-lulu/newbee-core/rpc/ent/oauthsession"
	"github.com/coder-lulu/newbee-core/rpc/ent/user"
	uuid "github.com/gofrs/uuid/v5"
)

// OAuth Session Management Table | OAuth会话管理表
type OauthSession struct {
	config `json:"-"`
	// ID of the ent.
	ID uint64 `json:"id,omitempty"`
	// Create Time | 创建日期
	CreatedAt time.Time `json:"created_at,omitempty"`
	// Update Time | 修改日期
	UpdatedAt time.Time `json:"updated_at,omitempty"`
	// Status 1: normal 2: ban | 状态 1 正常 2 禁用
	Status uint8 `json:"status,omitempty"`
	// Tenant ID | 租户 ID
	TenantID uint64 `json:"tenant_id,omitempty"`
	// Unique session identifier | 唯一会话标识符
	SessionID string `json:"session_id,omitempty"`
	// OAuth state parameter | OAuth state参数
	State string `json:"state,omitempty"`
	// OAuth provider ID | OAuth提供商ID
	ProviderID uint64 `json:"provider_id,omitempty"`
	// Associated user ID (if logged in) | 关联的用户ID（如果已登录）
	UserID uuid.UUID `json:"user_id,omitempty"`
	// OAuth redirect URI | OAuth回调地址
	RedirectURI string `json:"redirect_uri,omitempty"`
	// Requested OAuth scopes | 请求的OAuth权限范围
	Scope string `json:"scope,omitempty"`
	// PKCE code challenge | PKCE代码挑战
	CodeChallenge string `json:"code_challenge,omitempty"`
	// PKCE code challenge method | PKCE代码挑战方法
	CodeChallengeMethod string `json:"code_challenge_method,omitempty"`
	// PKCE code verifier | PKCE代码验证器
	CodeVerifier string `json:"code_verifier,omitempty"`
	// Session expiration time | 会话过期时间
	ExpiresAt time.Time `json:"expires_at,omitempty"`
	// Client IP address | 客户端IP地址
	ClientIP string `json:"client_ip,omitempty"`
	// Client user agent | 客户端用户代理
	UserAgent string `json:"user_agent,omitempty"`
	// OAuth authorization code | OAuth授权码
	AuthorizationCode string `json:"authorization_code,omitempty"`
	// Authorization code received time | 授权码接收时间
	CodeReceivedAt time.Time `json:"code_received_at,omitempty"`
	// OAuth callback additional data | OAuth回调额外数据
	CallbackData map[string]interface{} `json:"callback_data,omitempty"`
	// OAuth error code | OAuth错误码
	ErrorCode string `json:"error_code,omitempty"`
	// OAuth error description | OAuth错误描述
	ErrorDescription string `json:"error_description,omitempty"`
	// Retry attempts count | 重试次数
	RetryCount int `json:"retry_count,omitempty"`
	// Department ID when session was created | 会话创建时的部门ID
	DepartmentID uint64 `json:"department_id,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the OauthSessionQuery when eager-loading is set.
	Edges        OauthSessionEdges `json:"edges"`
	selectValues sql.SelectValues
}

// OauthSessionEdges holds the relations/edges for other nodes in the graph.
type OauthSessionEdges struct {
	// Provider holds the value of the provider edge.
	Provider *OauthProvider `json:"provider,omitempty"`
	// User holds the value of the user edge.
	User *User `json:"user,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [2]bool
}

// ProviderOrErr returns the Provider value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e OauthSessionEdges) ProviderOrErr() (*OauthProvider, error) {
	if e.Provider != nil {
		return e.Provider, nil
	} else if e.loadedTypes[0] {
		return nil, &NotFoundError{label: oauthprovider.Label}
	}
	return nil, &NotLoadedError{edge: "provider"}
}

// UserOrErr returns the User value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e OauthSessionEdges) UserOrErr() (*User, error) {
	if e.User != nil {
		return e.User, nil
	} else if e.loadedTypes[1] {
		return nil, &NotFoundError{label: user.Label}
	}
	return nil, &NotLoadedError{edge: "user"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*OauthSession) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case oauthsession.FieldCallbackData:
			values[i] = new([]byte)
		case oauthsession.FieldID, oauthsession.FieldStatus, oauthsession.FieldTenantID, oauthsession.FieldProviderID, oauthsession.FieldRetryCount, oauthsession.FieldDepartmentID:
			values[i] = new(sql.NullInt64)
		case oauthsession.FieldSessionID, oauthsession.FieldState, oauthsession.FieldRedirectURI, oauthsession.FieldScope, oauthsession.FieldCodeChallenge, oauthsession.FieldCodeChallengeMethod, oauthsession.FieldCodeVerifier, oauthsession.FieldClientIP, oauthsession.FieldUserAgent, oauthsession.FieldAuthorizationCode, oauthsession.FieldErrorCode, oauthsession.FieldErrorDescription:
			values[i] = new(sql.NullString)
		case oauthsession.FieldCreatedAt, oauthsession.FieldUpdatedAt, oauthsession.FieldExpiresAt, oauthsession.FieldCodeReceivedAt:
			values[i] = new(sql.NullTime)
		case oauthsession.FieldUserID:
			values[i] = new(uuid.UUID)
		default:
			values[i] = new(sql.UnknownType)
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the OauthSession fields.
func (_m *OauthSession) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case oauthsession.FieldID:
			value, ok := values[i].(*sql.NullInt64)
			if !ok {
				return fmt.Errorf("unexpected type %T for field id", value)
			}
			_m.ID = uint64(value.Int64)
		case oauthsession.FieldCreatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field created_at", values[i])
			} else if value.Valid {
				_m.CreatedAt = value.Time
			}
		case oauthsession.FieldUpdatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field updated_at", values[i])
			} else if value.Valid {
				_m.UpdatedAt = value.Time
			}
		case oauthsession.FieldStatus:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field status", values[i])
			} else if value.Valid {
				_m.Status = uint8(value.Int64)
			}
		case oauthsession.FieldTenantID:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field tenant_id", values[i])
			} else if value.Valid {
				_m.TenantID = uint64(value.Int64)
			}
		case oauthsession.FieldSessionID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field session_id", values[i])
			} else if value.Valid {
				_m.SessionID = value.String
			}
		case oauthsession.FieldState:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field state", values[i])
			} else if value.Valid {
				_m.State = value.String
			}
		case oauthsession.FieldProviderID:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field provider_id", values[i])
			} else if value.Valid {
				_m.ProviderID = uint64(value.Int64)
			}
		case oauthsession.FieldUserID:
			if value, ok := values[i].(*uuid.UUID); !ok {
				return fmt.Errorf("unexpected type %T for field user_id", values[i])
			} else if value != nil {
				_m.UserID = *value
			}
		case oauthsession.FieldRedirectURI:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field redirect_uri", values[i])
			} else if value.Valid {
				_m.RedirectURI = value.String
			}
		case oauthsession.FieldScope:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field scope", values[i])
			} else if value.Valid {
				_m.Scope = value.String
			}
		case oauthsession.FieldCodeChallenge:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field code_challenge", values[i])
			} else if value.Valid {
				_m.CodeChallenge = value.String
			}
		case oauthsession.FieldCodeChallengeMethod:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field code_challenge_method", values[i])
			} else if value.Valid {
				_m.CodeChallengeMethod = value.String
			}
		case oauthsession.FieldCodeVerifier:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field code_verifier", values[i])
			} else if value.Valid {
				_m.CodeVerifier = value.String
			}
		case oauthsession.FieldExpiresAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field expires_at", values[i])
			} else if value.Valid {
				_m.ExpiresAt = value.Time
			}
		case oauthsession.FieldClientIP:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field client_ip", values[i])
			} else if value.Valid {
				_m.ClientIP = value.String
			}
		case oauthsession.FieldUserAgent:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field user_agent", values[i])
			} else if value.Valid {
				_m.UserAgent = value.String
			}
		case oauthsession.FieldAuthorizationCode:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field authorization_code", values[i])
			} else if value.Valid {
				_m.AuthorizationCode = value.String
			}
		case oauthsession.FieldCodeReceivedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field code_received_at", values[i])
			} else if value.Valid {
				_m.CodeReceivedAt = value.Time
			}
		case oauthsession.FieldCallbackData:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field callback_data", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &_m.CallbackData); err != nil {
					return fmt.Errorf("unmarshal field callback_data: %w", err)
				}
			}
		case oauthsession.FieldErrorCode:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field error_code", values[i])
			} else if value.Valid {
				_m.ErrorCode = value.String
			}
		case oauthsession.FieldErrorDescription:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field error_description", values[i])
			} else if value.Valid {
				_m.ErrorDescription = value.String
			}
		case oauthsession.FieldRetryCount:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field retry_count", values[i])
			} else if value.Valid {
				_m.RetryCount = int(value.Int64)
			}
		case oauthsession.FieldDepartmentID:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field department_id", values[i])
			} else if value.Valid {
				_m.DepartmentID = uint64(value.Int64)
			}
		default:
			_m.selectValues.Set(columns[i], values[i])
		}
	}
	return nil
}

// Value returns the ent.Value that was dynamically selected and assigned to the OauthSession.
// This includes values selected through modifiers, order, etc.
func (_m *OauthSession) Value(name string) (ent.Value, error) {
	return _m.selectValues.Get(name)
}

// QueryProvider queries the "provider" edge of the OauthSession entity.
func (_m *OauthSession) QueryProvider() *OauthProviderQuery {
	return NewOauthSessionClient(_m.config).QueryProvider(_m)
}

// QueryUser queries the "user" edge of the OauthSession entity.
func (_m *OauthSession) QueryUser() *UserQuery {
	return NewOauthSessionClient(_m.config).QueryUser(_m)
}

// Update returns a builder for updating this OauthSession.
// Note that you need to call OauthSession.Unwrap() before calling this method if this OauthSession
// was returned from a transaction, and the transaction was committed or rolled back.
func (_m *OauthSession) Update() *OauthSessionUpdateOne {
	return NewOauthSessionClient(_m.config).UpdateOne(_m)
}

// Unwrap unwraps the OauthSession entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (_m *OauthSession) Unwrap() *OauthSession {
	_tx, ok := _m.config.driver.(*txDriver)
	if !ok {
		panic("ent: OauthSession is not a transactional entity")
	}
	_m.config.driver = _tx.drv
	return _m
}

// String implements the fmt.Stringer.
func (_m *OauthSession) String() string {
	var builder strings.Builder
	builder.WriteString("OauthSession(")
	builder.WriteString(fmt.Sprintf("id=%v, ", _m.ID))
	builder.WriteString("created_at=")
	builder.WriteString(_m.CreatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("updated_at=")
	builder.WriteString(_m.UpdatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("status=")
	builder.WriteString(fmt.Sprintf("%v", _m.Status))
	builder.WriteString(", ")
	builder.WriteString("tenant_id=")
	builder.WriteString(fmt.Sprintf("%v", _m.TenantID))
	builder.WriteString(", ")
	builder.WriteString("session_id=")
	builder.WriteString(_m.SessionID)
	builder.WriteString(", ")
	builder.WriteString("state=")
	builder.WriteString(_m.State)
	builder.WriteString(", ")
	builder.WriteString("provider_id=")
	builder.WriteString(fmt.Sprintf("%v", _m.ProviderID))
	builder.WriteString(", ")
	builder.WriteString("user_id=")
	builder.WriteString(fmt.Sprintf("%v", _m.UserID))
	builder.WriteString(", ")
	builder.WriteString("redirect_uri=")
	builder.WriteString(_m.RedirectURI)
	builder.WriteString(", ")
	builder.WriteString("scope=")
	builder.WriteString(_m.Scope)
	builder.WriteString(", ")
	builder.WriteString("code_challenge=")
	builder.WriteString(_m.CodeChallenge)
	builder.WriteString(", ")
	builder.WriteString("code_challenge_method=")
	builder.WriteString(_m.CodeChallengeMethod)
	builder.WriteString(", ")
	builder.WriteString("code_verifier=")
	builder.WriteString(_m.CodeVerifier)
	builder.WriteString(", ")
	builder.WriteString("expires_at=")
	builder.WriteString(_m.ExpiresAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("client_ip=")
	builder.WriteString(_m.ClientIP)
	builder.WriteString(", ")
	builder.WriteString("user_agent=")
	builder.WriteString(_m.UserAgent)
	builder.WriteString(", ")
	builder.WriteString("authorization_code=")
	builder.WriteString(_m.AuthorizationCode)
	builder.WriteString(", ")
	builder.WriteString("code_received_at=")
	builder.WriteString(_m.CodeReceivedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("callback_data=")
	builder.WriteString(fmt.Sprintf("%v", _m.CallbackData))
	builder.WriteString(", ")
	builder.WriteString("error_code=")
	builder.WriteString(_m.ErrorCode)
	builder.WriteString(", ")
	builder.WriteString("error_description=")
	builder.WriteString(_m.ErrorDescription)
	builder.WriteString(", ")
	builder.WriteString("retry_count=")
	builder.WriteString(fmt.Sprintf("%v", _m.RetryCount))
	builder.WriteString(", ")
	builder.WriteString("department_id=")
	builder.WriteString(fmt.Sprintf("%v", _m.DepartmentID))
	builder.WriteByte(')')
	return builder.String()
}

// OauthSessions is a parsable slice of OauthSession.
type OauthSessions []*OauthSession

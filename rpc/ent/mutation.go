// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/coder-lulu/newbee-core/rpc/ent/api"
	"github.com/coder-lulu/newbee-core/rpc/ent/auditlog"
	"github.com/coder-lulu/newbee-core/rpc/ent/casbinrule"
	"github.com/coder-lulu/newbee-core/rpc/ent/configuration"
	"github.com/coder-lulu/newbee-core/rpc/ent/department"
	"github.com/coder-lulu/newbee-core/rpc/ent/dictionary"
	"github.com/coder-lulu/newbee-core/rpc/ent/dictionarydetail"
	"github.com/coder-lulu/newbee-core/rpc/ent/menu"
	"github.com/coder-lulu/newbee-core/rpc/ent/oauthaccount"
	"github.com/coder-lulu/newbee-core/rpc/ent/oauthprovider"
	"github.com/coder-lulu/newbee-core/rpc/ent/oauthsession"
	"github.com/coder-lulu/newbee-core/rpc/ent/position"
	"github.com/coder-lulu/newbee-core/rpc/ent/predicate"
	"github.com/coder-lulu/newbee-core/rpc/ent/role"
	"github.com/coder-lulu/newbee-core/rpc/ent/tenant"
	"github.com/coder-lulu/newbee-core/rpc/ent/token"
	"github.com/coder-lulu/newbee-core/rpc/ent/user"
	uuid "github.com/gofrs/uuid/v5"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAPI              = "API"
	TypeAuditLog         = "AuditLog"
	TypeCasbinRule       = "CasbinRule"
	TypeConfiguration    = "Configuration"
	TypeDepartment       = "Department"
	TypeDictionary       = "Dictionary"
	TypeDictionaryDetail = "DictionaryDetail"
	TypeMenu             = "Menu"
	TypeOauthAccount     = "OauthAccount"
	TypeOauthProvider    = "OauthProvider"
	TypeOauthSession     = "OauthSession"
	TypePosition         = "Position"
	TypeRole             = "Role"
	TypeTenant           = "Tenant"
	TypeToken            = "Token"
	TypeUser             = "User"
)

// APIMutation represents an operation that mutates the API nodes in the graph.
type APIMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	created_at    *time.Time
	updated_at    *time.Time
	tenant_id     *uint64
	addtenant_id  *int64
	_path         *string
	description   *string
	api_group     *string
	service_name  *string
	method        *string
	is_required   *bool
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*API, error)
	predicates    []predicate.API
}

var _ ent.Mutation = (*APIMutation)(nil)

// apiOption allows management of the mutation configuration using functional options.
type apiOption func(*APIMutation)

// newAPIMutation creates new mutation for the API entity.
func newAPIMutation(c config, op Op, opts ...apiOption) *APIMutation {
	m := &APIMutation{
		config:        c,
		op:            op,
		typ:           TypeAPI,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAPIID sets the ID field of the mutation.
func withAPIID(id uint64) apiOption {
	return func(m *APIMutation) {
		var (
			err   error
			once  sync.Once
			value *API
		)
		m.oldValue = func(ctx context.Context) (*API, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().API.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAPI sets the old API of the mutation.
func withAPI(node *API) apiOption {
	return func(m *APIMutation) {
		m.oldValue = func(context.Context) (*API, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m APIMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m APIMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of API entities.
func (m *APIMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *APIMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *APIMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().API.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *APIMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *APIMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the API entity.
// If the API object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *APIMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *APIMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *APIMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the API entity.
// If the API object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *APIMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *APIMutation) SetTenantID(u uint64) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *APIMutation) TenantID() (r uint64, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the API entity.
// If the API object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldTenantID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *APIMutation) AddTenantID(u int64) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *APIMutation) AddedTenantID() (r int64, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *APIMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetPath sets the "path" field.
func (m *APIMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *APIMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the API entity.
// If the API object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ResetPath resets all changes to the "path" field.
func (m *APIMutation) ResetPath() {
	m._path = nil
}

// SetDescription sets the "description" field.
func (m *APIMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *APIMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the API entity.
// If the API object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *APIMutation) ResetDescription() {
	m.description = nil
}

// SetAPIGroup sets the "api_group" field.
func (m *APIMutation) SetAPIGroup(s string) {
	m.api_group = &s
}

// APIGroup returns the value of the "api_group" field in the mutation.
func (m *APIMutation) APIGroup() (r string, exists bool) {
	v := m.api_group
	if v == nil {
		return
	}
	return *v, true
}

// OldAPIGroup returns the old "api_group" field's value of the API entity.
// If the API object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldAPIGroup(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPIGroup is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPIGroup requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPIGroup: %w", err)
	}
	return oldValue.APIGroup, nil
}

// ResetAPIGroup resets all changes to the "api_group" field.
func (m *APIMutation) ResetAPIGroup() {
	m.api_group = nil
}

// SetServiceName sets the "service_name" field.
func (m *APIMutation) SetServiceName(s string) {
	m.service_name = &s
}

// ServiceName returns the value of the "service_name" field in the mutation.
func (m *APIMutation) ServiceName() (r string, exists bool) {
	v := m.service_name
	if v == nil {
		return
	}
	return *v, true
}

// OldServiceName returns the old "service_name" field's value of the API entity.
// If the API object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldServiceName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServiceName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServiceName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServiceName: %w", err)
	}
	return oldValue.ServiceName, nil
}

// ResetServiceName resets all changes to the "service_name" field.
func (m *APIMutation) ResetServiceName() {
	m.service_name = nil
}

// SetMethod sets the "method" field.
func (m *APIMutation) SetMethod(s string) {
	m.method = &s
}

// Method returns the value of the "method" field in the mutation.
func (m *APIMutation) Method() (r string, exists bool) {
	v := m.method
	if v == nil {
		return
	}
	return *v, true
}

// OldMethod returns the old "method" field's value of the API entity.
// If the API object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMethod: %w", err)
	}
	return oldValue.Method, nil
}

// ResetMethod resets all changes to the "method" field.
func (m *APIMutation) ResetMethod() {
	m.method = nil
}

// SetIsRequired sets the "is_required" field.
func (m *APIMutation) SetIsRequired(b bool) {
	m.is_required = &b
}

// IsRequired returns the value of the "is_required" field in the mutation.
func (m *APIMutation) IsRequired() (r bool, exists bool) {
	v := m.is_required
	if v == nil {
		return
	}
	return *v, true
}

// OldIsRequired returns the old "is_required" field's value of the API entity.
// If the API object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldIsRequired(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsRequired is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsRequired requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsRequired: %w", err)
	}
	return oldValue.IsRequired, nil
}

// ResetIsRequired resets all changes to the "is_required" field.
func (m *APIMutation) ResetIsRequired() {
	m.is_required = nil
}

// Where appends a list predicates to the APIMutation builder.
func (m *APIMutation) Where(ps ...predicate.API) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the APIMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *APIMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.API, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *APIMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *APIMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (API).
func (m *APIMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *APIMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, api.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, api.FieldUpdatedAt)
	}
	if m.tenant_id != nil {
		fields = append(fields, api.FieldTenantID)
	}
	if m._path != nil {
		fields = append(fields, api.FieldPath)
	}
	if m.description != nil {
		fields = append(fields, api.FieldDescription)
	}
	if m.api_group != nil {
		fields = append(fields, api.FieldAPIGroup)
	}
	if m.service_name != nil {
		fields = append(fields, api.FieldServiceName)
	}
	if m.method != nil {
		fields = append(fields, api.FieldMethod)
	}
	if m.is_required != nil {
		fields = append(fields, api.FieldIsRequired)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *APIMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case api.FieldCreatedAt:
		return m.CreatedAt()
	case api.FieldUpdatedAt:
		return m.UpdatedAt()
	case api.FieldTenantID:
		return m.TenantID()
	case api.FieldPath:
		return m.Path()
	case api.FieldDescription:
		return m.Description()
	case api.FieldAPIGroup:
		return m.APIGroup()
	case api.FieldServiceName:
		return m.ServiceName()
	case api.FieldMethod:
		return m.Method()
	case api.FieldIsRequired:
		return m.IsRequired()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *APIMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case api.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case api.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case api.FieldTenantID:
		return m.OldTenantID(ctx)
	case api.FieldPath:
		return m.OldPath(ctx)
	case api.FieldDescription:
		return m.OldDescription(ctx)
	case api.FieldAPIGroup:
		return m.OldAPIGroup(ctx)
	case api.FieldServiceName:
		return m.OldServiceName(ctx)
	case api.FieldMethod:
		return m.OldMethod(ctx)
	case api.FieldIsRequired:
		return m.OldIsRequired(ctx)
	}
	return nil, fmt.Errorf("unknown API field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *APIMutation) SetField(name string, value ent.Value) error {
	switch name {
	case api.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case api.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case api.FieldTenantID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case api.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case api.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case api.FieldAPIGroup:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPIGroup(v)
		return nil
	case api.FieldServiceName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServiceName(v)
		return nil
	case api.FieldMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMethod(v)
		return nil
	case api.FieldIsRequired:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsRequired(v)
		return nil
	}
	return fmt.Errorf("unknown API field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *APIMutation) AddedFields() []string {
	var fields []string
	if m.addtenant_id != nil {
		fields = append(fields, api.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *APIMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case api.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *APIMutation) AddField(name string, value ent.Value) error {
	switch name {
	case api.FieldTenantID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown API numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *APIMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *APIMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *APIMutation) ClearField(name string) error {
	return fmt.Errorf("unknown API nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *APIMutation) ResetField(name string) error {
	switch name {
	case api.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case api.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case api.FieldTenantID:
		m.ResetTenantID()
		return nil
	case api.FieldPath:
		m.ResetPath()
		return nil
	case api.FieldDescription:
		m.ResetDescription()
		return nil
	case api.FieldAPIGroup:
		m.ResetAPIGroup()
		return nil
	case api.FieldServiceName:
		m.ResetServiceName()
		return nil
	case api.FieldMethod:
		m.ResetMethod()
		return nil
	case api.FieldIsRequired:
		m.ResetIsRequired()
		return nil
	}
	return fmt.Errorf("unknown API field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *APIMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *APIMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *APIMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *APIMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *APIMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *APIMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *APIMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown API unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *APIMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown API edge %s", name)
}

// AuditLogMutation represents an operation that mutates the AuditLog nodes in the graph.
type AuditLogMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	created_at         *time.Time
	updated_at         *time.Time
	status             *uint8
	addstatus          *int8
	tenant_id          *string
	user_id            *string
	user_name          *string
	operation_type     *auditlog.OperationType
	resource_type      *string
	resource_id        *string
	request_method     *string
	request_path       *string
	request_data       *string
	response_status    *int
	addresponse_status *int
	response_data      *string
	ip_address         *string
	user_agent         *string
	duration_ms        *int64
	addduration_ms     *int64
	error_message      *string
	metadata           *map[string]interface{}
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*AuditLog, error)
	predicates         []predicate.AuditLog
}

var _ ent.Mutation = (*AuditLogMutation)(nil)

// auditlogOption allows management of the mutation configuration using functional options.
type auditlogOption func(*AuditLogMutation)

// newAuditLogMutation creates new mutation for the AuditLog entity.
func newAuditLogMutation(c config, op Op, opts ...auditlogOption) *AuditLogMutation {
	m := &AuditLogMutation{
		config:        c,
		op:            op,
		typ:           TypeAuditLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuditLogID sets the ID field of the mutation.
func withAuditLogID(id uuid.UUID) auditlogOption {
	return func(m *AuditLogMutation) {
		var (
			err   error
			once  sync.Once
			value *AuditLog
		)
		m.oldValue = func(ctx context.Context) (*AuditLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuditLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuditLog sets the old AuditLog of the mutation.
func withAuditLog(node *AuditLog) auditlogOption {
	return func(m *AuditLogMutation) {
		m.oldValue = func(context.Context) (*AuditLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuditLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuditLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AuditLog entities.
func (m *AuditLogMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuditLogMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuditLogMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AuditLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AuditLogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AuditLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AuditLogMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AuditLogMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AuditLogMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AuditLogMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *AuditLogMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *AuditLogMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *AuditLogMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *AuditLogMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *AuditLogMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[auditlog.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *AuditLogMutation) StatusCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *AuditLogMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, auditlog.FieldStatus)
}

// SetTenantID sets the "tenant_id" field.
func (m *AuditLogMutation) SetTenantID(s string) {
	m.tenant_id = &s
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *AuditLogMutation) TenantID() (r string, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldTenantID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *AuditLogMutation) ResetTenantID() {
	m.tenant_id = nil
}

// SetUserID sets the "user_id" field.
func (m *AuditLogMutation) SetUserID(s string) {
	m.user_id = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *AuditLogMutation) UserID() (r string, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *AuditLogMutation) ResetUserID() {
	m.user_id = nil
}

// SetUserName sets the "user_name" field.
func (m *AuditLogMutation) SetUserName(s string) {
	m.user_name = &s
}

// UserName returns the value of the "user_name" field in the mutation.
func (m *AuditLogMutation) UserName() (r string, exists bool) {
	v := m.user_name
	if v == nil {
		return
	}
	return *v, true
}

// OldUserName returns the old "user_name" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldUserName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserName: %w", err)
	}
	return oldValue.UserName, nil
}

// ClearUserName clears the value of the "user_name" field.
func (m *AuditLogMutation) ClearUserName() {
	m.user_name = nil
	m.clearedFields[auditlog.FieldUserName] = struct{}{}
}

// UserNameCleared returns if the "user_name" field was cleared in this mutation.
func (m *AuditLogMutation) UserNameCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldUserName]
	return ok
}

// ResetUserName resets all changes to the "user_name" field.
func (m *AuditLogMutation) ResetUserName() {
	m.user_name = nil
	delete(m.clearedFields, auditlog.FieldUserName)
}

// SetOperationType sets the "operation_type" field.
func (m *AuditLogMutation) SetOperationType(at auditlog.OperationType) {
	m.operation_type = &at
}

// OperationType returns the value of the "operation_type" field in the mutation.
func (m *AuditLogMutation) OperationType() (r auditlog.OperationType, exists bool) {
	v := m.operation_type
	if v == nil {
		return
	}
	return *v, true
}

// OldOperationType returns the old "operation_type" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldOperationType(ctx context.Context) (v auditlog.OperationType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperationType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperationType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperationType: %w", err)
	}
	return oldValue.OperationType, nil
}

// ResetOperationType resets all changes to the "operation_type" field.
func (m *AuditLogMutation) ResetOperationType() {
	m.operation_type = nil
}

// SetResourceType sets the "resource_type" field.
func (m *AuditLogMutation) SetResourceType(s string) {
	m.resource_type = &s
}

// ResourceType returns the value of the "resource_type" field in the mutation.
func (m *AuditLogMutation) ResourceType() (r string, exists bool) {
	v := m.resource_type
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceType returns the old "resource_type" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldResourceType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceType: %w", err)
	}
	return oldValue.ResourceType, nil
}

// ResetResourceType resets all changes to the "resource_type" field.
func (m *AuditLogMutation) ResetResourceType() {
	m.resource_type = nil
}

// SetResourceID sets the "resource_id" field.
func (m *AuditLogMutation) SetResourceID(s string) {
	m.resource_id = &s
}

// ResourceID returns the value of the "resource_id" field in the mutation.
func (m *AuditLogMutation) ResourceID() (r string, exists bool) {
	v := m.resource_id
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceID returns the old "resource_id" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldResourceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceID: %w", err)
	}
	return oldValue.ResourceID, nil
}

// ClearResourceID clears the value of the "resource_id" field.
func (m *AuditLogMutation) ClearResourceID() {
	m.resource_id = nil
	m.clearedFields[auditlog.FieldResourceID] = struct{}{}
}

// ResourceIDCleared returns if the "resource_id" field was cleared in this mutation.
func (m *AuditLogMutation) ResourceIDCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldResourceID]
	return ok
}

// ResetResourceID resets all changes to the "resource_id" field.
func (m *AuditLogMutation) ResetResourceID() {
	m.resource_id = nil
	delete(m.clearedFields, auditlog.FieldResourceID)
}

// SetRequestMethod sets the "request_method" field.
func (m *AuditLogMutation) SetRequestMethod(s string) {
	m.request_method = &s
}

// RequestMethod returns the value of the "request_method" field in the mutation.
func (m *AuditLogMutation) RequestMethod() (r string, exists bool) {
	v := m.request_method
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestMethod returns the old "request_method" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldRequestMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestMethod: %w", err)
	}
	return oldValue.RequestMethod, nil
}

// ResetRequestMethod resets all changes to the "request_method" field.
func (m *AuditLogMutation) ResetRequestMethod() {
	m.request_method = nil
}

// SetRequestPath sets the "request_path" field.
func (m *AuditLogMutation) SetRequestPath(s string) {
	m.request_path = &s
}

// RequestPath returns the value of the "request_path" field in the mutation.
func (m *AuditLogMutation) RequestPath() (r string, exists bool) {
	v := m.request_path
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestPath returns the old "request_path" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldRequestPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestPath: %w", err)
	}
	return oldValue.RequestPath, nil
}

// ResetRequestPath resets all changes to the "request_path" field.
func (m *AuditLogMutation) ResetRequestPath() {
	m.request_path = nil
}

// SetRequestData sets the "request_data" field.
func (m *AuditLogMutation) SetRequestData(s string) {
	m.request_data = &s
}

// RequestData returns the value of the "request_data" field in the mutation.
func (m *AuditLogMutation) RequestData() (r string, exists bool) {
	v := m.request_data
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestData returns the old "request_data" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldRequestData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestData: %w", err)
	}
	return oldValue.RequestData, nil
}

// ClearRequestData clears the value of the "request_data" field.
func (m *AuditLogMutation) ClearRequestData() {
	m.request_data = nil
	m.clearedFields[auditlog.FieldRequestData] = struct{}{}
}

// RequestDataCleared returns if the "request_data" field was cleared in this mutation.
func (m *AuditLogMutation) RequestDataCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldRequestData]
	return ok
}

// ResetRequestData resets all changes to the "request_data" field.
func (m *AuditLogMutation) ResetRequestData() {
	m.request_data = nil
	delete(m.clearedFields, auditlog.FieldRequestData)
}

// SetResponseStatus sets the "response_status" field.
func (m *AuditLogMutation) SetResponseStatus(i int) {
	m.response_status = &i
	m.addresponse_status = nil
}

// ResponseStatus returns the value of the "response_status" field in the mutation.
func (m *AuditLogMutation) ResponseStatus() (r int, exists bool) {
	v := m.response_status
	if v == nil {
		return
	}
	return *v, true
}

// OldResponseStatus returns the old "response_status" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldResponseStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponseStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponseStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponseStatus: %w", err)
	}
	return oldValue.ResponseStatus, nil
}

// AddResponseStatus adds i to the "response_status" field.
func (m *AuditLogMutation) AddResponseStatus(i int) {
	if m.addresponse_status != nil {
		*m.addresponse_status += i
	} else {
		m.addresponse_status = &i
	}
}

// AddedResponseStatus returns the value that was added to the "response_status" field in this mutation.
func (m *AuditLogMutation) AddedResponseStatus() (r int, exists bool) {
	v := m.addresponse_status
	if v == nil {
		return
	}
	return *v, true
}

// ResetResponseStatus resets all changes to the "response_status" field.
func (m *AuditLogMutation) ResetResponseStatus() {
	m.response_status = nil
	m.addresponse_status = nil
}

// SetResponseData sets the "response_data" field.
func (m *AuditLogMutation) SetResponseData(s string) {
	m.response_data = &s
}

// ResponseData returns the value of the "response_data" field in the mutation.
func (m *AuditLogMutation) ResponseData() (r string, exists bool) {
	v := m.response_data
	if v == nil {
		return
	}
	return *v, true
}

// OldResponseData returns the old "response_data" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldResponseData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponseData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponseData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponseData: %w", err)
	}
	return oldValue.ResponseData, nil
}

// ClearResponseData clears the value of the "response_data" field.
func (m *AuditLogMutation) ClearResponseData() {
	m.response_data = nil
	m.clearedFields[auditlog.FieldResponseData] = struct{}{}
}

// ResponseDataCleared returns if the "response_data" field was cleared in this mutation.
func (m *AuditLogMutation) ResponseDataCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldResponseData]
	return ok
}

// ResetResponseData resets all changes to the "response_data" field.
func (m *AuditLogMutation) ResetResponseData() {
	m.response_data = nil
	delete(m.clearedFields, auditlog.FieldResponseData)
}

// SetIPAddress sets the "ip_address" field.
func (m *AuditLogMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *AuditLogMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldIPAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *AuditLogMutation) ResetIPAddress() {
	m.ip_address = nil
}

// SetUserAgent sets the "user_agent" field.
func (m *AuditLogMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *AuditLogMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldUserAgent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "user_agent" field.
func (m *AuditLogMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[auditlog.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "user_agent" field was cleared in this mutation.
func (m *AuditLogMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *AuditLogMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, auditlog.FieldUserAgent)
}

// SetDurationMs sets the "duration_ms" field.
func (m *AuditLogMutation) SetDurationMs(i int64) {
	m.duration_ms = &i
	m.addduration_ms = nil
}

// DurationMs returns the value of the "duration_ms" field in the mutation.
func (m *AuditLogMutation) DurationMs() (r int64, exists bool) {
	v := m.duration_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldDurationMs returns the old "duration_ms" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldDurationMs(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDurationMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDurationMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDurationMs: %w", err)
	}
	return oldValue.DurationMs, nil
}

// AddDurationMs adds i to the "duration_ms" field.
func (m *AuditLogMutation) AddDurationMs(i int64) {
	if m.addduration_ms != nil {
		*m.addduration_ms += i
	} else {
		m.addduration_ms = &i
	}
}

// AddedDurationMs returns the value that was added to the "duration_ms" field in this mutation.
func (m *AuditLogMutation) AddedDurationMs() (r int64, exists bool) {
	v := m.addduration_ms
	if v == nil {
		return
	}
	return *v, true
}

// ResetDurationMs resets all changes to the "duration_ms" field.
func (m *AuditLogMutation) ResetDurationMs() {
	m.duration_ms = nil
	m.addduration_ms = nil
}

// SetErrorMessage sets the "error_message" field.
func (m *AuditLogMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *AuditLogMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldErrorMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *AuditLogMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[auditlog.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *AuditLogMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *AuditLogMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, auditlog.FieldErrorMessage)
}

// SetMetadata sets the "metadata" field.
func (m *AuditLogMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *AuditLogMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *AuditLogMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[auditlog.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *AuditLogMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *AuditLogMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, auditlog.FieldMetadata)
}

// Where appends a list predicates to the AuditLogMutation builder.
func (m *AuditLogMutation) Where(ps ...predicate.AuditLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AuditLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AuditLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AuditLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AuditLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AuditLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AuditLog).
func (m *AuditLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuditLogMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.created_at != nil {
		fields = append(fields, auditlog.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, auditlog.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, auditlog.FieldStatus)
	}
	if m.tenant_id != nil {
		fields = append(fields, auditlog.FieldTenantID)
	}
	if m.user_id != nil {
		fields = append(fields, auditlog.FieldUserID)
	}
	if m.user_name != nil {
		fields = append(fields, auditlog.FieldUserName)
	}
	if m.operation_type != nil {
		fields = append(fields, auditlog.FieldOperationType)
	}
	if m.resource_type != nil {
		fields = append(fields, auditlog.FieldResourceType)
	}
	if m.resource_id != nil {
		fields = append(fields, auditlog.FieldResourceID)
	}
	if m.request_method != nil {
		fields = append(fields, auditlog.FieldRequestMethod)
	}
	if m.request_path != nil {
		fields = append(fields, auditlog.FieldRequestPath)
	}
	if m.request_data != nil {
		fields = append(fields, auditlog.FieldRequestData)
	}
	if m.response_status != nil {
		fields = append(fields, auditlog.FieldResponseStatus)
	}
	if m.response_data != nil {
		fields = append(fields, auditlog.FieldResponseData)
	}
	if m.ip_address != nil {
		fields = append(fields, auditlog.FieldIPAddress)
	}
	if m.user_agent != nil {
		fields = append(fields, auditlog.FieldUserAgent)
	}
	if m.duration_ms != nil {
		fields = append(fields, auditlog.FieldDurationMs)
	}
	if m.error_message != nil {
		fields = append(fields, auditlog.FieldErrorMessage)
	}
	if m.metadata != nil {
		fields = append(fields, auditlog.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuditLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case auditlog.FieldCreatedAt:
		return m.CreatedAt()
	case auditlog.FieldUpdatedAt:
		return m.UpdatedAt()
	case auditlog.FieldStatus:
		return m.Status()
	case auditlog.FieldTenantID:
		return m.TenantID()
	case auditlog.FieldUserID:
		return m.UserID()
	case auditlog.FieldUserName:
		return m.UserName()
	case auditlog.FieldOperationType:
		return m.OperationType()
	case auditlog.FieldResourceType:
		return m.ResourceType()
	case auditlog.FieldResourceID:
		return m.ResourceID()
	case auditlog.FieldRequestMethod:
		return m.RequestMethod()
	case auditlog.FieldRequestPath:
		return m.RequestPath()
	case auditlog.FieldRequestData:
		return m.RequestData()
	case auditlog.FieldResponseStatus:
		return m.ResponseStatus()
	case auditlog.FieldResponseData:
		return m.ResponseData()
	case auditlog.FieldIPAddress:
		return m.IPAddress()
	case auditlog.FieldUserAgent:
		return m.UserAgent()
	case auditlog.FieldDurationMs:
		return m.DurationMs()
	case auditlog.FieldErrorMessage:
		return m.ErrorMessage()
	case auditlog.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuditLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case auditlog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case auditlog.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case auditlog.FieldStatus:
		return m.OldStatus(ctx)
	case auditlog.FieldTenantID:
		return m.OldTenantID(ctx)
	case auditlog.FieldUserID:
		return m.OldUserID(ctx)
	case auditlog.FieldUserName:
		return m.OldUserName(ctx)
	case auditlog.FieldOperationType:
		return m.OldOperationType(ctx)
	case auditlog.FieldResourceType:
		return m.OldResourceType(ctx)
	case auditlog.FieldResourceID:
		return m.OldResourceID(ctx)
	case auditlog.FieldRequestMethod:
		return m.OldRequestMethod(ctx)
	case auditlog.FieldRequestPath:
		return m.OldRequestPath(ctx)
	case auditlog.FieldRequestData:
		return m.OldRequestData(ctx)
	case auditlog.FieldResponseStatus:
		return m.OldResponseStatus(ctx)
	case auditlog.FieldResponseData:
		return m.OldResponseData(ctx)
	case auditlog.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case auditlog.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case auditlog.FieldDurationMs:
		return m.OldDurationMs(ctx)
	case auditlog.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case auditlog.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown AuditLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuditLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case auditlog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case auditlog.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case auditlog.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case auditlog.FieldTenantID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case auditlog.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case auditlog.FieldUserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserName(v)
		return nil
	case auditlog.FieldOperationType:
		v, ok := value.(auditlog.OperationType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperationType(v)
		return nil
	case auditlog.FieldResourceType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceType(v)
		return nil
	case auditlog.FieldResourceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceID(v)
		return nil
	case auditlog.FieldRequestMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestMethod(v)
		return nil
	case auditlog.FieldRequestPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestPath(v)
		return nil
	case auditlog.FieldRequestData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestData(v)
		return nil
	case auditlog.FieldResponseStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponseStatus(v)
		return nil
	case auditlog.FieldResponseData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponseData(v)
		return nil
	case auditlog.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case auditlog.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case auditlog.FieldDurationMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDurationMs(v)
		return nil
	case auditlog.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case auditlog.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown AuditLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuditLogMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, auditlog.FieldStatus)
	}
	if m.addresponse_status != nil {
		fields = append(fields, auditlog.FieldResponseStatus)
	}
	if m.addduration_ms != nil {
		fields = append(fields, auditlog.FieldDurationMs)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuditLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case auditlog.FieldStatus:
		return m.AddedStatus()
	case auditlog.FieldResponseStatus:
		return m.AddedResponseStatus()
	case auditlog.FieldDurationMs:
		return m.AddedDurationMs()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuditLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case auditlog.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case auditlog.FieldResponseStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddResponseStatus(v)
		return nil
	case auditlog.FieldDurationMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDurationMs(v)
		return nil
	}
	return fmt.Errorf("unknown AuditLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuditLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(auditlog.FieldStatus) {
		fields = append(fields, auditlog.FieldStatus)
	}
	if m.FieldCleared(auditlog.FieldUserName) {
		fields = append(fields, auditlog.FieldUserName)
	}
	if m.FieldCleared(auditlog.FieldResourceID) {
		fields = append(fields, auditlog.FieldResourceID)
	}
	if m.FieldCleared(auditlog.FieldRequestData) {
		fields = append(fields, auditlog.FieldRequestData)
	}
	if m.FieldCleared(auditlog.FieldResponseData) {
		fields = append(fields, auditlog.FieldResponseData)
	}
	if m.FieldCleared(auditlog.FieldUserAgent) {
		fields = append(fields, auditlog.FieldUserAgent)
	}
	if m.FieldCleared(auditlog.FieldErrorMessage) {
		fields = append(fields, auditlog.FieldErrorMessage)
	}
	if m.FieldCleared(auditlog.FieldMetadata) {
		fields = append(fields, auditlog.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuditLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuditLogMutation) ClearField(name string) error {
	switch name {
	case auditlog.FieldStatus:
		m.ClearStatus()
		return nil
	case auditlog.FieldUserName:
		m.ClearUserName()
		return nil
	case auditlog.FieldResourceID:
		m.ClearResourceID()
		return nil
	case auditlog.FieldRequestData:
		m.ClearRequestData()
		return nil
	case auditlog.FieldResponseData:
		m.ClearResponseData()
		return nil
	case auditlog.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	case auditlog.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	case auditlog.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown AuditLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuditLogMutation) ResetField(name string) error {
	switch name {
	case auditlog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case auditlog.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case auditlog.FieldStatus:
		m.ResetStatus()
		return nil
	case auditlog.FieldTenantID:
		m.ResetTenantID()
		return nil
	case auditlog.FieldUserID:
		m.ResetUserID()
		return nil
	case auditlog.FieldUserName:
		m.ResetUserName()
		return nil
	case auditlog.FieldOperationType:
		m.ResetOperationType()
		return nil
	case auditlog.FieldResourceType:
		m.ResetResourceType()
		return nil
	case auditlog.FieldResourceID:
		m.ResetResourceID()
		return nil
	case auditlog.FieldRequestMethod:
		m.ResetRequestMethod()
		return nil
	case auditlog.FieldRequestPath:
		m.ResetRequestPath()
		return nil
	case auditlog.FieldRequestData:
		m.ResetRequestData()
		return nil
	case auditlog.FieldResponseStatus:
		m.ResetResponseStatus()
		return nil
	case auditlog.FieldResponseData:
		m.ResetResponseData()
		return nil
	case auditlog.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case auditlog.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case auditlog.FieldDurationMs:
		m.ResetDurationMs()
		return nil
	case auditlog.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case auditlog.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown AuditLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuditLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuditLogMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuditLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuditLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuditLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuditLogMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuditLogMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AuditLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuditLogMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AuditLog edge %s", name)
}

// CasbinRuleMutation represents an operation that mutates the CasbinRule nodes in the graph.
type CasbinRuleMutation struct {
	config
	op               Op
	typ              string
	id               *uint64
	created_at       *time.Time
	updated_at       *time.Time
	status           *uint8
	addstatus        *int8
	tenant_id        *uint64
	addtenant_id     *int64
	ptype            *string
	v0               *string
	v1               *string
	v2               *string
	v3               *string
	v4               *string
	v5               *string
	service_name     *string
	rule_name        *string
	description      *string
	category         *string
	version          *string
	require_approval *bool
	approval_status  *casbinrule.ApprovalStatus
	approved_by      *uint64
	addapproved_by   *int64
	approved_at      *time.Time
	effective_from   *time.Time
	effective_to     *time.Time
	is_temporary     *bool
	metadata         *string
	tags             *string
	usage_count      *int64
	addusage_count   *int64
	last_used_at     *time.Time
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*CasbinRule, error)
	predicates       []predicate.CasbinRule
}

var _ ent.Mutation = (*CasbinRuleMutation)(nil)

// casbinruleOption allows management of the mutation configuration using functional options.
type casbinruleOption func(*CasbinRuleMutation)

// newCasbinRuleMutation creates new mutation for the CasbinRule entity.
func newCasbinRuleMutation(c config, op Op, opts ...casbinruleOption) *CasbinRuleMutation {
	m := &CasbinRuleMutation{
		config:        c,
		op:            op,
		typ:           TypeCasbinRule,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCasbinRuleID sets the ID field of the mutation.
func withCasbinRuleID(id uint64) casbinruleOption {
	return func(m *CasbinRuleMutation) {
		var (
			err   error
			once  sync.Once
			value *CasbinRule
		)
		m.oldValue = func(ctx context.Context) (*CasbinRule, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CasbinRule.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCasbinRule sets the old CasbinRule of the mutation.
func withCasbinRule(node *CasbinRule) casbinruleOption {
	return func(m *CasbinRuleMutation) {
		m.oldValue = func(context.Context) (*CasbinRule, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CasbinRuleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CasbinRuleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CasbinRule entities.
func (m *CasbinRuleMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CasbinRuleMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CasbinRuleMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CasbinRule.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CasbinRuleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CasbinRuleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CasbinRule entity.
// If the CasbinRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CasbinRuleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CasbinRuleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CasbinRuleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CasbinRuleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CasbinRule entity.
// If the CasbinRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CasbinRuleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CasbinRuleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *CasbinRuleMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *CasbinRuleMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the CasbinRule entity.
// If the CasbinRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CasbinRuleMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *CasbinRuleMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *CasbinRuleMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *CasbinRuleMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[casbinrule.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *CasbinRuleMutation) StatusCleared() bool {
	_, ok := m.clearedFields[casbinrule.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *CasbinRuleMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, casbinrule.FieldStatus)
}

// SetTenantID sets the "tenant_id" field.
func (m *CasbinRuleMutation) SetTenantID(u uint64) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *CasbinRuleMutation) TenantID() (r uint64, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the CasbinRule entity.
// If the CasbinRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CasbinRuleMutation) OldTenantID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *CasbinRuleMutation) AddTenantID(u int64) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *CasbinRuleMutation) AddedTenantID() (r int64, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *CasbinRuleMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetPtype sets the "ptype" field.
func (m *CasbinRuleMutation) SetPtype(s string) {
	m.ptype = &s
}

// Ptype returns the value of the "ptype" field in the mutation.
func (m *CasbinRuleMutation) Ptype() (r string, exists bool) {
	v := m.ptype
	if v == nil {
		return
	}
	return *v, true
}

// OldPtype returns the old "ptype" field's value of the CasbinRule entity.
// If the CasbinRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CasbinRuleMutation) OldPtype(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPtype is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPtype requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPtype: %w", err)
	}
	return oldValue.Ptype, nil
}

// ResetPtype resets all changes to the "ptype" field.
func (m *CasbinRuleMutation) ResetPtype() {
	m.ptype = nil
}

// SetV0 sets the "v0" field.
func (m *CasbinRuleMutation) SetV0(s string) {
	m.v0 = &s
}

// V0 returns the value of the "v0" field in the mutation.
func (m *CasbinRuleMutation) V0() (r string, exists bool) {
	v := m.v0
	if v == nil {
		return
	}
	return *v, true
}

// OldV0 returns the old "v0" field's value of the CasbinRule entity.
// If the CasbinRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CasbinRuleMutation) OldV0(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldV0 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldV0 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldV0: %w", err)
	}
	return oldValue.V0, nil
}

// ClearV0 clears the value of the "v0" field.
func (m *CasbinRuleMutation) ClearV0() {
	m.v0 = nil
	m.clearedFields[casbinrule.FieldV0] = struct{}{}
}

// V0Cleared returns if the "v0" field was cleared in this mutation.
func (m *CasbinRuleMutation) V0Cleared() bool {
	_, ok := m.clearedFields[casbinrule.FieldV0]
	return ok
}

// ResetV0 resets all changes to the "v0" field.
func (m *CasbinRuleMutation) ResetV0() {
	m.v0 = nil
	delete(m.clearedFields, casbinrule.FieldV0)
}

// SetV1 sets the "v1" field.
func (m *CasbinRuleMutation) SetV1(s string) {
	m.v1 = &s
}

// V1 returns the value of the "v1" field in the mutation.
func (m *CasbinRuleMutation) V1() (r string, exists bool) {
	v := m.v1
	if v == nil {
		return
	}
	return *v, true
}

// OldV1 returns the old "v1" field's value of the CasbinRule entity.
// If the CasbinRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CasbinRuleMutation) OldV1(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldV1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldV1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldV1: %w", err)
	}
	return oldValue.V1, nil
}

// ClearV1 clears the value of the "v1" field.
func (m *CasbinRuleMutation) ClearV1() {
	m.v1 = nil
	m.clearedFields[casbinrule.FieldV1] = struct{}{}
}

// V1Cleared returns if the "v1" field was cleared in this mutation.
func (m *CasbinRuleMutation) V1Cleared() bool {
	_, ok := m.clearedFields[casbinrule.FieldV1]
	return ok
}

// ResetV1 resets all changes to the "v1" field.
func (m *CasbinRuleMutation) ResetV1() {
	m.v1 = nil
	delete(m.clearedFields, casbinrule.FieldV1)
}

// SetV2 sets the "v2" field.
func (m *CasbinRuleMutation) SetV2(s string) {
	m.v2 = &s
}

// V2 returns the value of the "v2" field in the mutation.
func (m *CasbinRuleMutation) V2() (r string, exists bool) {
	v := m.v2
	if v == nil {
		return
	}
	return *v, true
}

// OldV2 returns the old "v2" field's value of the CasbinRule entity.
// If the CasbinRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CasbinRuleMutation) OldV2(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldV2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldV2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldV2: %w", err)
	}
	return oldValue.V2, nil
}

// ClearV2 clears the value of the "v2" field.
func (m *CasbinRuleMutation) ClearV2() {
	m.v2 = nil
	m.clearedFields[casbinrule.FieldV2] = struct{}{}
}

// V2Cleared returns if the "v2" field was cleared in this mutation.
func (m *CasbinRuleMutation) V2Cleared() bool {
	_, ok := m.clearedFields[casbinrule.FieldV2]
	return ok
}

// ResetV2 resets all changes to the "v2" field.
func (m *CasbinRuleMutation) ResetV2() {
	m.v2 = nil
	delete(m.clearedFields, casbinrule.FieldV2)
}

// SetV3 sets the "v3" field.
func (m *CasbinRuleMutation) SetV3(s string) {
	m.v3 = &s
}

// V3 returns the value of the "v3" field in the mutation.
func (m *CasbinRuleMutation) V3() (r string, exists bool) {
	v := m.v3
	if v == nil {
		return
	}
	return *v, true
}

// OldV3 returns the old "v3" field's value of the CasbinRule entity.
// If the CasbinRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CasbinRuleMutation) OldV3(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldV3 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldV3 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldV3: %w", err)
	}
	return oldValue.V3, nil
}

// ClearV3 clears the value of the "v3" field.
func (m *CasbinRuleMutation) ClearV3() {
	m.v3 = nil
	m.clearedFields[casbinrule.FieldV3] = struct{}{}
}

// V3Cleared returns if the "v3" field was cleared in this mutation.
func (m *CasbinRuleMutation) V3Cleared() bool {
	_, ok := m.clearedFields[casbinrule.FieldV3]
	return ok
}

// ResetV3 resets all changes to the "v3" field.
func (m *CasbinRuleMutation) ResetV3() {
	m.v3 = nil
	delete(m.clearedFields, casbinrule.FieldV3)
}

// SetV4 sets the "v4" field.
func (m *CasbinRuleMutation) SetV4(s string) {
	m.v4 = &s
}

// V4 returns the value of the "v4" field in the mutation.
func (m *CasbinRuleMutation) V4() (r string, exists bool) {
	v := m.v4
	if v == nil {
		return
	}
	return *v, true
}

// OldV4 returns the old "v4" field's value of the CasbinRule entity.
// If the CasbinRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CasbinRuleMutation) OldV4(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldV4 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldV4 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldV4: %w", err)
	}
	return oldValue.V4, nil
}

// ClearV4 clears the value of the "v4" field.
func (m *CasbinRuleMutation) ClearV4() {
	m.v4 = nil
	m.clearedFields[casbinrule.FieldV4] = struct{}{}
}

// V4Cleared returns if the "v4" field was cleared in this mutation.
func (m *CasbinRuleMutation) V4Cleared() bool {
	_, ok := m.clearedFields[casbinrule.FieldV4]
	return ok
}

// ResetV4 resets all changes to the "v4" field.
func (m *CasbinRuleMutation) ResetV4() {
	m.v4 = nil
	delete(m.clearedFields, casbinrule.FieldV4)
}

// SetV5 sets the "v5" field.
func (m *CasbinRuleMutation) SetV5(s string) {
	m.v5 = &s
}

// V5 returns the value of the "v5" field in the mutation.
func (m *CasbinRuleMutation) V5() (r string, exists bool) {
	v := m.v5
	if v == nil {
		return
	}
	return *v, true
}

// OldV5 returns the old "v5" field's value of the CasbinRule entity.
// If the CasbinRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CasbinRuleMutation) OldV5(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldV5 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldV5 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldV5: %w", err)
	}
	return oldValue.V5, nil
}

// ClearV5 clears the value of the "v5" field.
func (m *CasbinRuleMutation) ClearV5() {
	m.v5 = nil
	m.clearedFields[casbinrule.FieldV5] = struct{}{}
}

// V5Cleared returns if the "v5" field was cleared in this mutation.
func (m *CasbinRuleMutation) V5Cleared() bool {
	_, ok := m.clearedFields[casbinrule.FieldV5]
	return ok
}

// ResetV5 resets all changes to the "v5" field.
func (m *CasbinRuleMutation) ResetV5() {
	m.v5 = nil
	delete(m.clearedFields, casbinrule.FieldV5)
}

// SetServiceName sets the "service_name" field.
func (m *CasbinRuleMutation) SetServiceName(s string) {
	m.service_name = &s
}

// ServiceName returns the value of the "service_name" field in the mutation.
func (m *CasbinRuleMutation) ServiceName() (r string, exists bool) {
	v := m.service_name
	if v == nil {
		return
	}
	return *v, true
}

// OldServiceName returns the old "service_name" field's value of the CasbinRule entity.
// If the CasbinRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CasbinRuleMutation) OldServiceName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServiceName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServiceName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServiceName: %w", err)
	}
	return oldValue.ServiceName, nil
}

// ResetServiceName resets all changes to the "service_name" field.
func (m *CasbinRuleMutation) ResetServiceName() {
	m.service_name = nil
}

// SetRuleName sets the "rule_name" field.
func (m *CasbinRuleMutation) SetRuleName(s string) {
	m.rule_name = &s
}

// RuleName returns the value of the "rule_name" field in the mutation.
func (m *CasbinRuleMutation) RuleName() (r string, exists bool) {
	v := m.rule_name
	if v == nil {
		return
	}
	return *v, true
}

// OldRuleName returns the old "rule_name" field's value of the CasbinRule entity.
// If the CasbinRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CasbinRuleMutation) OldRuleName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRuleName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRuleName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRuleName: %w", err)
	}
	return oldValue.RuleName, nil
}

// ClearRuleName clears the value of the "rule_name" field.
func (m *CasbinRuleMutation) ClearRuleName() {
	m.rule_name = nil
	m.clearedFields[casbinrule.FieldRuleName] = struct{}{}
}

// RuleNameCleared returns if the "rule_name" field was cleared in this mutation.
func (m *CasbinRuleMutation) RuleNameCleared() bool {
	_, ok := m.clearedFields[casbinrule.FieldRuleName]
	return ok
}

// ResetRuleName resets all changes to the "rule_name" field.
func (m *CasbinRuleMutation) ResetRuleName() {
	m.rule_name = nil
	delete(m.clearedFields, casbinrule.FieldRuleName)
}

// SetDescription sets the "description" field.
func (m *CasbinRuleMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CasbinRuleMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the CasbinRule entity.
// If the CasbinRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CasbinRuleMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CasbinRuleMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[casbinrule.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CasbinRuleMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[casbinrule.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CasbinRuleMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, casbinrule.FieldDescription)
}

// SetCategory sets the "category" field.
func (m *CasbinRuleMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *CasbinRuleMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the CasbinRule entity.
// If the CasbinRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CasbinRuleMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *CasbinRuleMutation) ResetCategory() {
	m.category = nil
}

// SetVersion sets the "version" field.
func (m *CasbinRuleMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *CasbinRuleMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the CasbinRule entity.
// If the CasbinRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CasbinRuleMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *CasbinRuleMutation) ResetVersion() {
	m.version = nil
}

// SetRequireApproval sets the "require_approval" field.
func (m *CasbinRuleMutation) SetRequireApproval(b bool) {
	m.require_approval = &b
}

// RequireApproval returns the value of the "require_approval" field in the mutation.
func (m *CasbinRuleMutation) RequireApproval() (r bool, exists bool) {
	v := m.require_approval
	if v == nil {
		return
	}
	return *v, true
}

// OldRequireApproval returns the old "require_approval" field's value of the CasbinRule entity.
// If the CasbinRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CasbinRuleMutation) OldRequireApproval(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequireApproval is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequireApproval requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequireApproval: %w", err)
	}
	return oldValue.RequireApproval, nil
}

// ResetRequireApproval resets all changes to the "require_approval" field.
func (m *CasbinRuleMutation) ResetRequireApproval() {
	m.require_approval = nil
}

// SetApprovalStatus sets the "approval_status" field.
func (m *CasbinRuleMutation) SetApprovalStatus(cs casbinrule.ApprovalStatus) {
	m.approval_status = &cs
}

// ApprovalStatus returns the value of the "approval_status" field in the mutation.
func (m *CasbinRuleMutation) ApprovalStatus() (r casbinrule.ApprovalStatus, exists bool) {
	v := m.approval_status
	if v == nil {
		return
	}
	return *v, true
}

// OldApprovalStatus returns the old "approval_status" field's value of the CasbinRule entity.
// If the CasbinRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CasbinRuleMutation) OldApprovalStatus(ctx context.Context) (v casbinrule.ApprovalStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApprovalStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApprovalStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApprovalStatus: %w", err)
	}
	return oldValue.ApprovalStatus, nil
}

// ResetApprovalStatus resets all changes to the "approval_status" field.
func (m *CasbinRuleMutation) ResetApprovalStatus() {
	m.approval_status = nil
}

// SetApprovedBy sets the "approved_by" field.
func (m *CasbinRuleMutation) SetApprovedBy(u uint64) {
	m.approved_by = &u
	m.addapproved_by = nil
}

// ApprovedBy returns the value of the "approved_by" field in the mutation.
func (m *CasbinRuleMutation) ApprovedBy() (r uint64, exists bool) {
	v := m.approved_by
	if v == nil {
		return
	}
	return *v, true
}

// OldApprovedBy returns the old "approved_by" field's value of the CasbinRule entity.
// If the CasbinRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CasbinRuleMutation) OldApprovedBy(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApprovedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApprovedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApprovedBy: %w", err)
	}
	return oldValue.ApprovedBy, nil
}

// AddApprovedBy adds u to the "approved_by" field.
func (m *CasbinRuleMutation) AddApprovedBy(u int64) {
	if m.addapproved_by != nil {
		*m.addapproved_by += u
	} else {
		m.addapproved_by = &u
	}
}

// AddedApprovedBy returns the value that was added to the "approved_by" field in this mutation.
func (m *CasbinRuleMutation) AddedApprovedBy() (r int64, exists bool) {
	v := m.addapproved_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearApprovedBy clears the value of the "approved_by" field.
func (m *CasbinRuleMutation) ClearApprovedBy() {
	m.approved_by = nil
	m.addapproved_by = nil
	m.clearedFields[casbinrule.FieldApprovedBy] = struct{}{}
}

// ApprovedByCleared returns if the "approved_by" field was cleared in this mutation.
func (m *CasbinRuleMutation) ApprovedByCleared() bool {
	_, ok := m.clearedFields[casbinrule.FieldApprovedBy]
	return ok
}

// ResetApprovedBy resets all changes to the "approved_by" field.
func (m *CasbinRuleMutation) ResetApprovedBy() {
	m.approved_by = nil
	m.addapproved_by = nil
	delete(m.clearedFields, casbinrule.FieldApprovedBy)
}

// SetApprovedAt sets the "approved_at" field.
func (m *CasbinRuleMutation) SetApprovedAt(t time.Time) {
	m.approved_at = &t
}

// ApprovedAt returns the value of the "approved_at" field in the mutation.
func (m *CasbinRuleMutation) ApprovedAt() (r time.Time, exists bool) {
	v := m.approved_at
	if v == nil {
		return
	}
	return *v, true
}

// OldApprovedAt returns the old "approved_at" field's value of the CasbinRule entity.
// If the CasbinRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CasbinRuleMutation) OldApprovedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApprovedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApprovedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApprovedAt: %w", err)
	}
	return oldValue.ApprovedAt, nil
}

// ClearApprovedAt clears the value of the "approved_at" field.
func (m *CasbinRuleMutation) ClearApprovedAt() {
	m.approved_at = nil
	m.clearedFields[casbinrule.FieldApprovedAt] = struct{}{}
}

// ApprovedAtCleared returns if the "approved_at" field was cleared in this mutation.
func (m *CasbinRuleMutation) ApprovedAtCleared() bool {
	_, ok := m.clearedFields[casbinrule.FieldApprovedAt]
	return ok
}

// ResetApprovedAt resets all changes to the "approved_at" field.
func (m *CasbinRuleMutation) ResetApprovedAt() {
	m.approved_at = nil
	delete(m.clearedFields, casbinrule.FieldApprovedAt)
}

// SetEffectiveFrom sets the "effective_from" field.
func (m *CasbinRuleMutation) SetEffectiveFrom(t time.Time) {
	m.effective_from = &t
}

// EffectiveFrom returns the value of the "effective_from" field in the mutation.
func (m *CasbinRuleMutation) EffectiveFrom() (r time.Time, exists bool) {
	v := m.effective_from
	if v == nil {
		return
	}
	return *v, true
}

// OldEffectiveFrom returns the old "effective_from" field's value of the CasbinRule entity.
// If the CasbinRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CasbinRuleMutation) OldEffectiveFrom(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEffectiveFrom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEffectiveFrom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEffectiveFrom: %w", err)
	}
	return oldValue.EffectiveFrom, nil
}

// ClearEffectiveFrom clears the value of the "effective_from" field.
func (m *CasbinRuleMutation) ClearEffectiveFrom() {
	m.effective_from = nil
	m.clearedFields[casbinrule.FieldEffectiveFrom] = struct{}{}
}

// EffectiveFromCleared returns if the "effective_from" field was cleared in this mutation.
func (m *CasbinRuleMutation) EffectiveFromCleared() bool {
	_, ok := m.clearedFields[casbinrule.FieldEffectiveFrom]
	return ok
}

// ResetEffectiveFrom resets all changes to the "effective_from" field.
func (m *CasbinRuleMutation) ResetEffectiveFrom() {
	m.effective_from = nil
	delete(m.clearedFields, casbinrule.FieldEffectiveFrom)
}

// SetEffectiveTo sets the "effective_to" field.
func (m *CasbinRuleMutation) SetEffectiveTo(t time.Time) {
	m.effective_to = &t
}

// EffectiveTo returns the value of the "effective_to" field in the mutation.
func (m *CasbinRuleMutation) EffectiveTo() (r time.Time, exists bool) {
	v := m.effective_to
	if v == nil {
		return
	}
	return *v, true
}

// OldEffectiveTo returns the old "effective_to" field's value of the CasbinRule entity.
// If the CasbinRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CasbinRuleMutation) OldEffectiveTo(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEffectiveTo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEffectiveTo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEffectiveTo: %w", err)
	}
	return oldValue.EffectiveTo, nil
}

// ClearEffectiveTo clears the value of the "effective_to" field.
func (m *CasbinRuleMutation) ClearEffectiveTo() {
	m.effective_to = nil
	m.clearedFields[casbinrule.FieldEffectiveTo] = struct{}{}
}

// EffectiveToCleared returns if the "effective_to" field was cleared in this mutation.
func (m *CasbinRuleMutation) EffectiveToCleared() bool {
	_, ok := m.clearedFields[casbinrule.FieldEffectiveTo]
	return ok
}

// ResetEffectiveTo resets all changes to the "effective_to" field.
func (m *CasbinRuleMutation) ResetEffectiveTo() {
	m.effective_to = nil
	delete(m.clearedFields, casbinrule.FieldEffectiveTo)
}

// SetIsTemporary sets the "is_temporary" field.
func (m *CasbinRuleMutation) SetIsTemporary(b bool) {
	m.is_temporary = &b
}

// IsTemporary returns the value of the "is_temporary" field in the mutation.
func (m *CasbinRuleMutation) IsTemporary() (r bool, exists bool) {
	v := m.is_temporary
	if v == nil {
		return
	}
	return *v, true
}

// OldIsTemporary returns the old "is_temporary" field's value of the CasbinRule entity.
// If the CasbinRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CasbinRuleMutation) OldIsTemporary(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsTemporary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsTemporary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsTemporary: %w", err)
	}
	return oldValue.IsTemporary, nil
}

// ResetIsTemporary resets all changes to the "is_temporary" field.
func (m *CasbinRuleMutation) ResetIsTemporary() {
	m.is_temporary = nil
}

// SetMetadata sets the "metadata" field.
func (m *CasbinRuleMutation) SetMetadata(s string) {
	m.metadata = &s
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *CasbinRuleMutation) Metadata() (r string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the CasbinRule entity.
// If the CasbinRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CasbinRuleMutation) OldMetadata(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *CasbinRuleMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[casbinrule.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *CasbinRuleMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[casbinrule.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *CasbinRuleMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, casbinrule.FieldMetadata)
}

// SetTags sets the "tags" field.
func (m *CasbinRuleMutation) SetTags(s string) {
	m.tags = &s
}

// Tags returns the value of the "tags" field in the mutation.
func (m *CasbinRuleMutation) Tags() (r string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the CasbinRule entity.
// If the CasbinRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CasbinRuleMutation) OldTags(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// ClearTags clears the value of the "tags" field.
func (m *CasbinRuleMutation) ClearTags() {
	m.tags = nil
	m.clearedFields[casbinrule.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *CasbinRuleMutation) TagsCleared() bool {
	_, ok := m.clearedFields[casbinrule.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *CasbinRuleMutation) ResetTags() {
	m.tags = nil
	delete(m.clearedFields, casbinrule.FieldTags)
}

// SetUsageCount sets the "usage_count" field.
func (m *CasbinRuleMutation) SetUsageCount(i int64) {
	m.usage_count = &i
	m.addusage_count = nil
}

// UsageCount returns the value of the "usage_count" field in the mutation.
func (m *CasbinRuleMutation) UsageCount() (r int64, exists bool) {
	v := m.usage_count
	if v == nil {
		return
	}
	return *v, true
}

// OldUsageCount returns the old "usage_count" field's value of the CasbinRule entity.
// If the CasbinRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CasbinRuleMutation) OldUsageCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsageCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsageCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsageCount: %w", err)
	}
	return oldValue.UsageCount, nil
}

// AddUsageCount adds i to the "usage_count" field.
func (m *CasbinRuleMutation) AddUsageCount(i int64) {
	if m.addusage_count != nil {
		*m.addusage_count += i
	} else {
		m.addusage_count = &i
	}
}

// AddedUsageCount returns the value that was added to the "usage_count" field in this mutation.
func (m *CasbinRuleMutation) AddedUsageCount() (r int64, exists bool) {
	v := m.addusage_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetUsageCount resets all changes to the "usage_count" field.
func (m *CasbinRuleMutation) ResetUsageCount() {
	m.usage_count = nil
	m.addusage_count = nil
}

// SetLastUsedAt sets the "last_used_at" field.
func (m *CasbinRuleMutation) SetLastUsedAt(t time.Time) {
	m.last_used_at = &t
}

// LastUsedAt returns the value of the "last_used_at" field in the mutation.
func (m *CasbinRuleMutation) LastUsedAt() (r time.Time, exists bool) {
	v := m.last_used_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUsedAt returns the old "last_used_at" field's value of the CasbinRule entity.
// If the CasbinRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CasbinRuleMutation) OldLastUsedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUsedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUsedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUsedAt: %w", err)
	}
	return oldValue.LastUsedAt, nil
}

// ClearLastUsedAt clears the value of the "last_used_at" field.
func (m *CasbinRuleMutation) ClearLastUsedAt() {
	m.last_used_at = nil
	m.clearedFields[casbinrule.FieldLastUsedAt] = struct{}{}
}

// LastUsedAtCleared returns if the "last_used_at" field was cleared in this mutation.
func (m *CasbinRuleMutation) LastUsedAtCleared() bool {
	_, ok := m.clearedFields[casbinrule.FieldLastUsedAt]
	return ok
}

// ResetLastUsedAt resets all changes to the "last_used_at" field.
func (m *CasbinRuleMutation) ResetLastUsedAt() {
	m.last_used_at = nil
	delete(m.clearedFields, casbinrule.FieldLastUsedAt)
}

// Where appends a list predicates to the CasbinRuleMutation builder.
func (m *CasbinRuleMutation) Where(ps ...predicate.CasbinRule) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CasbinRuleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CasbinRuleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CasbinRule, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CasbinRuleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CasbinRuleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CasbinRule).
func (m *CasbinRuleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CasbinRuleMutation) Fields() []string {
	fields := make([]string, 0, 27)
	if m.created_at != nil {
		fields = append(fields, casbinrule.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, casbinrule.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, casbinrule.FieldStatus)
	}
	if m.tenant_id != nil {
		fields = append(fields, casbinrule.FieldTenantID)
	}
	if m.ptype != nil {
		fields = append(fields, casbinrule.FieldPtype)
	}
	if m.v0 != nil {
		fields = append(fields, casbinrule.FieldV0)
	}
	if m.v1 != nil {
		fields = append(fields, casbinrule.FieldV1)
	}
	if m.v2 != nil {
		fields = append(fields, casbinrule.FieldV2)
	}
	if m.v3 != nil {
		fields = append(fields, casbinrule.FieldV3)
	}
	if m.v4 != nil {
		fields = append(fields, casbinrule.FieldV4)
	}
	if m.v5 != nil {
		fields = append(fields, casbinrule.FieldV5)
	}
	if m.service_name != nil {
		fields = append(fields, casbinrule.FieldServiceName)
	}
	if m.rule_name != nil {
		fields = append(fields, casbinrule.FieldRuleName)
	}
	if m.description != nil {
		fields = append(fields, casbinrule.FieldDescription)
	}
	if m.category != nil {
		fields = append(fields, casbinrule.FieldCategory)
	}
	if m.version != nil {
		fields = append(fields, casbinrule.FieldVersion)
	}
	if m.require_approval != nil {
		fields = append(fields, casbinrule.FieldRequireApproval)
	}
	if m.approval_status != nil {
		fields = append(fields, casbinrule.FieldApprovalStatus)
	}
	if m.approved_by != nil {
		fields = append(fields, casbinrule.FieldApprovedBy)
	}
	if m.approved_at != nil {
		fields = append(fields, casbinrule.FieldApprovedAt)
	}
	if m.effective_from != nil {
		fields = append(fields, casbinrule.FieldEffectiveFrom)
	}
	if m.effective_to != nil {
		fields = append(fields, casbinrule.FieldEffectiveTo)
	}
	if m.is_temporary != nil {
		fields = append(fields, casbinrule.FieldIsTemporary)
	}
	if m.metadata != nil {
		fields = append(fields, casbinrule.FieldMetadata)
	}
	if m.tags != nil {
		fields = append(fields, casbinrule.FieldTags)
	}
	if m.usage_count != nil {
		fields = append(fields, casbinrule.FieldUsageCount)
	}
	if m.last_used_at != nil {
		fields = append(fields, casbinrule.FieldLastUsedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CasbinRuleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case casbinrule.FieldCreatedAt:
		return m.CreatedAt()
	case casbinrule.FieldUpdatedAt:
		return m.UpdatedAt()
	case casbinrule.FieldStatus:
		return m.Status()
	case casbinrule.FieldTenantID:
		return m.TenantID()
	case casbinrule.FieldPtype:
		return m.Ptype()
	case casbinrule.FieldV0:
		return m.V0()
	case casbinrule.FieldV1:
		return m.V1()
	case casbinrule.FieldV2:
		return m.V2()
	case casbinrule.FieldV3:
		return m.V3()
	case casbinrule.FieldV4:
		return m.V4()
	case casbinrule.FieldV5:
		return m.V5()
	case casbinrule.FieldServiceName:
		return m.ServiceName()
	case casbinrule.FieldRuleName:
		return m.RuleName()
	case casbinrule.FieldDescription:
		return m.Description()
	case casbinrule.FieldCategory:
		return m.Category()
	case casbinrule.FieldVersion:
		return m.Version()
	case casbinrule.FieldRequireApproval:
		return m.RequireApproval()
	case casbinrule.FieldApprovalStatus:
		return m.ApprovalStatus()
	case casbinrule.FieldApprovedBy:
		return m.ApprovedBy()
	case casbinrule.FieldApprovedAt:
		return m.ApprovedAt()
	case casbinrule.FieldEffectiveFrom:
		return m.EffectiveFrom()
	case casbinrule.FieldEffectiveTo:
		return m.EffectiveTo()
	case casbinrule.FieldIsTemporary:
		return m.IsTemporary()
	case casbinrule.FieldMetadata:
		return m.Metadata()
	case casbinrule.FieldTags:
		return m.Tags()
	case casbinrule.FieldUsageCount:
		return m.UsageCount()
	case casbinrule.FieldLastUsedAt:
		return m.LastUsedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CasbinRuleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case casbinrule.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case casbinrule.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case casbinrule.FieldStatus:
		return m.OldStatus(ctx)
	case casbinrule.FieldTenantID:
		return m.OldTenantID(ctx)
	case casbinrule.FieldPtype:
		return m.OldPtype(ctx)
	case casbinrule.FieldV0:
		return m.OldV0(ctx)
	case casbinrule.FieldV1:
		return m.OldV1(ctx)
	case casbinrule.FieldV2:
		return m.OldV2(ctx)
	case casbinrule.FieldV3:
		return m.OldV3(ctx)
	case casbinrule.FieldV4:
		return m.OldV4(ctx)
	case casbinrule.FieldV5:
		return m.OldV5(ctx)
	case casbinrule.FieldServiceName:
		return m.OldServiceName(ctx)
	case casbinrule.FieldRuleName:
		return m.OldRuleName(ctx)
	case casbinrule.FieldDescription:
		return m.OldDescription(ctx)
	case casbinrule.FieldCategory:
		return m.OldCategory(ctx)
	case casbinrule.FieldVersion:
		return m.OldVersion(ctx)
	case casbinrule.FieldRequireApproval:
		return m.OldRequireApproval(ctx)
	case casbinrule.FieldApprovalStatus:
		return m.OldApprovalStatus(ctx)
	case casbinrule.FieldApprovedBy:
		return m.OldApprovedBy(ctx)
	case casbinrule.FieldApprovedAt:
		return m.OldApprovedAt(ctx)
	case casbinrule.FieldEffectiveFrom:
		return m.OldEffectiveFrom(ctx)
	case casbinrule.FieldEffectiveTo:
		return m.OldEffectiveTo(ctx)
	case casbinrule.FieldIsTemporary:
		return m.OldIsTemporary(ctx)
	case casbinrule.FieldMetadata:
		return m.OldMetadata(ctx)
	case casbinrule.FieldTags:
		return m.OldTags(ctx)
	case casbinrule.FieldUsageCount:
		return m.OldUsageCount(ctx)
	case casbinrule.FieldLastUsedAt:
		return m.OldLastUsedAt(ctx)
	}
	return nil, fmt.Errorf("unknown CasbinRule field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CasbinRuleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case casbinrule.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case casbinrule.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case casbinrule.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case casbinrule.FieldTenantID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case casbinrule.FieldPtype:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPtype(v)
		return nil
	case casbinrule.FieldV0:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetV0(v)
		return nil
	case casbinrule.FieldV1:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetV1(v)
		return nil
	case casbinrule.FieldV2:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetV2(v)
		return nil
	case casbinrule.FieldV3:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetV3(v)
		return nil
	case casbinrule.FieldV4:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetV4(v)
		return nil
	case casbinrule.FieldV5:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetV5(v)
		return nil
	case casbinrule.FieldServiceName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServiceName(v)
		return nil
	case casbinrule.FieldRuleName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRuleName(v)
		return nil
	case casbinrule.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case casbinrule.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case casbinrule.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case casbinrule.FieldRequireApproval:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequireApproval(v)
		return nil
	case casbinrule.FieldApprovalStatus:
		v, ok := value.(casbinrule.ApprovalStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApprovalStatus(v)
		return nil
	case casbinrule.FieldApprovedBy:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApprovedBy(v)
		return nil
	case casbinrule.FieldApprovedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApprovedAt(v)
		return nil
	case casbinrule.FieldEffectiveFrom:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEffectiveFrom(v)
		return nil
	case casbinrule.FieldEffectiveTo:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEffectiveTo(v)
		return nil
	case casbinrule.FieldIsTemporary:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsTemporary(v)
		return nil
	case casbinrule.FieldMetadata:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case casbinrule.FieldTags:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case casbinrule.FieldUsageCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsageCount(v)
		return nil
	case casbinrule.FieldLastUsedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUsedAt(v)
		return nil
	}
	return fmt.Errorf("unknown CasbinRule field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CasbinRuleMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, casbinrule.FieldStatus)
	}
	if m.addtenant_id != nil {
		fields = append(fields, casbinrule.FieldTenantID)
	}
	if m.addapproved_by != nil {
		fields = append(fields, casbinrule.FieldApprovedBy)
	}
	if m.addusage_count != nil {
		fields = append(fields, casbinrule.FieldUsageCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CasbinRuleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case casbinrule.FieldStatus:
		return m.AddedStatus()
	case casbinrule.FieldTenantID:
		return m.AddedTenantID()
	case casbinrule.FieldApprovedBy:
		return m.AddedApprovedBy()
	case casbinrule.FieldUsageCount:
		return m.AddedUsageCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CasbinRuleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case casbinrule.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case casbinrule.FieldTenantID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case casbinrule.FieldApprovedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddApprovedBy(v)
		return nil
	case casbinrule.FieldUsageCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUsageCount(v)
		return nil
	}
	return fmt.Errorf("unknown CasbinRule numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CasbinRuleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(casbinrule.FieldStatus) {
		fields = append(fields, casbinrule.FieldStatus)
	}
	if m.FieldCleared(casbinrule.FieldV0) {
		fields = append(fields, casbinrule.FieldV0)
	}
	if m.FieldCleared(casbinrule.FieldV1) {
		fields = append(fields, casbinrule.FieldV1)
	}
	if m.FieldCleared(casbinrule.FieldV2) {
		fields = append(fields, casbinrule.FieldV2)
	}
	if m.FieldCleared(casbinrule.FieldV3) {
		fields = append(fields, casbinrule.FieldV3)
	}
	if m.FieldCleared(casbinrule.FieldV4) {
		fields = append(fields, casbinrule.FieldV4)
	}
	if m.FieldCleared(casbinrule.FieldV5) {
		fields = append(fields, casbinrule.FieldV5)
	}
	if m.FieldCleared(casbinrule.FieldRuleName) {
		fields = append(fields, casbinrule.FieldRuleName)
	}
	if m.FieldCleared(casbinrule.FieldDescription) {
		fields = append(fields, casbinrule.FieldDescription)
	}
	if m.FieldCleared(casbinrule.FieldApprovedBy) {
		fields = append(fields, casbinrule.FieldApprovedBy)
	}
	if m.FieldCleared(casbinrule.FieldApprovedAt) {
		fields = append(fields, casbinrule.FieldApprovedAt)
	}
	if m.FieldCleared(casbinrule.FieldEffectiveFrom) {
		fields = append(fields, casbinrule.FieldEffectiveFrom)
	}
	if m.FieldCleared(casbinrule.FieldEffectiveTo) {
		fields = append(fields, casbinrule.FieldEffectiveTo)
	}
	if m.FieldCleared(casbinrule.FieldMetadata) {
		fields = append(fields, casbinrule.FieldMetadata)
	}
	if m.FieldCleared(casbinrule.FieldTags) {
		fields = append(fields, casbinrule.FieldTags)
	}
	if m.FieldCleared(casbinrule.FieldLastUsedAt) {
		fields = append(fields, casbinrule.FieldLastUsedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CasbinRuleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CasbinRuleMutation) ClearField(name string) error {
	switch name {
	case casbinrule.FieldStatus:
		m.ClearStatus()
		return nil
	case casbinrule.FieldV0:
		m.ClearV0()
		return nil
	case casbinrule.FieldV1:
		m.ClearV1()
		return nil
	case casbinrule.FieldV2:
		m.ClearV2()
		return nil
	case casbinrule.FieldV3:
		m.ClearV3()
		return nil
	case casbinrule.FieldV4:
		m.ClearV4()
		return nil
	case casbinrule.FieldV5:
		m.ClearV5()
		return nil
	case casbinrule.FieldRuleName:
		m.ClearRuleName()
		return nil
	case casbinrule.FieldDescription:
		m.ClearDescription()
		return nil
	case casbinrule.FieldApprovedBy:
		m.ClearApprovedBy()
		return nil
	case casbinrule.FieldApprovedAt:
		m.ClearApprovedAt()
		return nil
	case casbinrule.FieldEffectiveFrom:
		m.ClearEffectiveFrom()
		return nil
	case casbinrule.FieldEffectiveTo:
		m.ClearEffectiveTo()
		return nil
	case casbinrule.FieldMetadata:
		m.ClearMetadata()
		return nil
	case casbinrule.FieldTags:
		m.ClearTags()
		return nil
	case casbinrule.FieldLastUsedAt:
		m.ClearLastUsedAt()
		return nil
	}
	return fmt.Errorf("unknown CasbinRule nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CasbinRuleMutation) ResetField(name string) error {
	switch name {
	case casbinrule.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case casbinrule.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case casbinrule.FieldStatus:
		m.ResetStatus()
		return nil
	case casbinrule.FieldTenantID:
		m.ResetTenantID()
		return nil
	case casbinrule.FieldPtype:
		m.ResetPtype()
		return nil
	case casbinrule.FieldV0:
		m.ResetV0()
		return nil
	case casbinrule.FieldV1:
		m.ResetV1()
		return nil
	case casbinrule.FieldV2:
		m.ResetV2()
		return nil
	case casbinrule.FieldV3:
		m.ResetV3()
		return nil
	case casbinrule.FieldV4:
		m.ResetV4()
		return nil
	case casbinrule.FieldV5:
		m.ResetV5()
		return nil
	case casbinrule.FieldServiceName:
		m.ResetServiceName()
		return nil
	case casbinrule.FieldRuleName:
		m.ResetRuleName()
		return nil
	case casbinrule.FieldDescription:
		m.ResetDescription()
		return nil
	case casbinrule.FieldCategory:
		m.ResetCategory()
		return nil
	case casbinrule.FieldVersion:
		m.ResetVersion()
		return nil
	case casbinrule.FieldRequireApproval:
		m.ResetRequireApproval()
		return nil
	case casbinrule.FieldApprovalStatus:
		m.ResetApprovalStatus()
		return nil
	case casbinrule.FieldApprovedBy:
		m.ResetApprovedBy()
		return nil
	case casbinrule.FieldApprovedAt:
		m.ResetApprovedAt()
		return nil
	case casbinrule.FieldEffectiveFrom:
		m.ResetEffectiveFrom()
		return nil
	case casbinrule.FieldEffectiveTo:
		m.ResetEffectiveTo()
		return nil
	case casbinrule.FieldIsTemporary:
		m.ResetIsTemporary()
		return nil
	case casbinrule.FieldMetadata:
		m.ResetMetadata()
		return nil
	case casbinrule.FieldTags:
		m.ResetTags()
		return nil
	case casbinrule.FieldUsageCount:
		m.ResetUsageCount()
		return nil
	case casbinrule.FieldLastUsedAt:
		m.ResetLastUsedAt()
		return nil
	}
	return fmt.Errorf("unknown CasbinRule field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CasbinRuleMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CasbinRuleMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CasbinRuleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CasbinRuleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CasbinRuleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CasbinRuleMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CasbinRuleMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CasbinRule unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CasbinRuleMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CasbinRule edge %s", name)
}

// ConfigurationMutation represents an operation that mutates the Configuration nodes in the graph.
type ConfigurationMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	created_at    *time.Time
	updated_at    *time.Time
	sort          *uint32
	addsort       *int32
	state         *bool
	tenant_id     *uint64
	addtenant_id  *int64
	name          *string
	key           *string
	value         *string
	category      *string
	remark        *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Configuration, error)
	predicates    []predicate.Configuration
}

var _ ent.Mutation = (*ConfigurationMutation)(nil)

// configurationOption allows management of the mutation configuration using functional options.
type configurationOption func(*ConfigurationMutation)

// newConfigurationMutation creates new mutation for the Configuration entity.
func newConfigurationMutation(c config, op Op, opts ...configurationOption) *ConfigurationMutation {
	m := &ConfigurationMutation{
		config:        c,
		op:            op,
		typ:           TypeConfiguration,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withConfigurationID sets the ID field of the mutation.
func withConfigurationID(id uint64) configurationOption {
	return func(m *ConfigurationMutation) {
		var (
			err   error
			once  sync.Once
			value *Configuration
		)
		m.oldValue = func(ctx context.Context) (*Configuration, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Configuration.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withConfiguration sets the old Configuration of the mutation.
func withConfiguration(node *Configuration) configurationOption {
	return func(m *ConfigurationMutation) {
		m.oldValue = func(context.Context) (*Configuration, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ConfigurationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ConfigurationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Configuration entities.
func (m *ConfigurationMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ConfigurationMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ConfigurationMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Configuration.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ConfigurationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ConfigurationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Configuration entity.
// If the Configuration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ConfigurationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ConfigurationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ConfigurationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Configuration entity.
// If the Configuration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ConfigurationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetSort sets the "sort" field.
func (m *ConfigurationMutation) SetSort(u uint32) {
	m.sort = &u
	m.addsort = nil
}

// Sort returns the value of the "sort" field in the mutation.
func (m *ConfigurationMutation) Sort() (r uint32, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the Configuration entity.
// If the Configuration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationMutation) OldSort(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// AddSort adds u to the "sort" field.
func (m *ConfigurationMutation) AddSort(u int32) {
	if m.addsort != nil {
		*m.addsort += u
	} else {
		m.addsort = &u
	}
}

// AddedSort returns the value that was added to the "sort" field in this mutation.
func (m *ConfigurationMutation) AddedSort() (r int32, exists bool) {
	v := m.addsort
	if v == nil {
		return
	}
	return *v, true
}

// ResetSort resets all changes to the "sort" field.
func (m *ConfigurationMutation) ResetSort() {
	m.sort = nil
	m.addsort = nil
}

// SetState sets the "state" field.
func (m *ConfigurationMutation) SetState(b bool) {
	m.state = &b
}

// State returns the value of the "state" field in the mutation.
func (m *ConfigurationMutation) State() (r bool, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the Configuration entity.
// If the Configuration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationMutation) OldState(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ClearState clears the value of the "state" field.
func (m *ConfigurationMutation) ClearState() {
	m.state = nil
	m.clearedFields[configuration.FieldState] = struct{}{}
}

// StateCleared returns if the "state" field was cleared in this mutation.
func (m *ConfigurationMutation) StateCleared() bool {
	_, ok := m.clearedFields[configuration.FieldState]
	return ok
}

// ResetState resets all changes to the "state" field.
func (m *ConfigurationMutation) ResetState() {
	m.state = nil
	delete(m.clearedFields, configuration.FieldState)
}

// SetTenantID sets the "tenant_id" field.
func (m *ConfigurationMutation) SetTenantID(u uint64) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ConfigurationMutation) TenantID() (r uint64, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Configuration entity.
// If the Configuration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationMutation) OldTenantID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *ConfigurationMutation) AddTenantID(u int64) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *ConfigurationMutation) AddedTenantID() (r int64, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ConfigurationMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetName sets the "name" field.
func (m *ConfigurationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ConfigurationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Configuration entity.
// If the Configuration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ConfigurationMutation) ResetName() {
	m.name = nil
}

// SetKey sets the "key" field.
func (m *ConfigurationMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *ConfigurationMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the Configuration entity.
// If the Configuration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *ConfigurationMutation) ResetKey() {
	m.key = nil
}

// SetValue sets the "value" field.
func (m *ConfigurationMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *ConfigurationMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Configuration entity.
// If the Configuration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *ConfigurationMutation) ResetValue() {
	m.value = nil
}

// SetCategory sets the "category" field.
func (m *ConfigurationMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *ConfigurationMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the Configuration entity.
// If the Configuration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *ConfigurationMutation) ResetCategory() {
	m.category = nil
}

// SetRemark sets the "remark" field.
func (m *ConfigurationMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *ConfigurationMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Configuration entity.
// If the Configuration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *ConfigurationMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[configuration.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *ConfigurationMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[configuration.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *ConfigurationMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, configuration.FieldRemark)
}

// Where appends a list predicates to the ConfigurationMutation builder.
func (m *ConfigurationMutation) Where(ps ...predicate.Configuration) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ConfigurationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ConfigurationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Configuration, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ConfigurationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ConfigurationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Configuration).
func (m *ConfigurationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ConfigurationMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, configuration.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, configuration.FieldUpdatedAt)
	}
	if m.sort != nil {
		fields = append(fields, configuration.FieldSort)
	}
	if m.state != nil {
		fields = append(fields, configuration.FieldState)
	}
	if m.tenant_id != nil {
		fields = append(fields, configuration.FieldTenantID)
	}
	if m.name != nil {
		fields = append(fields, configuration.FieldName)
	}
	if m.key != nil {
		fields = append(fields, configuration.FieldKey)
	}
	if m.value != nil {
		fields = append(fields, configuration.FieldValue)
	}
	if m.category != nil {
		fields = append(fields, configuration.FieldCategory)
	}
	if m.remark != nil {
		fields = append(fields, configuration.FieldRemark)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ConfigurationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case configuration.FieldCreatedAt:
		return m.CreatedAt()
	case configuration.FieldUpdatedAt:
		return m.UpdatedAt()
	case configuration.FieldSort:
		return m.Sort()
	case configuration.FieldState:
		return m.State()
	case configuration.FieldTenantID:
		return m.TenantID()
	case configuration.FieldName:
		return m.Name()
	case configuration.FieldKey:
		return m.Key()
	case configuration.FieldValue:
		return m.Value()
	case configuration.FieldCategory:
		return m.Category()
	case configuration.FieldRemark:
		return m.Remark()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ConfigurationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case configuration.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case configuration.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case configuration.FieldSort:
		return m.OldSort(ctx)
	case configuration.FieldState:
		return m.OldState(ctx)
	case configuration.FieldTenantID:
		return m.OldTenantID(ctx)
	case configuration.FieldName:
		return m.OldName(ctx)
	case configuration.FieldKey:
		return m.OldKey(ctx)
	case configuration.FieldValue:
		return m.OldValue(ctx)
	case configuration.FieldCategory:
		return m.OldCategory(ctx)
	case configuration.FieldRemark:
		return m.OldRemark(ctx)
	}
	return nil, fmt.Errorf("unknown Configuration field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConfigurationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case configuration.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case configuration.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case configuration.FieldSort:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	case configuration.FieldState:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case configuration.FieldTenantID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case configuration.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case configuration.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case configuration.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case configuration.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case configuration.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	}
	return fmt.Errorf("unknown Configuration field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ConfigurationMutation) AddedFields() []string {
	var fields []string
	if m.addsort != nil {
		fields = append(fields, configuration.FieldSort)
	}
	if m.addtenant_id != nil {
		fields = append(fields, configuration.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ConfigurationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case configuration.FieldSort:
		return m.AddedSort()
	case configuration.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConfigurationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case configuration.FieldSort:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSort(v)
		return nil
	case configuration.FieldTenantID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown Configuration numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ConfigurationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(configuration.FieldState) {
		fields = append(fields, configuration.FieldState)
	}
	if m.FieldCleared(configuration.FieldRemark) {
		fields = append(fields, configuration.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ConfigurationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ConfigurationMutation) ClearField(name string) error {
	switch name {
	case configuration.FieldState:
		m.ClearState()
		return nil
	case configuration.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown Configuration nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ConfigurationMutation) ResetField(name string) error {
	switch name {
	case configuration.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case configuration.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case configuration.FieldSort:
		m.ResetSort()
		return nil
	case configuration.FieldState:
		m.ResetState()
		return nil
	case configuration.FieldTenantID:
		m.ResetTenantID()
		return nil
	case configuration.FieldName:
		m.ResetName()
		return nil
	case configuration.FieldKey:
		m.ResetKey()
		return nil
	case configuration.FieldValue:
		m.ResetValue()
		return nil
	case configuration.FieldCategory:
		m.ResetCategory()
		return nil
	case configuration.FieldRemark:
		m.ResetRemark()
		return nil
	}
	return fmt.Errorf("unknown Configuration field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ConfigurationMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ConfigurationMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ConfigurationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ConfigurationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ConfigurationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ConfigurationMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ConfigurationMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Configuration unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ConfigurationMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Configuration edge %s", name)
}

// DepartmentMutation represents an operation that mutates the Department nodes in the graph.
type DepartmentMutation struct {
	config
	op              Op
	typ             string
	id              *uint64
	created_at      *time.Time
	updated_at      *time.Time
	status          *uint8
	addstatus       *int8
	sort            *uint32
	addsort         *int32
	tenant_id       *uint64
	addtenant_id    *int64
	name            *string
	ancestors       *string
	leader          *string
	phone           *string
	email           *string
	remark          *string
	clearedFields   map[string]struct{}
	parent          *uint64
	clearedparent   bool
	children        map[uint64]struct{}
	removedchildren map[uint64]struct{}
	clearedchildren bool
	users           map[uuid.UUID]struct{}
	removedusers    map[uuid.UUID]struct{}
	clearedusers    bool
	posts           map[uint64]struct{}
	removedposts    map[uint64]struct{}
	clearedposts    bool
	done            bool
	oldValue        func(context.Context) (*Department, error)
	predicates      []predicate.Department
}

var _ ent.Mutation = (*DepartmentMutation)(nil)

// departmentOption allows management of the mutation configuration using functional options.
type departmentOption func(*DepartmentMutation)

// newDepartmentMutation creates new mutation for the Department entity.
func newDepartmentMutation(c config, op Op, opts ...departmentOption) *DepartmentMutation {
	m := &DepartmentMutation{
		config:        c,
		op:            op,
		typ:           TypeDepartment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDepartmentID sets the ID field of the mutation.
func withDepartmentID(id uint64) departmentOption {
	return func(m *DepartmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Department
		)
		m.oldValue = func(ctx context.Context) (*Department, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Department.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDepartment sets the old Department of the mutation.
func withDepartment(node *Department) departmentOption {
	return func(m *DepartmentMutation) {
		m.oldValue = func(context.Context) (*Department, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DepartmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DepartmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Department entities.
func (m *DepartmentMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DepartmentMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DepartmentMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Department.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DepartmentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DepartmentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DepartmentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DepartmentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DepartmentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DepartmentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *DepartmentMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *DepartmentMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *DepartmentMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *DepartmentMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *DepartmentMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[department.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *DepartmentMutation) StatusCleared() bool {
	_, ok := m.clearedFields[department.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *DepartmentMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, department.FieldStatus)
}

// SetSort sets the "sort" field.
func (m *DepartmentMutation) SetSort(u uint32) {
	m.sort = &u
	m.addsort = nil
}

// Sort returns the value of the "sort" field in the mutation.
func (m *DepartmentMutation) Sort() (r uint32, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldSort(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// AddSort adds u to the "sort" field.
func (m *DepartmentMutation) AddSort(u int32) {
	if m.addsort != nil {
		*m.addsort += u
	} else {
		m.addsort = &u
	}
}

// AddedSort returns the value that was added to the "sort" field in this mutation.
func (m *DepartmentMutation) AddedSort() (r int32, exists bool) {
	v := m.addsort
	if v == nil {
		return
	}
	return *v, true
}

// ResetSort resets all changes to the "sort" field.
func (m *DepartmentMutation) ResetSort() {
	m.sort = nil
	m.addsort = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *DepartmentMutation) SetTenantID(u uint64) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *DepartmentMutation) TenantID() (r uint64, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldTenantID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *DepartmentMutation) AddTenantID(u int64) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *DepartmentMutation) AddedTenantID() (r int64, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *DepartmentMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetName sets the "name" field.
func (m *DepartmentMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DepartmentMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DepartmentMutation) ResetName() {
	m.name = nil
}

// SetAncestors sets the "ancestors" field.
func (m *DepartmentMutation) SetAncestors(s string) {
	m.ancestors = &s
}

// Ancestors returns the value of the "ancestors" field in the mutation.
func (m *DepartmentMutation) Ancestors() (r string, exists bool) {
	v := m.ancestors
	if v == nil {
		return
	}
	return *v, true
}

// OldAncestors returns the old "ancestors" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldAncestors(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAncestors is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAncestors requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAncestors: %w", err)
	}
	return oldValue.Ancestors, nil
}

// ClearAncestors clears the value of the "ancestors" field.
func (m *DepartmentMutation) ClearAncestors() {
	m.ancestors = nil
	m.clearedFields[department.FieldAncestors] = struct{}{}
}

// AncestorsCleared returns if the "ancestors" field was cleared in this mutation.
func (m *DepartmentMutation) AncestorsCleared() bool {
	_, ok := m.clearedFields[department.FieldAncestors]
	return ok
}

// ResetAncestors resets all changes to the "ancestors" field.
func (m *DepartmentMutation) ResetAncestors() {
	m.ancestors = nil
	delete(m.clearedFields, department.FieldAncestors)
}

// SetLeader sets the "leader" field.
func (m *DepartmentMutation) SetLeader(s string) {
	m.leader = &s
}

// Leader returns the value of the "leader" field in the mutation.
func (m *DepartmentMutation) Leader() (r string, exists bool) {
	v := m.leader
	if v == nil {
		return
	}
	return *v, true
}

// OldLeader returns the old "leader" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldLeader(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLeader is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLeader requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLeader: %w", err)
	}
	return oldValue.Leader, nil
}

// ClearLeader clears the value of the "leader" field.
func (m *DepartmentMutation) ClearLeader() {
	m.leader = nil
	m.clearedFields[department.FieldLeader] = struct{}{}
}

// LeaderCleared returns if the "leader" field was cleared in this mutation.
func (m *DepartmentMutation) LeaderCleared() bool {
	_, ok := m.clearedFields[department.FieldLeader]
	return ok
}

// ResetLeader resets all changes to the "leader" field.
func (m *DepartmentMutation) ResetLeader() {
	m.leader = nil
	delete(m.clearedFields, department.FieldLeader)
}

// SetPhone sets the "phone" field.
func (m *DepartmentMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *DepartmentMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ClearPhone clears the value of the "phone" field.
func (m *DepartmentMutation) ClearPhone() {
	m.phone = nil
	m.clearedFields[department.FieldPhone] = struct{}{}
}

// PhoneCleared returns if the "phone" field was cleared in this mutation.
func (m *DepartmentMutation) PhoneCleared() bool {
	_, ok := m.clearedFields[department.FieldPhone]
	return ok
}

// ResetPhone resets all changes to the "phone" field.
func (m *DepartmentMutation) ResetPhone() {
	m.phone = nil
	delete(m.clearedFields, department.FieldPhone)
}

// SetEmail sets the "email" field.
func (m *DepartmentMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *DepartmentMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *DepartmentMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[department.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *DepartmentMutation) EmailCleared() bool {
	_, ok := m.clearedFields[department.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *DepartmentMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, department.FieldEmail)
}

// SetRemark sets the "remark" field.
func (m *DepartmentMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *DepartmentMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *DepartmentMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[department.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *DepartmentMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[department.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *DepartmentMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, department.FieldRemark)
}

// SetParentID sets the "parent_id" field.
func (m *DepartmentMutation) SetParentID(u uint64) {
	m.parent = &u
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *DepartmentMutation) ParentID() (r uint64, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldParentID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *DepartmentMutation) ClearParentID() {
	m.parent = nil
	m.clearedFields[department.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *DepartmentMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[department.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *DepartmentMutation) ResetParentID() {
	m.parent = nil
	delete(m.clearedFields, department.FieldParentID)
}

// ClearParent clears the "parent" edge to the Department entity.
func (m *DepartmentMutation) ClearParent() {
	m.clearedparent = true
	m.clearedFields[department.FieldParentID] = struct{}{}
}

// ParentCleared reports if the "parent" edge to the Department entity was cleared.
func (m *DepartmentMutation) ParentCleared() bool {
	return m.ParentIDCleared() || m.clearedparent
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *DepartmentMutation) ParentIDs() (ids []uint64) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *DepartmentMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the Department entity by ids.
func (m *DepartmentMutation) AddChildIDs(ids ...uint64) {
	if m.children == nil {
		m.children = make(map[uint64]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the Department entity.
func (m *DepartmentMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the Department entity was cleared.
func (m *DepartmentMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the Department entity by IDs.
func (m *DepartmentMutation) RemoveChildIDs(ids ...uint64) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the Department entity.
func (m *DepartmentMutation) RemovedChildrenIDs() (ids []uint64) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *DepartmentMutation) ChildrenIDs() (ids []uint64) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *DepartmentMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *DepartmentMutation) AddUserIDs(ids ...uuid.UUID) {
	if m.users == nil {
		m.users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *DepartmentMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *DepartmentMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *DepartmentMutation) RemoveUserIDs(ids ...uuid.UUID) {
	if m.removedusers == nil {
		m.removedusers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *DepartmentMutation) RemovedUsersIDs() (ids []uuid.UUID) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *DepartmentMutation) UsersIDs() (ids []uuid.UUID) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *DepartmentMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// AddPostIDs adds the "posts" edge to the Position entity by ids.
func (m *DepartmentMutation) AddPostIDs(ids ...uint64) {
	if m.posts == nil {
		m.posts = make(map[uint64]struct{})
	}
	for i := range ids {
		m.posts[ids[i]] = struct{}{}
	}
}

// ClearPosts clears the "posts" edge to the Position entity.
func (m *DepartmentMutation) ClearPosts() {
	m.clearedposts = true
}

// PostsCleared reports if the "posts" edge to the Position entity was cleared.
func (m *DepartmentMutation) PostsCleared() bool {
	return m.clearedposts
}

// RemovePostIDs removes the "posts" edge to the Position entity by IDs.
func (m *DepartmentMutation) RemovePostIDs(ids ...uint64) {
	if m.removedposts == nil {
		m.removedposts = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.posts, ids[i])
		m.removedposts[ids[i]] = struct{}{}
	}
}

// RemovedPosts returns the removed IDs of the "posts" edge to the Position entity.
func (m *DepartmentMutation) RemovedPostsIDs() (ids []uint64) {
	for id := range m.removedposts {
		ids = append(ids, id)
	}
	return
}

// PostsIDs returns the "posts" edge IDs in the mutation.
func (m *DepartmentMutation) PostsIDs() (ids []uint64) {
	for id := range m.posts {
		ids = append(ids, id)
	}
	return
}

// ResetPosts resets all changes to the "posts" edge.
func (m *DepartmentMutation) ResetPosts() {
	m.posts = nil
	m.clearedposts = false
	m.removedposts = nil
}

// Where appends a list predicates to the DepartmentMutation builder.
func (m *DepartmentMutation) Where(ps ...predicate.Department) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DepartmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DepartmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Department, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DepartmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DepartmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Department).
func (m *DepartmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DepartmentMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, department.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, department.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, department.FieldStatus)
	}
	if m.sort != nil {
		fields = append(fields, department.FieldSort)
	}
	if m.tenant_id != nil {
		fields = append(fields, department.FieldTenantID)
	}
	if m.name != nil {
		fields = append(fields, department.FieldName)
	}
	if m.ancestors != nil {
		fields = append(fields, department.FieldAncestors)
	}
	if m.leader != nil {
		fields = append(fields, department.FieldLeader)
	}
	if m.phone != nil {
		fields = append(fields, department.FieldPhone)
	}
	if m.email != nil {
		fields = append(fields, department.FieldEmail)
	}
	if m.remark != nil {
		fields = append(fields, department.FieldRemark)
	}
	if m.parent != nil {
		fields = append(fields, department.FieldParentID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DepartmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case department.FieldCreatedAt:
		return m.CreatedAt()
	case department.FieldUpdatedAt:
		return m.UpdatedAt()
	case department.FieldStatus:
		return m.Status()
	case department.FieldSort:
		return m.Sort()
	case department.FieldTenantID:
		return m.TenantID()
	case department.FieldName:
		return m.Name()
	case department.FieldAncestors:
		return m.Ancestors()
	case department.FieldLeader:
		return m.Leader()
	case department.FieldPhone:
		return m.Phone()
	case department.FieldEmail:
		return m.Email()
	case department.FieldRemark:
		return m.Remark()
	case department.FieldParentID:
		return m.ParentID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DepartmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case department.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case department.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case department.FieldStatus:
		return m.OldStatus(ctx)
	case department.FieldSort:
		return m.OldSort(ctx)
	case department.FieldTenantID:
		return m.OldTenantID(ctx)
	case department.FieldName:
		return m.OldName(ctx)
	case department.FieldAncestors:
		return m.OldAncestors(ctx)
	case department.FieldLeader:
		return m.OldLeader(ctx)
	case department.FieldPhone:
		return m.OldPhone(ctx)
	case department.FieldEmail:
		return m.OldEmail(ctx)
	case department.FieldRemark:
		return m.OldRemark(ctx)
	case department.FieldParentID:
		return m.OldParentID(ctx)
	}
	return nil, fmt.Errorf("unknown Department field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DepartmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case department.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case department.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case department.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case department.FieldSort:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	case department.FieldTenantID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case department.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case department.FieldAncestors:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAncestors(v)
		return nil
	case department.FieldLeader:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLeader(v)
		return nil
	case department.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case department.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case department.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case department.FieldParentID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	}
	return fmt.Errorf("unknown Department field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DepartmentMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, department.FieldStatus)
	}
	if m.addsort != nil {
		fields = append(fields, department.FieldSort)
	}
	if m.addtenant_id != nil {
		fields = append(fields, department.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DepartmentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case department.FieldStatus:
		return m.AddedStatus()
	case department.FieldSort:
		return m.AddedSort()
	case department.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DepartmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case department.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case department.FieldSort:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSort(v)
		return nil
	case department.FieldTenantID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown Department numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DepartmentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(department.FieldStatus) {
		fields = append(fields, department.FieldStatus)
	}
	if m.FieldCleared(department.FieldAncestors) {
		fields = append(fields, department.FieldAncestors)
	}
	if m.FieldCleared(department.FieldLeader) {
		fields = append(fields, department.FieldLeader)
	}
	if m.FieldCleared(department.FieldPhone) {
		fields = append(fields, department.FieldPhone)
	}
	if m.FieldCleared(department.FieldEmail) {
		fields = append(fields, department.FieldEmail)
	}
	if m.FieldCleared(department.FieldRemark) {
		fields = append(fields, department.FieldRemark)
	}
	if m.FieldCleared(department.FieldParentID) {
		fields = append(fields, department.FieldParentID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DepartmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DepartmentMutation) ClearField(name string) error {
	switch name {
	case department.FieldStatus:
		m.ClearStatus()
		return nil
	case department.FieldAncestors:
		m.ClearAncestors()
		return nil
	case department.FieldLeader:
		m.ClearLeader()
		return nil
	case department.FieldPhone:
		m.ClearPhone()
		return nil
	case department.FieldEmail:
		m.ClearEmail()
		return nil
	case department.FieldRemark:
		m.ClearRemark()
		return nil
	case department.FieldParentID:
		m.ClearParentID()
		return nil
	}
	return fmt.Errorf("unknown Department nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DepartmentMutation) ResetField(name string) error {
	switch name {
	case department.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case department.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case department.FieldStatus:
		m.ResetStatus()
		return nil
	case department.FieldSort:
		m.ResetSort()
		return nil
	case department.FieldTenantID:
		m.ResetTenantID()
		return nil
	case department.FieldName:
		m.ResetName()
		return nil
	case department.FieldAncestors:
		m.ResetAncestors()
		return nil
	case department.FieldLeader:
		m.ResetLeader()
		return nil
	case department.FieldPhone:
		m.ResetPhone()
		return nil
	case department.FieldEmail:
		m.ResetEmail()
		return nil
	case department.FieldRemark:
		m.ResetRemark()
		return nil
	case department.FieldParentID:
		m.ResetParentID()
		return nil
	}
	return fmt.Errorf("unknown Department field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DepartmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.parent != nil {
		edges = append(edges, department.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, department.EdgeChildren)
	}
	if m.users != nil {
		edges = append(edges, department.EdgeUsers)
	}
	if m.posts != nil {
		edges = append(edges, department.EdgePosts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DepartmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case department.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case department.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case department.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case department.EdgePosts:
		ids := make([]ent.Value, 0, len(m.posts))
		for id := range m.posts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DepartmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedchildren != nil {
		edges = append(edges, department.EdgeChildren)
	}
	if m.removedusers != nil {
		edges = append(edges, department.EdgeUsers)
	}
	if m.removedposts != nil {
		edges = append(edges, department.EdgePosts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DepartmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case department.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case department.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	case department.EdgePosts:
		ids := make([]ent.Value, 0, len(m.removedposts))
		for id := range m.removedposts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DepartmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedparent {
		edges = append(edges, department.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, department.EdgeChildren)
	}
	if m.clearedusers {
		edges = append(edges, department.EdgeUsers)
	}
	if m.clearedposts {
		edges = append(edges, department.EdgePosts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DepartmentMutation) EdgeCleared(name string) bool {
	switch name {
	case department.EdgeParent:
		return m.clearedparent
	case department.EdgeChildren:
		return m.clearedchildren
	case department.EdgeUsers:
		return m.clearedusers
	case department.EdgePosts:
		return m.clearedposts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DepartmentMutation) ClearEdge(name string) error {
	switch name {
	case department.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown Department unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DepartmentMutation) ResetEdge(name string) error {
	switch name {
	case department.EdgeParent:
		m.ResetParent()
		return nil
	case department.EdgeChildren:
		m.ResetChildren()
		return nil
	case department.EdgeUsers:
		m.ResetUsers()
		return nil
	case department.EdgePosts:
		m.ResetPosts()
		return nil
	}
	return fmt.Errorf("unknown Department edge %s", name)
}

// DictionaryMutation represents an operation that mutates the Dictionary nodes in the graph.
type DictionaryMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uint64
	created_at                *time.Time
	updated_at                *time.Time
	status                    *uint8
	addstatus                 *int8
	tenant_id                 *uint64
	addtenant_id              *int64
	title                     *string
	name                      *string
	desc                      *string
	clearedFields             map[string]struct{}
	dictionary_details        map[uint64]struct{}
	removeddictionary_details map[uint64]struct{}
	cleareddictionary_details bool
	done                      bool
	oldValue                  func(context.Context) (*Dictionary, error)
	predicates                []predicate.Dictionary
}

var _ ent.Mutation = (*DictionaryMutation)(nil)

// dictionaryOption allows management of the mutation configuration using functional options.
type dictionaryOption func(*DictionaryMutation)

// newDictionaryMutation creates new mutation for the Dictionary entity.
func newDictionaryMutation(c config, op Op, opts ...dictionaryOption) *DictionaryMutation {
	m := &DictionaryMutation{
		config:        c,
		op:            op,
		typ:           TypeDictionary,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDictionaryID sets the ID field of the mutation.
func withDictionaryID(id uint64) dictionaryOption {
	return func(m *DictionaryMutation) {
		var (
			err   error
			once  sync.Once
			value *Dictionary
		)
		m.oldValue = func(ctx context.Context) (*Dictionary, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Dictionary.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDictionary sets the old Dictionary of the mutation.
func withDictionary(node *Dictionary) dictionaryOption {
	return func(m *DictionaryMutation) {
		m.oldValue = func(context.Context) (*Dictionary, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DictionaryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DictionaryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Dictionary entities.
func (m *DictionaryMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DictionaryMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DictionaryMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Dictionary.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DictionaryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DictionaryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Dictionary entity.
// If the Dictionary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DictionaryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DictionaryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DictionaryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Dictionary entity.
// If the Dictionary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DictionaryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *DictionaryMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *DictionaryMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Dictionary entity.
// If the Dictionary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *DictionaryMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *DictionaryMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *DictionaryMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[dictionary.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *DictionaryMutation) StatusCleared() bool {
	_, ok := m.clearedFields[dictionary.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *DictionaryMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, dictionary.FieldStatus)
}

// SetTenantID sets the "tenant_id" field.
func (m *DictionaryMutation) SetTenantID(u uint64) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *DictionaryMutation) TenantID() (r uint64, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Dictionary entity.
// If the Dictionary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryMutation) OldTenantID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *DictionaryMutation) AddTenantID(u int64) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *DictionaryMutation) AddedTenantID() (r int64, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *DictionaryMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetTitle sets the "title" field.
func (m *DictionaryMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *DictionaryMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Dictionary entity.
// If the Dictionary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *DictionaryMutation) ResetTitle() {
	m.title = nil
}

// SetName sets the "name" field.
func (m *DictionaryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DictionaryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Dictionary entity.
// If the Dictionary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DictionaryMutation) ResetName() {
	m.name = nil
}

// SetDesc sets the "desc" field.
func (m *DictionaryMutation) SetDesc(s string) {
	m.desc = &s
}

// Desc returns the value of the "desc" field in the mutation.
func (m *DictionaryMutation) Desc() (r string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the Dictionary entity.
// If the Dictionary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryMutation) OldDesc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// ClearDesc clears the value of the "desc" field.
func (m *DictionaryMutation) ClearDesc() {
	m.desc = nil
	m.clearedFields[dictionary.FieldDesc] = struct{}{}
}

// DescCleared returns if the "desc" field was cleared in this mutation.
func (m *DictionaryMutation) DescCleared() bool {
	_, ok := m.clearedFields[dictionary.FieldDesc]
	return ok
}

// ResetDesc resets all changes to the "desc" field.
func (m *DictionaryMutation) ResetDesc() {
	m.desc = nil
	delete(m.clearedFields, dictionary.FieldDesc)
}

// AddDictionaryDetailIDs adds the "dictionary_details" edge to the DictionaryDetail entity by ids.
func (m *DictionaryMutation) AddDictionaryDetailIDs(ids ...uint64) {
	if m.dictionary_details == nil {
		m.dictionary_details = make(map[uint64]struct{})
	}
	for i := range ids {
		m.dictionary_details[ids[i]] = struct{}{}
	}
}

// ClearDictionaryDetails clears the "dictionary_details" edge to the DictionaryDetail entity.
func (m *DictionaryMutation) ClearDictionaryDetails() {
	m.cleareddictionary_details = true
}

// DictionaryDetailsCleared reports if the "dictionary_details" edge to the DictionaryDetail entity was cleared.
func (m *DictionaryMutation) DictionaryDetailsCleared() bool {
	return m.cleareddictionary_details
}

// RemoveDictionaryDetailIDs removes the "dictionary_details" edge to the DictionaryDetail entity by IDs.
func (m *DictionaryMutation) RemoveDictionaryDetailIDs(ids ...uint64) {
	if m.removeddictionary_details == nil {
		m.removeddictionary_details = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.dictionary_details, ids[i])
		m.removeddictionary_details[ids[i]] = struct{}{}
	}
}

// RemovedDictionaryDetails returns the removed IDs of the "dictionary_details" edge to the DictionaryDetail entity.
func (m *DictionaryMutation) RemovedDictionaryDetailsIDs() (ids []uint64) {
	for id := range m.removeddictionary_details {
		ids = append(ids, id)
	}
	return
}

// DictionaryDetailsIDs returns the "dictionary_details" edge IDs in the mutation.
func (m *DictionaryMutation) DictionaryDetailsIDs() (ids []uint64) {
	for id := range m.dictionary_details {
		ids = append(ids, id)
	}
	return
}

// ResetDictionaryDetails resets all changes to the "dictionary_details" edge.
func (m *DictionaryMutation) ResetDictionaryDetails() {
	m.dictionary_details = nil
	m.cleareddictionary_details = false
	m.removeddictionary_details = nil
}

// Where appends a list predicates to the DictionaryMutation builder.
func (m *DictionaryMutation) Where(ps ...predicate.Dictionary) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DictionaryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DictionaryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Dictionary, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DictionaryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DictionaryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Dictionary).
func (m *DictionaryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DictionaryMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, dictionary.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, dictionary.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, dictionary.FieldStatus)
	}
	if m.tenant_id != nil {
		fields = append(fields, dictionary.FieldTenantID)
	}
	if m.title != nil {
		fields = append(fields, dictionary.FieldTitle)
	}
	if m.name != nil {
		fields = append(fields, dictionary.FieldName)
	}
	if m.desc != nil {
		fields = append(fields, dictionary.FieldDesc)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DictionaryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dictionary.FieldCreatedAt:
		return m.CreatedAt()
	case dictionary.FieldUpdatedAt:
		return m.UpdatedAt()
	case dictionary.FieldStatus:
		return m.Status()
	case dictionary.FieldTenantID:
		return m.TenantID()
	case dictionary.FieldTitle:
		return m.Title()
	case dictionary.FieldName:
		return m.Name()
	case dictionary.FieldDesc:
		return m.Desc()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DictionaryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dictionary.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case dictionary.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case dictionary.FieldStatus:
		return m.OldStatus(ctx)
	case dictionary.FieldTenantID:
		return m.OldTenantID(ctx)
	case dictionary.FieldTitle:
		return m.OldTitle(ctx)
	case dictionary.FieldName:
		return m.OldName(ctx)
	case dictionary.FieldDesc:
		return m.OldDesc(ctx)
	}
	return nil, fmt.Errorf("unknown Dictionary field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DictionaryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dictionary.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case dictionary.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case dictionary.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case dictionary.FieldTenantID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case dictionary.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case dictionary.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case dictionary.FieldDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	}
	return fmt.Errorf("unknown Dictionary field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DictionaryMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, dictionary.FieldStatus)
	}
	if m.addtenant_id != nil {
		fields = append(fields, dictionary.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DictionaryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case dictionary.FieldStatus:
		return m.AddedStatus()
	case dictionary.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DictionaryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case dictionary.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case dictionary.FieldTenantID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown Dictionary numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DictionaryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(dictionary.FieldStatus) {
		fields = append(fields, dictionary.FieldStatus)
	}
	if m.FieldCleared(dictionary.FieldDesc) {
		fields = append(fields, dictionary.FieldDesc)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DictionaryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DictionaryMutation) ClearField(name string) error {
	switch name {
	case dictionary.FieldStatus:
		m.ClearStatus()
		return nil
	case dictionary.FieldDesc:
		m.ClearDesc()
		return nil
	}
	return fmt.Errorf("unknown Dictionary nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DictionaryMutation) ResetField(name string) error {
	switch name {
	case dictionary.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case dictionary.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case dictionary.FieldStatus:
		m.ResetStatus()
		return nil
	case dictionary.FieldTenantID:
		m.ResetTenantID()
		return nil
	case dictionary.FieldTitle:
		m.ResetTitle()
		return nil
	case dictionary.FieldName:
		m.ResetName()
		return nil
	case dictionary.FieldDesc:
		m.ResetDesc()
		return nil
	}
	return fmt.Errorf("unknown Dictionary field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DictionaryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.dictionary_details != nil {
		edges = append(edges, dictionary.EdgeDictionaryDetails)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DictionaryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dictionary.EdgeDictionaryDetails:
		ids := make([]ent.Value, 0, len(m.dictionary_details))
		for id := range m.dictionary_details {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DictionaryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removeddictionary_details != nil {
		edges = append(edges, dictionary.EdgeDictionaryDetails)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DictionaryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case dictionary.EdgeDictionaryDetails:
		ids := make([]ent.Value, 0, len(m.removeddictionary_details))
		for id := range m.removeddictionary_details {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DictionaryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareddictionary_details {
		edges = append(edges, dictionary.EdgeDictionaryDetails)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DictionaryMutation) EdgeCleared(name string) bool {
	switch name {
	case dictionary.EdgeDictionaryDetails:
		return m.cleareddictionary_details
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DictionaryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Dictionary unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DictionaryMutation) ResetEdge(name string) error {
	switch name {
	case dictionary.EdgeDictionaryDetails:
		m.ResetDictionaryDetails()
		return nil
	}
	return fmt.Errorf("unknown Dictionary edge %s", name)
}

// DictionaryDetailMutation represents an operation that mutates the DictionaryDetail nodes in the graph.
type DictionaryDetailMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uint64
	created_at          *time.Time
	updated_at          *time.Time
	status              *uint8
	addstatus           *int8
	sort                *uint32
	addsort             *int32
	tenant_id           *uint64
	addtenant_id        *int64
	title               *string
	value               *string
	list_class          *string
	css_class           *string
	is_default          *uint32
	addis_default       *int32
	clearedFields       map[string]struct{}
	dictionaries        *uint64
	cleareddictionaries bool
	done                bool
	oldValue            func(context.Context) (*DictionaryDetail, error)
	predicates          []predicate.DictionaryDetail
}

var _ ent.Mutation = (*DictionaryDetailMutation)(nil)

// dictionarydetailOption allows management of the mutation configuration using functional options.
type dictionarydetailOption func(*DictionaryDetailMutation)

// newDictionaryDetailMutation creates new mutation for the DictionaryDetail entity.
func newDictionaryDetailMutation(c config, op Op, opts ...dictionarydetailOption) *DictionaryDetailMutation {
	m := &DictionaryDetailMutation{
		config:        c,
		op:            op,
		typ:           TypeDictionaryDetail,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDictionaryDetailID sets the ID field of the mutation.
func withDictionaryDetailID(id uint64) dictionarydetailOption {
	return func(m *DictionaryDetailMutation) {
		var (
			err   error
			once  sync.Once
			value *DictionaryDetail
		)
		m.oldValue = func(ctx context.Context) (*DictionaryDetail, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DictionaryDetail.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDictionaryDetail sets the old DictionaryDetail of the mutation.
func withDictionaryDetail(node *DictionaryDetail) dictionarydetailOption {
	return func(m *DictionaryDetailMutation) {
		m.oldValue = func(context.Context) (*DictionaryDetail, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DictionaryDetailMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DictionaryDetailMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DictionaryDetail entities.
func (m *DictionaryDetailMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DictionaryDetailMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DictionaryDetailMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DictionaryDetail.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DictionaryDetailMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DictionaryDetailMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DictionaryDetail entity.
// If the DictionaryDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryDetailMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DictionaryDetailMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DictionaryDetailMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DictionaryDetailMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DictionaryDetail entity.
// If the DictionaryDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryDetailMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DictionaryDetailMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *DictionaryDetailMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *DictionaryDetailMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the DictionaryDetail entity.
// If the DictionaryDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryDetailMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *DictionaryDetailMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *DictionaryDetailMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *DictionaryDetailMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[dictionarydetail.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *DictionaryDetailMutation) StatusCleared() bool {
	_, ok := m.clearedFields[dictionarydetail.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *DictionaryDetailMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, dictionarydetail.FieldStatus)
}

// SetSort sets the "sort" field.
func (m *DictionaryDetailMutation) SetSort(u uint32) {
	m.sort = &u
	m.addsort = nil
}

// Sort returns the value of the "sort" field in the mutation.
func (m *DictionaryDetailMutation) Sort() (r uint32, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the DictionaryDetail entity.
// If the DictionaryDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryDetailMutation) OldSort(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// AddSort adds u to the "sort" field.
func (m *DictionaryDetailMutation) AddSort(u int32) {
	if m.addsort != nil {
		*m.addsort += u
	} else {
		m.addsort = &u
	}
}

// AddedSort returns the value that was added to the "sort" field in this mutation.
func (m *DictionaryDetailMutation) AddedSort() (r int32, exists bool) {
	v := m.addsort
	if v == nil {
		return
	}
	return *v, true
}

// ResetSort resets all changes to the "sort" field.
func (m *DictionaryDetailMutation) ResetSort() {
	m.sort = nil
	m.addsort = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *DictionaryDetailMutation) SetTenantID(u uint64) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *DictionaryDetailMutation) TenantID() (r uint64, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the DictionaryDetail entity.
// If the DictionaryDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryDetailMutation) OldTenantID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *DictionaryDetailMutation) AddTenantID(u int64) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *DictionaryDetailMutation) AddedTenantID() (r int64, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *DictionaryDetailMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetTitle sets the "title" field.
func (m *DictionaryDetailMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *DictionaryDetailMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the DictionaryDetail entity.
// If the DictionaryDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryDetailMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *DictionaryDetailMutation) ResetTitle() {
	m.title = nil
}

// SetValue sets the "value" field.
func (m *DictionaryDetailMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *DictionaryDetailMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the DictionaryDetail entity.
// If the DictionaryDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryDetailMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *DictionaryDetailMutation) ResetValue() {
	m.value = nil
}

// SetListClass sets the "list_class" field.
func (m *DictionaryDetailMutation) SetListClass(s string) {
	m.list_class = &s
}

// ListClass returns the value of the "list_class" field in the mutation.
func (m *DictionaryDetailMutation) ListClass() (r string, exists bool) {
	v := m.list_class
	if v == nil {
		return
	}
	return *v, true
}

// OldListClass returns the old "list_class" field's value of the DictionaryDetail entity.
// If the DictionaryDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryDetailMutation) OldListClass(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldListClass is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldListClass requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldListClass: %w", err)
	}
	return oldValue.ListClass, nil
}

// ClearListClass clears the value of the "list_class" field.
func (m *DictionaryDetailMutation) ClearListClass() {
	m.list_class = nil
	m.clearedFields[dictionarydetail.FieldListClass] = struct{}{}
}

// ListClassCleared returns if the "list_class" field was cleared in this mutation.
func (m *DictionaryDetailMutation) ListClassCleared() bool {
	_, ok := m.clearedFields[dictionarydetail.FieldListClass]
	return ok
}

// ResetListClass resets all changes to the "list_class" field.
func (m *DictionaryDetailMutation) ResetListClass() {
	m.list_class = nil
	delete(m.clearedFields, dictionarydetail.FieldListClass)
}

// SetCSSClass sets the "css_class" field.
func (m *DictionaryDetailMutation) SetCSSClass(s string) {
	m.css_class = &s
}

// CSSClass returns the value of the "css_class" field in the mutation.
func (m *DictionaryDetailMutation) CSSClass() (r string, exists bool) {
	v := m.css_class
	if v == nil {
		return
	}
	return *v, true
}

// OldCSSClass returns the old "css_class" field's value of the DictionaryDetail entity.
// If the DictionaryDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryDetailMutation) OldCSSClass(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCSSClass is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCSSClass requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCSSClass: %w", err)
	}
	return oldValue.CSSClass, nil
}

// ClearCSSClass clears the value of the "css_class" field.
func (m *DictionaryDetailMutation) ClearCSSClass() {
	m.css_class = nil
	m.clearedFields[dictionarydetail.FieldCSSClass] = struct{}{}
}

// CSSClassCleared returns if the "css_class" field was cleared in this mutation.
func (m *DictionaryDetailMutation) CSSClassCleared() bool {
	_, ok := m.clearedFields[dictionarydetail.FieldCSSClass]
	return ok
}

// ResetCSSClass resets all changes to the "css_class" field.
func (m *DictionaryDetailMutation) ResetCSSClass() {
	m.css_class = nil
	delete(m.clearedFields, dictionarydetail.FieldCSSClass)
}

// SetIsDefault sets the "is_default" field.
func (m *DictionaryDetailMutation) SetIsDefault(u uint32) {
	m.is_default = &u
	m.addis_default = nil
}

// IsDefault returns the value of the "is_default" field in the mutation.
func (m *DictionaryDetailMutation) IsDefault() (r uint32, exists bool) {
	v := m.is_default
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDefault returns the old "is_default" field's value of the DictionaryDetail entity.
// If the DictionaryDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryDetailMutation) OldIsDefault(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDefault is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDefault requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDefault: %w", err)
	}
	return oldValue.IsDefault, nil
}

// AddIsDefault adds u to the "is_default" field.
func (m *DictionaryDetailMutation) AddIsDefault(u int32) {
	if m.addis_default != nil {
		*m.addis_default += u
	} else {
		m.addis_default = &u
	}
}

// AddedIsDefault returns the value that was added to the "is_default" field in this mutation.
func (m *DictionaryDetailMutation) AddedIsDefault() (r int32, exists bool) {
	v := m.addis_default
	if v == nil {
		return
	}
	return *v, true
}

// ClearIsDefault clears the value of the "is_default" field.
func (m *DictionaryDetailMutation) ClearIsDefault() {
	m.is_default = nil
	m.addis_default = nil
	m.clearedFields[dictionarydetail.FieldIsDefault] = struct{}{}
}

// IsDefaultCleared returns if the "is_default" field was cleared in this mutation.
func (m *DictionaryDetailMutation) IsDefaultCleared() bool {
	_, ok := m.clearedFields[dictionarydetail.FieldIsDefault]
	return ok
}

// ResetIsDefault resets all changes to the "is_default" field.
func (m *DictionaryDetailMutation) ResetIsDefault() {
	m.is_default = nil
	m.addis_default = nil
	delete(m.clearedFields, dictionarydetail.FieldIsDefault)
}

// SetDictionaryID sets the "dictionary_id" field.
func (m *DictionaryDetailMutation) SetDictionaryID(u uint64) {
	m.dictionaries = &u
}

// DictionaryID returns the value of the "dictionary_id" field in the mutation.
func (m *DictionaryDetailMutation) DictionaryID() (r uint64, exists bool) {
	v := m.dictionaries
	if v == nil {
		return
	}
	return *v, true
}

// OldDictionaryID returns the old "dictionary_id" field's value of the DictionaryDetail entity.
// If the DictionaryDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryDetailMutation) OldDictionaryID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDictionaryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDictionaryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDictionaryID: %w", err)
	}
	return oldValue.DictionaryID, nil
}

// ClearDictionaryID clears the value of the "dictionary_id" field.
func (m *DictionaryDetailMutation) ClearDictionaryID() {
	m.dictionaries = nil
	m.clearedFields[dictionarydetail.FieldDictionaryID] = struct{}{}
}

// DictionaryIDCleared returns if the "dictionary_id" field was cleared in this mutation.
func (m *DictionaryDetailMutation) DictionaryIDCleared() bool {
	_, ok := m.clearedFields[dictionarydetail.FieldDictionaryID]
	return ok
}

// ResetDictionaryID resets all changes to the "dictionary_id" field.
func (m *DictionaryDetailMutation) ResetDictionaryID() {
	m.dictionaries = nil
	delete(m.clearedFields, dictionarydetail.FieldDictionaryID)
}

// SetDictionariesID sets the "dictionaries" edge to the Dictionary entity by id.
func (m *DictionaryDetailMutation) SetDictionariesID(id uint64) {
	m.dictionaries = &id
}

// ClearDictionaries clears the "dictionaries" edge to the Dictionary entity.
func (m *DictionaryDetailMutation) ClearDictionaries() {
	m.cleareddictionaries = true
	m.clearedFields[dictionarydetail.FieldDictionaryID] = struct{}{}
}

// DictionariesCleared reports if the "dictionaries" edge to the Dictionary entity was cleared.
func (m *DictionaryDetailMutation) DictionariesCleared() bool {
	return m.DictionaryIDCleared() || m.cleareddictionaries
}

// DictionariesID returns the "dictionaries" edge ID in the mutation.
func (m *DictionaryDetailMutation) DictionariesID() (id uint64, exists bool) {
	if m.dictionaries != nil {
		return *m.dictionaries, true
	}
	return
}

// DictionariesIDs returns the "dictionaries" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DictionariesID instead. It exists only for internal usage by the builders.
func (m *DictionaryDetailMutation) DictionariesIDs() (ids []uint64) {
	if id := m.dictionaries; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDictionaries resets all changes to the "dictionaries" edge.
func (m *DictionaryDetailMutation) ResetDictionaries() {
	m.dictionaries = nil
	m.cleareddictionaries = false
}

// Where appends a list predicates to the DictionaryDetailMutation builder.
func (m *DictionaryDetailMutation) Where(ps ...predicate.DictionaryDetail) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DictionaryDetailMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DictionaryDetailMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DictionaryDetail, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DictionaryDetailMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DictionaryDetailMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DictionaryDetail).
func (m *DictionaryDetailMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DictionaryDetailMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, dictionarydetail.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, dictionarydetail.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, dictionarydetail.FieldStatus)
	}
	if m.sort != nil {
		fields = append(fields, dictionarydetail.FieldSort)
	}
	if m.tenant_id != nil {
		fields = append(fields, dictionarydetail.FieldTenantID)
	}
	if m.title != nil {
		fields = append(fields, dictionarydetail.FieldTitle)
	}
	if m.value != nil {
		fields = append(fields, dictionarydetail.FieldValue)
	}
	if m.list_class != nil {
		fields = append(fields, dictionarydetail.FieldListClass)
	}
	if m.css_class != nil {
		fields = append(fields, dictionarydetail.FieldCSSClass)
	}
	if m.is_default != nil {
		fields = append(fields, dictionarydetail.FieldIsDefault)
	}
	if m.dictionaries != nil {
		fields = append(fields, dictionarydetail.FieldDictionaryID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DictionaryDetailMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dictionarydetail.FieldCreatedAt:
		return m.CreatedAt()
	case dictionarydetail.FieldUpdatedAt:
		return m.UpdatedAt()
	case dictionarydetail.FieldStatus:
		return m.Status()
	case dictionarydetail.FieldSort:
		return m.Sort()
	case dictionarydetail.FieldTenantID:
		return m.TenantID()
	case dictionarydetail.FieldTitle:
		return m.Title()
	case dictionarydetail.FieldValue:
		return m.Value()
	case dictionarydetail.FieldListClass:
		return m.ListClass()
	case dictionarydetail.FieldCSSClass:
		return m.CSSClass()
	case dictionarydetail.FieldIsDefault:
		return m.IsDefault()
	case dictionarydetail.FieldDictionaryID:
		return m.DictionaryID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DictionaryDetailMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dictionarydetail.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case dictionarydetail.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case dictionarydetail.FieldStatus:
		return m.OldStatus(ctx)
	case dictionarydetail.FieldSort:
		return m.OldSort(ctx)
	case dictionarydetail.FieldTenantID:
		return m.OldTenantID(ctx)
	case dictionarydetail.FieldTitle:
		return m.OldTitle(ctx)
	case dictionarydetail.FieldValue:
		return m.OldValue(ctx)
	case dictionarydetail.FieldListClass:
		return m.OldListClass(ctx)
	case dictionarydetail.FieldCSSClass:
		return m.OldCSSClass(ctx)
	case dictionarydetail.FieldIsDefault:
		return m.OldIsDefault(ctx)
	case dictionarydetail.FieldDictionaryID:
		return m.OldDictionaryID(ctx)
	}
	return nil, fmt.Errorf("unknown DictionaryDetail field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DictionaryDetailMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dictionarydetail.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case dictionarydetail.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case dictionarydetail.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case dictionarydetail.FieldSort:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	case dictionarydetail.FieldTenantID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case dictionarydetail.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case dictionarydetail.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case dictionarydetail.FieldListClass:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetListClass(v)
		return nil
	case dictionarydetail.FieldCSSClass:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCSSClass(v)
		return nil
	case dictionarydetail.FieldIsDefault:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDefault(v)
		return nil
	case dictionarydetail.FieldDictionaryID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDictionaryID(v)
		return nil
	}
	return fmt.Errorf("unknown DictionaryDetail field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DictionaryDetailMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, dictionarydetail.FieldStatus)
	}
	if m.addsort != nil {
		fields = append(fields, dictionarydetail.FieldSort)
	}
	if m.addtenant_id != nil {
		fields = append(fields, dictionarydetail.FieldTenantID)
	}
	if m.addis_default != nil {
		fields = append(fields, dictionarydetail.FieldIsDefault)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DictionaryDetailMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case dictionarydetail.FieldStatus:
		return m.AddedStatus()
	case dictionarydetail.FieldSort:
		return m.AddedSort()
	case dictionarydetail.FieldTenantID:
		return m.AddedTenantID()
	case dictionarydetail.FieldIsDefault:
		return m.AddedIsDefault()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DictionaryDetailMutation) AddField(name string, value ent.Value) error {
	switch name {
	case dictionarydetail.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case dictionarydetail.FieldSort:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSort(v)
		return nil
	case dictionarydetail.FieldTenantID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case dictionarydetail.FieldIsDefault:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDefault(v)
		return nil
	}
	return fmt.Errorf("unknown DictionaryDetail numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DictionaryDetailMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(dictionarydetail.FieldStatus) {
		fields = append(fields, dictionarydetail.FieldStatus)
	}
	if m.FieldCleared(dictionarydetail.FieldListClass) {
		fields = append(fields, dictionarydetail.FieldListClass)
	}
	if m.FieldCleared(dictionarydetail.FieldCSSClass) {
		fields = append(fields, dictionarydetail.FieldCSSClass)
	}
	if m.FieldCleared(dictionarydetail.FieldIsDefault) {
		fields = append(fields, dictionarydetail.FieldIsDefault)
	}
	if m.FieldCleared(dictionarydetail.FieldDictionaryID) {
		fields = append(fields, dictionarydetail.FieldDictionaryID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DictionaryDetailMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DictionaryDetailMutation) ClearField(name string) error {
	switch name {
	case dictionarydetail.FieldStatus:
		m.ClearStatus()
		return nil
	case dictionarydetail.FieldListClass:
		m.ClearListClass()
		return nil
	case dictionarydetail.FieldCSSClass:
		m.ClearCSSClass()
		return nil
	case dictionarydetail.FieldIsDefault:
		m.ClearIsDefault()
		return nil
	case dictionarydetail.FieldDictionaryID:
		m.ClearDictionaryID()
		return nil
	}
	return fmt.Errorf("unknown DictionaryDetail nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DictionaryDetailMutation) ResetField(name string) error {
	switch name {
	case dictionarydetail.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case dictionarydetail.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case dictionarydetail.FieldStatus:
		m.ResetStatus()
		return nil
	case dictionarydetail.FieldSort:
		m.ResetSort()
		return nil
	case dictionarydetail.FieldTenantID:
		m.ResetTenantID()
		return nil
	case dictionarydetail.FieldTitle:
		m.ResetTitle()
		return nil
	case dictionarydetail.FieldValue:
		m.ResetValue()
		return nil
	case dictionarydetail.FieldListClass:
		m.ResetListClass()
		return nil
	case dictionarydetail.FieldCSSClass:
		m.ResetCSSClass()
		return nil
	case dictionarydetail.FieldIsDefault:
		m.ResetIsDefault()
		return nil
	case dictionarydetail.FieldDictionaryID:
		m.ResetDictionaryID()
		return nil
	}
	return fmt.Errorf("unknown DictionaryDetail field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DictionaryDetailMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.dictionaries != nil {
		edges = append(edges, dictionarydetail.EdgeDictionaries)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DictionaryDetailMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dictionarydetail.EdgeDictionaries:
		if id := m.dictionaries; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DictionaryDetailMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DictionaryDetailMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DictionaryDetailMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareddictionaries {
		edges = append(edges, dictionarydetail.EdgeDictionaries)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DictionaryDetailMutation) EdgeCleared(name string) bool {
	switch name {
	case dictionarydetail.EdgeDictionaries:
		return m.cleareddictionaries
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DictionaryDetailMutation) ClearEdge(name string) error {
	switch name {
	case dictionarydetail.EdgeDictionaries:
		m.ClearDictionaries()
		return nil
	}
	return fmt.Errorf("unknown DictionaryDetail unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DictionaryDetailMutation) ResetEdge(name string) error {
	switch name {
	case dictionarydetail.EdgeDictionaries:
		m.ResetDictionaries()
		return nil
	}
	return fmt.Errorf("unknown DictionaryDetail edge %s", name)
}

// MenuMutation represents an operation that mutates the Menu nodes in the graph.
type MenuMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uint64
	created_at            *time.Time
	updated_at            *time.Time
	sort                  *uint32
	addsort               *int32
	tenant_id             *uint64
	addtenant_id          *int64
	menu_level            *uint32
	addmenu_level         *int32
	menu_type             *uint32
	addmenu_type          *int32
	_path                 *string
	name                  *string
	redirect              *string
	component             *string
	disabled              *bool
	service_name          *string
	permission            *string
	title                 *string
	icon                  *string
	hide_menu             *bool
	hide_breadcrumb       *bool
	ignore_keep_alive     *bool
	hide_tab              *bool
	frame_src             *string
	carry_param           *bool
	hide_children_in_menu *bool
	affix                 *bool
	dynamic_level         *uint32
	adddynamic_level      *int32
	real_path             *string
	params                *string
	clearedFields         map[string]struct{}
	roles                 map[uint64]struct{}
	removedroles          map[uint64]struct{}
	clearedroles          bool
	parent                *uint64
	clearedparent         bool
	children              map[uint64]struct{}
	removedchildren       map[uint64]struct{}
	clearedchildren       bool
	done                  bool
	oldValue              func(context.Context) (*Menu, error)
	predicates            []predicate.Menu
}

var _ ent.Mutation = (*MenuMutation)(nil)

// menuOption allows management of the mutation configuration using functional options.
type menuOption func(*MenuMutation)

// newMenuMutation creates new mutation for the Menu entity.
func newMenuMutation(c config, op Op, opts ...menuOption) *MenuMutation {
	m := &MenuMutation{
		config:        c,
		op:            op,
		typ:           TypeMenu,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMenuID sets the ID field of the mutation.
func withMenuID(id uint64) menuOption {
	return func(m *MenuMutation) {
		var (
			err   error
			once  sync.Once
			value *Menu
		)
		m.oldValue = func(ctx context.Context) (*Menu, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Menu.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMenu sets the old Menu of the mutation.
func withMenu(node *Menu) menuOption {
	return func(m *MenuMutation) {
		m.oldValue = func(context.Context) (*Menu, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MenuMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MenuMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Menu entities.
func (m *MenuMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MenuMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MenuMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Menu.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MenuMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MenuMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MenuMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MenuMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MenuMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MenuMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetSort sets the "sort" field.
func (m *MenuMutation) SetSort(u uint32) {
	m.sort = &u
	m.addsort = nil
}

// Sort returns the value of the "sort" field in the mutation.
func (m *MenuMutation) Sort() (r uint32, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldSort(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// AddSort adds u to the "sort" field.
func (m *MenuMutation) AddSort(u int32) {
	if m.addsort != nil {
		*m.addsort += u
	} else {
		m.addsort = &u
	}
}

// AddedSort returns the value that was added to the "sort" field in this mutation.
func (m *MenuMutation) AddedSort() (r int32, exists bool) {
	v := m.addsort
	if v == nil {
		return
	}
	return *v, true
}

// ResetSort resets all changes to the "sort" field.
func (m *MenuMutation) ResetSort() {
	m.sort = nil
	m.addsort = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *MenuMutation) SetTenantID(u uint64) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *MenuMutation) TenantID() (r uint64, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldTenantID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *MenuMutation) AddTenantID(u int64) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *MenuMutation) AddedTenantID() (r int64, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *MenuMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetParentID sets the "parent_id" field.
func (m *MenuMutation) SetParentID(u uint64) {
	m.parent = &u
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *MenuMutation) ParentID() (r uint64, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldParentID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *MenuMutation) ClearParentID() {
	m.parent = nil
	m.clearedFields[menu.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *MenuMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[menu.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *MenuMutation) ResetParentID() {
	m.parent = nil
	delete(m.clearedFields, menu.FieldParentID)
}

// SetMenuLevel sets the "menu_level" field.
func (m *MenuMutation) SetMenuLevel(u uint32) {
	m.menu_level = &u
	m.addmenu_level = nil
}

// MenuLevel returns the value of the "menu_level" field in the mutation.
func (m *MenuMutation) MenuLevel() (r uint32, exists bool) {
	v := m.menu_level
	if v == nil {
		return
	}
	return *v, true
}

// OldMenuLevel returns the old "menu_level" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldMenuLevel(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMenuLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMenuLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMenuLevel: %w", err)
	}
	return oldValue.MenuLevel, nil
}

// AddMenuLevel adds u to the "menu_level" field.
func (m *MenuMutation) AddMenuLevel(u int32) {
	if m.addmenu_level != nil {
		*m.addmenu_level += u
	} else {
		m.addmenu_level = &u
	}
}

// AddedMenuLevel returns the value that was added to the "menu_level" field in this mutation.
func (m *MenuMutation) AddedMenuLevel() (r int32, exists bool) {
	v := m.addmenu_level
	if v == nil {
		return
	}
	return *v, true
}

// ResetMenuLevel resets all changes to the "menu_level" field.
func (m *MenuMutation) ResetMenuLevel() {
	m.menu_level = nil
	m.addmenu_level = nil
}

// SetMenuType sets the "menu_type" field.
func (m *MenuMutation) SetMenuType(u uint32) {
	m.menu_type = &u
	m.addmenu_type = nil
}

// MenuType returns the value of the "menu_type" field in the mutation.
func (m *MenuMutation) MenuType() (r uint32, exists bool) {
	v := m.menu_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMenuType returns the old "menu_type" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldMenuType(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMenuType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMenuType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMenuType: %w", err)
	}
	return oldValue.MenuType, nil
}

// AddMenuType adds u to the "menu_type" field.
func (m *MenuMutation) AddMenuType(u int32) {
	if m.addmenu_type != nil {
		*m.addmenu_type += u
	} else {
		m.addmenu_type = &u
	}
}

// AddedMenuType returns the value that was added to the "menu_type" field in this mutation.
func (m *MenuMutation) AddedMenuType() (r int32, exists bool) {
	v := m.addmenu_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetMenuType resets all changes to the "menu_type" field.
func (m *MenuMutation) ResetMenuType() {
	m.menu_type = nil
	m.addmenu_type = nil
}

// SetPath sets the "path" field.
func (m *MenuMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *MenuMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ClearPath clears the value of the "path" field.
func (m *MenuMutation) ClearPath() {
	m._path = nil
	m.clearedFields[menu.FieldPath] = struct{}{}
}

// PathCleared returns if the "path" field was cleared in this mutation.
func (m *MenuMutation) PathCleared() bool {
	_, ok := m.clearedFields[menu.FieldPath]
	return ok
}

// ResetPath resets all changes to the "path" field.
func (m *MenuMutation) ResetPath() {
	m._path = nil
	delete(m.clearedFields, menu.FieldPath)
}

// SetName sets the "name" field.
func (m *MenuMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MenuMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *MenuMutation) ResetName() {
	m.name = nil
}

// SetRedirect sets the "redirect" field.
func (m *MenuMutation) SetRedirect(s string) {
	m.redirect = &s
}

// Redirect returns the value of the "redirect" field in the mutation.
func (m *MenuMutation) Redirect() (r string, exists bool) {
	v := m.redirect
	if v == nil {
		return
	}
	return *v, true
}

// OldRedirect returns the old "redirect" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldRedirect(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRedirect is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRedirect requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRedirect: %w", err)
	}
	return oldValue.Redirect, nil
}

// ClearRedirect clears the value of the "redirect" field.
func (m *MenuMutation) ClearRedirect() {
	m.redirect = nil
	m.clearedFields[menu.FieldRedirect] = struct{}{}
}

// RedirectCleared returns if the "redirect" field was cleared in this mutation.
func (m *MenuMutation) RedirectCleared() bool {
	_, ok := m.clearedFields[menu.FieldRedirect]
	return ok
}

// ResetRedirect resets all changes to the "redirect" field.
func (m *MenuMutation) ResetRedirect() {
	m.redirect = nil
	delete(m.clearedFields, menu.FieldRedirect)
}

// SetComponent sets the "component" field.
func (m *MenuMutation) SetComponent(s string) {
	m.component = &s
}

// Component returns the value of the "component" field in the mutation.
func (m *MenuMutation) Component() (r string, exists bool) {
	v := m.component
	if v == nil {
		return
	}
	return *v, true
}

// OldComponent returns the old "component" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldComponent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComponent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComponent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComponent: %w", err)
	}
	return oldValue.Component, nil
}

// ClearComponent clears the value of the "component" field.
func (m *MenuMutation) ClearComponent() {
	m.component = nil
	m.clearedFields[menu.FieldComponent] = struct{}{}
}

// ComponentCleared returns if the "component" field was cleared in this mutation.
func (m *MenuMutation) ComponentCleared() bool {
	_, ok := m.clearedFields[menu.FieldComponent]
	return ok
}

// ResetComponent resets all changes to the "component" field.
func (m *MenuMutation) ResetComponent() {
	m.component = nil
	delete(m.clearedFields, menu.FieldComponent)
}

// SetDisabled sets the "disabled" field.
func (m *MenuMutation) SetDisabled(b bool) {
	m.disabled = &b
}

// Disabled returns the value of the "disabled" field in the mutation.
func (m *MenuMutation) Disabled() (r bool, exists bool) {
	v := m.disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabled returns the old "disabled" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabled: %w", err)
	}
	return oldValue.Disabled, nil
}

// ClearDisabled clears the value of the "disabled" field.
func (m *MenuMutation) ClearDisabled() {
	m.disabled = nil
	m.clearedFields[menu.FieldDisabled] = struct{}{}
}

// DisabledCleared returns if the "disabled" field was cleared in this mutation.
func (m *MenuMutation) DisabledCleared() bool {
	_, ok := m.clearedFields[menu.FieldDisabled]
	return ok
}

// ResetDisabled resets all changes to the "disabled" field.
func (m *MenuMutation) ResetDisabled() {
	m.disabled = nil
	delete(m.clearedFields, menu.FieldDisabled)
}

// SetServiceName sets the "service_name" field.
func (m *MenuMutation) SetServiceName(s string) {
	m.service_name = &s
}

// ServiceName returns the value of the "service_name" field in the mutation.
func (m *MenuMutation) ServiceName() (r string, exists bool) {
	v := m.service_name
	if v == nil {
		return
	}
	return *v, true
}

// OldServiceName returns the old "service_name" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldServiceName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServiceName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServiceName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServiceName: %w", err)
	}
	return oldValue.ServiceName, nil
}

// ClearServiceName clears the value of the "service_name" field.
func (m *MenuMutation) ClearServiceName() {
	m.service_name = nil
	m.clearedFields[menu.FieldServiceName] = struct{}{}
}

// ServiceNameCleared returns if the "service_name" field was cleared in this mutation.
func (m *MenuMutation) ServiceNameCleared() bool {
	_, ok := m.clearedFields[menu.FieldServiceName]
	return ok
}

// ResetServiceName resets all changes to the "service_name" field.
func (m *MenuMutation) ResetServiceName() {
	m.service_name = nil
	delete(m.clearedFields, menu.FieldServiceName)
}

// SetPermission sets the "permission" field.
func (m *MenuMutation) SetPermission(s string) {
	m.permission = &s
}

// Permission returns the value of the "permission" field in the mutation.
func (m *MenuMutation) Permission() (r string, exists bool) {
	v := m.permission
	if v == nil {
		return
	}
	return *v, true
}

// OldPermission returns the old "permission" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldPermission(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPermission is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPermission requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPermission: %w", err)
	}
	return oldValue.Permission, nil
}

// ClearPermission clears the value of the "permission" field.
func (m *MenuMutation) ClearPermission() {
	m.permission = nil
	m.clearedFields[menu.FieldPermission] = struct{}{}
}

// PermissionCleared returns if the "permission" field was cleared in this mutation.
func (m *MenuMutation) PermissionCleared() bool {
	_, ok := m.clearedFields[menu.FieldPermission]
	return ok
}

// ResetPermission resets all changes to the "permission" field.
func (m *MenuMutation) ResetPermission() {
	m.permission = nil
	delete(m.clearedFields, menu.FieldPermission)
}

// SetTitle sets the "title" field.
func (m *MenuMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *MenuMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *MenuMutation) ResetTitle() {
	m.title = nil
}

// SetIcon sets the "icon" field.
func (m *MenuMutation) SetIcon(s string) {
	m.icon = &s
}

// Icon returns the value of the "icon" field in the mutation.
func (m *MenuMutation) Icon() (r string, exists bool) {
	v := m.icon
	if v == nil {
		return
	}
	return *v, true
}

// OldIcon returns the old "icon" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldIcon(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcon: %w", err)
	}
	return oldValue.Icon, nil
}

// ResetIcon resets all changes to the "icon" field.
func (m *MenuMutation) ResetIcon() {
	m.icon = nil
}

// SetHideMenu sets the "hide_menu" field.
func (m *MenuMutation) SetHideMenu(b bool) {
	m.hide_menu = &b
}

// HideMenu returns the value of the "hide_menu" field in the mutation.
func (m *MenuMutation) HideMenu() (r bool, exists bool) {
	v := m.hide_menu
	if v == nil {
		return
	}
	return *v, true
}

// OldHideMenu returns the old "hide_menu" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldHideMenu(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHideMenu is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHideMenu requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHideMenu: %w", err)
	}
	return oldValue.HideMenu, nil
}

// ClearHideMenu clears the value of the "hide_menu" field.
func (m *MenuMutation) ClearHideMenu() {
	m.hide_menu = nil
	m.clearedFields[menu.FieldHideMenu] = struct{}{}
}

// HideMenuCleared returns if the "hide_menu" field was cleared in this mutation.
func (m *MenuMutation) HideMenuCleared() bool {
	_, ok := m.clearedFields[menu.FieldHideMenu]
	return ok
}

// ResetHideMenu resets all changes to the "hide_menu" field.
func (m *MenuMutation) ResetHideMenu() {
	m.hide_menu = nil
	delete(m.clearedFields, menu.FieldHideMenu)
}

// SetHideBreadcrumb sets the "hide_breadcrumb" field.
func (m *MenuMutation) SetHideBreadcrumb(b bool) {
	m.hide_breadcrumb = &b
}

// HideBreadcrumb returns the value of the "hide_breadcrumb" field in the mutation.
func (m *MenuMutation) HideBreadcrumb() (r bool, exists bool) {
	v := m.hide_breadcrumb
	if v == nil {
		return
	}
	return *v, true
}

// OldHideBreadcrumb returns the old "hide_breadcrumb" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldHideBreadcrumb(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHideBreadcrumb is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHideBreadcrumb requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHideBreadcrumb: %w", err)
	}
	return oldValue.HideBreadcrumb, nil
}

// ClearHideBreadcrumb clears the value of the "hide_breadcrumb" field.
func (m *MenuMutation) ClearHideBreadcrumb() {
	m.hide_breadcrumb = nil
	m.clearedFields[menu.FieldHideBreadcrumb] = struct{}{}
}

// HideBreadcrumbCleared returns if the "hide_breadcrumb" field was cleared in this mutation.
func (m *MenuMutation) HideBreadcrumbCleared() bool {
	_, ok := m.clearedFields[menu.FieldHideBreadcrumb]
	return ok
}

// ResetHideBreadcrumb resets all changes to the "hide_breadcrumb" field.
func (m *MenuMutation) ResetHideBreadcrumb() {
	m.hide_breadcrumb = nil
	delete(m.clearedFields, menu.FieldHideBreadcrumb)
}

// SetIgnoreKeepAlive sets the "ignore_keep_alive" field.
func (m *MenuMutation) SetIgnoreKeepAlive(b bool) {
	m.ignore_keep_alive = &b
}

// IgnoreKeepAlive returns the value of the "ignore_keep_alive" field in the mutation.
func (m *MenuMutation) IgnoreKeepAlive() (r bool, exists bool) {
	v := m.ignore_keep_alive
	if v == nil {
		return
	}
	return *v, true
}

// OldIgnoreKeepAlive returns the old "ignore_keep_alive" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldIgnoreKeepAlive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIgnoreKeepAlive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIgnoreKeepAlive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIgnoreKeepAlive: %w", err)
	}
	return oldValue.IgnoreKeepAlive, nil
}

// ClearIgnoreKeepAlive clears the value of the "ignore_keep_alive" field.
func (m *MenuMutation) ClearIgnoreKeepAlive() {
	m.ignore_keep_alive = nil
	m.clearedFields[menu.FieldIgnoreKeepAlive] = struct{}{}
}

// IgnoreKeepAliveCleared returns if the "ignore_keep_alive" field was cleared in this mutation.
func (m *MenuMutation) IgnoreKeepAliveCleared() bool {
	_, ok := m.clearedFields[menu.FieldIgnoreKeepAlive]
	return ok
}

// ResetIgnoreKeepAlive resets all changes to the "ignore_keep_alive" field.
func (m *MenuMutation) ResetIgnoreKeepAlive() {
	m.ignore_keep_alive = nil
	delete(m.clearedFields, menu.FieldIgnoreKeepAlive)
}

// SetHideTab sets the "hide_tab" field.
func (m *MenuMutation) SetHideTab(b bool) {
	m.hide_tab = &b
}

// HideTab returns the value of the "hide_tab" field in the mutation.
func (m *MenuMutation) HideTab() (r bool, exists bool) {
	v := m.hide_tab
	if v == nil {
		return
	}
	return *v, true
}

// OldHideTab returns the old "hide_tab" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldHideTab(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHideTab is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHideTab requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHideTab: %w", err)
	}
	return oldValue.HideTab, nil
}

// ClearHideTab clears the value of the "hide_tab" field.
func (m *MenuMutation) ClearHideTab() {
	m.hide_tab = nil
	m.clearedFields[menu.FieldHideTab] = struct{}{}
}

// HideTabCleared returns if the "hide_tab" field was cleared in this mutation.
func (m *MenuMutation) HideTabCleared() bool {
	_, ok := m.clearedFields[menu.FieldHideTab]
	return ok
}

// ResetHideTab resets all changes to the "hide_tab" field.
func (m *MenuMutation) ResetHideTab() {
	m.hide_tab = nil
	delete(m.clearedFields, menu.FieldHideTab)
}

// SetFrameSrc sets the "frame_src" field.
func (m *MenuMutation) SetFrameSrc(s string) {
	m.frame_src = &s
}

// FrameSrc returns the value of the "frame_src" field in the mutation.
func (m *MenuMutation) FrameSrc() (r string, exists bool) {
	v := m.frame_src
	if v == nil {
		return
	}
	return *v, true
}

// OldFrameSrc returns the old "frame_src" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldFrameSrc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFrameSrc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFrameSrc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFrameSrc: %w", err)
	}
	return oldValue.FrameSrc, nil
}

// ClearFrameSrc clears the value of the "frame_src" field.
func (m *MenuMutation) ClearFrameSrc() {
	m.frame_src = nil
	m.clearedFields[menu.FieldFrameSrc] = struct{}{}
}

// FrameSrcCleared returns if the "frame_src" field was cleared in this mutation.
func (m *MenuMutation) FrameSrcCleared() bool {
	_, ok := m.clearedFields[menu.FieldFrameSrc]
	return ok
}

// ResetFrameSrc resets all changes to the "frame_src" field.
func (m *MenuMutation) ResetFrameSrc() {
	m.frame_src = nil
	delete(m.clearedFields, menu.FieldFrameSrc)
}

// SetCarryParam sets the "carry_param" field.
func (m *MenuMutation) SetCarryParam(b bool) {
	m.carry_param = &b
}

// CarryParam returns the value of the "carry_param" field in the mutation.
func (m *MenuMutation) CarryParam() (r bool, exists bool) {
	v := m.carry_param
	if v == nil {
		return
	}
	return *v, true
}

// OldCarryParam returns the old "carry_param" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldCarryParam(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCarryParam is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCarryParam requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarryParam: %w", err)
	}
	return oldValue.CarryParam, nil
}

// ClearCarryParam clears the value of the "carry_param" field.
func (m *MenuMutation) ClearCarryParam() {
	m.carry_param = nil
	m.clearedFields[menu.FieldCarryParam] = struct{}{}
}

// CarryParamCleared returns if the "carry_param" field was cleared in this mutation.
func (m *MenuMutation) CarryParamCleared() bool {
	_, ok := m.clearedFields[menu.FieldCarryParam]
	return ok
}

// ResetCarryParam resets all changes to the "carry_param" field.
func (m *MenuMutation) ResetCarryParam() {
	m.carry_param = nil
	delete(m.clearedFields, menu.FieldCarryParam)
}

// SetHideChildrenInMenu sets the "hide_children_in_menu" field.
func (m *MenuMutation) SetHideChildrenInMenu(b bool) {
	m.hide_children_in_menu = &b
}

// HideChildrenInMenu returns the value of the "hide_children_in_menu" field in the mutation.
func (m *MenuMutation) HideChildrenInMenu() (r bool, exists bool) {
	v := m.hide_children_in_menu
	if v == nil {
		return
	}
	return *v, true
}

// OldHideChildrenInMenu returns the old "hide_children_in_menu" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldHideChildrenInMenu(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHideChildrenInMenu is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHideChildrenInMenu requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHideChildrenInMenu: %w", err)
	}
	return oldValue.HideChildrenInMenu, nil
}

// ClearHideChildrenInMenu clears the value of the "hide_children_in_menu" field.
func (m *MenuMutation) ClearHideChildrenInMenu() {
	m.hide_children_in_menu = nil
	m.clearedFields[menu.FieldHideChildrenInMenu] = struct{}{}
}

// HideChildrenInMenuCleared returns if the "hide_children_in_menu" field was cleared in this mutation.
func (m *MenuMutation) HideChildrenInMenuCleared() bool {
	_, ok := m.clearedFields[menu.FieldHideChildrenInMenu]
	return ok
}

// ResetHideChildrenInMenu resets all changes to the "hide_children_in_menu" field.
func (m *MenuMutation) ResetHideChildrenInMenu() {
	m.hide_children_in_menu = nil
	delete(m.clearedFields, menu.FieldHideChildrenInMenu)
}

// SetAffix sets the "affix" field.
func (m *MenuMutation) SetAffix(b bool) {
	m.affix = &b
}

// Affix returns the value of the "affix" field in the mutation.
func (m *MenuMutation) Affix() (r bool, exists bool) {
	v := m.affix
	if v == nil {
		return
	}
	return *v, true
}

// OldAffix returns the old "affix" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldAffix(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAffix is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAffix requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAffix: %w", err)
	}
	return oldValue.Affix, nil
}

// ClearAffix clears the value of the "affix" field.
func (m *MenuMutation) ClearAffix() {
	m.affix = nil
	m.clearedFields[menu.FieldAffix] = struct{}{}
}

// AffixCleared returns if the "affix" field was cleared in this mutation.
func (m *MenuMutation) AffixCleared() bool {
	_, ok := m.clearedFields[menu.FieldAffix]
	return ok
}

// ResetAffix resets all changes to the "affix" field.
func (m *MenuMutation) ResetAffix() {
	m.affix = nil
	delete(m.clearedFields, menu.FieldAffix)
}

// SetDynamicLevel sets the "dynamic_level" field.
func (m *MenuMutation) SetDynamicLevel(u uint32) {
	m.dynamic_level = &u
	m.adddynamic_level = nil
}

// DynamicLevel returns the value of the "dynamic_level" field in the mutation.
func (m *MenuMutation) DynamicLevel() (r uint32, exists bool) {
	v := m.dynamic_level
	if v == nil {
		return
	}
	return *v, true
}

// OldDynamicLevel returns the old "dynamic_level" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldDynamicLevel(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDynamicLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDynamicLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDynamicLevel: %w", err)
	}
	return oldValue.DynamicLevel, nil
}

// AddDynamicLevel adds u to the "dynamic_level" field.
func (m *MenuMutation) AddDynamicLevel(u int32) {
	if m.adddynamic_level != nil {
		*m.adddynamic_level += u
	} else {
		m.adddynamic_level = &u
	}
}

// AddedDynamicLevel returns the value that was added to the "dynamic_level" field in this mutation.
func (m *MenuMutation) AddedDynamicLevel() (r int32, exists bool) {
	v := m.adddynamic_level
	if v == nil {
		return
	}
	return *v, true
}

// ClearDynamicLevel clears the value of the "dynamic_level" field.
func (m *MenuMutation) ClearDynamicLevel() {
	m.dynamic_level = nil
	m.adddynamic_level = nil
	m.clearedFields[menu.FieldDynamicLevel] = struct{}{}
}

// DynamicLevelCleared returns if the "dynamic_level" field was cleared in this mutation.
func (m *MenuMutation) DynamicLevelCleared() bool {
	_, ok := m.clearedFields[menu.FieldDynamicLevel]
	return ok
}

// ResetDynamicLevel resets all changes to the "dynamic_level" field.
func (m *MenuMutation) ResetDynamicLevel() {
	m.dynamic_level = nil
	m.adddynamic_level = nil
	delete(m.clearedFields, menu.FieldDynamicLevel)
}

// SetRealPath sets the "real_path" field.
func (m *MenuMutation) SetRealPath(s string) {
	m.real_path = &s
}

// RealPath returns the value of the "real_path" field in the mutation.
func (m *MenuMutation) RealPath() (r string, exists bool) {
	v := m.real_path
	if v == nil {
		return
	}
	return *v, true
}

// OldRealPath returns the old "real_path" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldRealPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRealPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRealPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRealPath: %w", err)
	}
	return oldValue.RealPath, nil
}

// ClearRealPath clears the value of the "real_path" field.
func (m *MenuMutation) ClearRealPath() {
	m.real_path = nil
	m.clearedFields[menu.FieldRealPath] = struct{}{}
}

// RealPathCleared returns if the "real_path" field was cleared in this mutation.
func (m *MenuMutation) RealPathCleared() bool {
	_, ok := m.clearedFields[menu.FieldRealPath]
	return ok
}

// ResetRealPath resets all changes to the "real_path" field.
func (m *MenuMutation) ResetRealPath() {
	m.real_path = nil
	delete(m.clearedFields, menu.FieldRealPath)
}

// SetParams sets the "params" field.
func (m *MenuMutation) SetParams(s string) {
	m.params = &s
}

// Params returns the value of the "params" field in the mutation.
func (m *MenuMutation) Params() (r string, exists bool) {
	v := m.params
	if v == nil {
		return
	}
	return *v, true
}

// OldParams returns the old "params" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldParams(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParams is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParams requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParams: %w", err)
	}
	return oldValue.Params, nil
}

// ClearParams clears the value of the "params" field.
func (m *MenuMutation) ClearParams() {
	m.params = nil
	m.clearedFields[menu.FieldParams] = struct{}{}
}

// ParamsCleared returns if the "params" field was cleared in this mutation.
func (m *MenuMutation) ParamsCleared() bool {
	_, ok := m.clearedFields[menu.FieldParams]
	return ok
}

// ResetParams resets all changes to the "params" field.
func (m *MenuMutation) ResetParams() {
	m.params = nil
	delete(m.clearedFields, menu.FieldParams)
}

// AddRoleIDs adds the "roles" edge to the Role entity by ids.
func (m *MenuMutation) AddRoleIDs(ids ...uint64) {
	if m.roles == nil {
		m.roles = make(map[uint64]struct{})
	}
	for i := range ids {
		m.roles[ids[i]] = struct{}{}
	}
}

// ClearRoles clears the "roles" edge to the Role entity.
func (m *MenuMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the Role entity was cleared.
func (m *MenuMutation) RolesCleared() bool {
	return m.clearedroles
}

// RemoveRoleIDs removes the "roles" edge to the Role entity by IDs.
func (m *MenuMutation) RemoveRoleIDs(ids ...uint64) {
	if m.removedroles == nil {
		m.removedroles = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.roles, ids[i])
		m.removedroles[ids[i]] = struct{}{}
	}
}

// RemovedRoles returns the removed IDs of the "roles" edge to the Role entity.
func (m *MenuMutation) RemovedRolesIDs() (ids []uint64) {
	for id := range m.removedroles {
		ids = append(ids, id)
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
func (m *MenuMutation) RolesIDs() (ids []uint64) {
	for id := range m.roles {
		ids = append(ids, id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *MenuMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
	m.removedroles = nil
}

// ClearParent clears the "parent" edge to the Menu entity.
func (m *MenuMutation) ClearParent() {
	m.clearedparent = true
	m.clearedFields[menu.FieldParentID] = struct{}{}
}

// ParentCleared reports if the "parent" edge to the Menu entity was cleared.
func (m *MenuMutation) ParentCleared() bool {
	return m.ParentIDCleared() || m.clearedparent
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *MenuMutation) ParentIDs() (ids []uint64) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *MenuMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the Menu entity by ids.
func (m *MenuMutation) AddChildIDs(ids ...uint64) {
	if m.children == nil {
		m.children = make(map[uint64]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the Menu entity.
func (m *MenuMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the Menu entity was cleared.
func (m *MenuMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the Menu entity by IDs.
func (m *MenuMutation) RemoveChildIDs(ids ...uint64) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the Menu entity.
func (m *MenuMutation) RemovedChildrenIDs() (ids []uint64) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *MenuMutation) ChildrenIDs() (ids []uint64) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *MenuMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// Where appends a list predicates to the MenuMutation builder.
func (m *MenuMutation) Where(ps ...predicate.Menu) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MenuMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MenuMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Menu, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MenuMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MenuMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Menu).
func (m *MenuMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MenuMutation) Fields() []string {
	fields := make([]string, 0, 27)
	if m.created_at != nil {
		fields = append(fields, menu.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, menu.FieldUpdatedAt)
	}
	if m.sort != nil {
		fields = append(fields, menu.FieldSort)
	}
	if m.tenant_id != nil {
		fields = append(fields, menu.FieldTenantID)
	}
	if m.parent != nil {
		fields = append(fields, menu.FieldParentID)
	}
	if m.menu_level != nil {
		fields = append(fields, menu.FieldMenuLevel)
	}
	if m.menu_type != nil {
		fields = append(fields, menu.FieldMenuType)
	}
	if m._path != nil {
		fields = append(fields, menu.FieldPath)
	}
	if m.name != nil {
		fields = append(fields, menu.FieldName)
	}
	if m.redirect != nil {
		fields = append(fields, menu.FieldRedirect)
	}
	if m.component != nil {
		fields = append(fields, menu.FieldComponent)
	}
	if m.disabled != nil {
		fields = append(fields, menu.FieldDisabled)
	}
	if m.service_name != nil {
		fields = append(fields, menu.FieldServiceName)
	}
	if m.permission != nil {
		fields = append(fields, menu.FieldPermission)
	}
	if m.title != nil {
		fields = append(fields, menu.FieldTitle)
	}
	if m.icon != nil {
		fields = append(fields, menu.FieldIcon)
	}
	if m.hide_menu != nil {
		fields = append(fields, menu.FieldHideMenu)
	}
	if m.hide_breadcrumb != nil {
		fields = append(fields, menu.FieldHideBreadcrumb)
	}
	if m.ignore_keep_alive != nil {
		fields = append(fields, menu.FieldIgnoreKeepAlive)
	}
	if m.hide_tab != nil {
		fields = append(fields, menu.FieldHideTab)
	}
	if m.frame_src != nil {
		fields = append(fields, menu.FieldFrameSrc)
	}
	if m.carry_param != nil {
		fields = append(fields, menu.FieldCarryParam)
	}
	if m.hide_children_in_menu != nil {
		fields = append(fields, menu.FieldHideChildrenInMenu)
	}
	if m.affix != nil {
		fields = append(fields, menu.FieldAffix)
	}
	if m.dynamic_level != nil {
		fields = append(fields, menu.FieldDynamicLevel)
	}
	if m.real_path != nil {
		fields = append(fields, menu.FieldRealPath)
	}
	if m.params != nil {
		fields = append(fields, menu.FieldParams)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MenuMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case menu.FieldCreatedAt:
		return m.CreatedAt()
	case menu.FieldUpdatedAt:
		return m.UpdatedAt()
	case menu.FieldSort:
		return m.Sort()
	case menu.FieldTenantID:
		return m.TenantID()
	case menu.FieldParentID:
		return m.ParentID()
	case menu.FieldMenuLevel:
		return m.MenuLevel()
	case menu.FieldMenuType:
		return m.MenuType()
	case menu.FieldPath:
		return m.Path()
	case menu.FieldName:
		return m.Name()
	case menu.FieldRedirect:
		return m.Redirect()
	case menu.FieldComponent:
		return m.Component()
	case menu.FieldDisabled:
		return m.Disabled()
	case menu.FieldServiceName:
		return m.ServiceName()
	case menu.FieldPermission:
		return m.Permission()
	case menu.FieldTitle:
		return m.Title()
	case menu.FieldIcon:
		return m.Icon()
	case menu.FieldHideMenu:
		return m.HideMenu()
	case menu.FieldHideBreadcrumb:
		return m.HideBreadcrumb()
	case menu.FieldIgnoreKeepAlive:
		return m.IgnoreKeepAlive()
	case menu.FieldHideTab:
		return m.HideTab()
	case menu.FieldFrameSrc:
		return m.FrameSrc()
	case menu.FieldCarryParam:
		return m.CarryParam()
	case menu.FieldHideChildrenInMenu:
		return m.HideChildrenInMenu()
	case menu.FieldAffix:
		return m.Affix()
	case menu.FieldDynamicLevel:
		return m.DynamicLevel()
	case menu.FieldRealPath:
		return m.RealPath()
	case menu.FieldParams:
		return m.Params()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MenuMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case menu.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case menu.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case menu.FieldSort:
		return m.OldSort(ctx)
	case menu.FieldTenantID:
		return m.OldTenantID(ctx)
	case menu.FieldParentID:
		return m.OldParentID(ctx)
	case menu.FieldMenuLevel:
		return m.OldMenuLevel(ctx)
	case menu.FieldMenuType:
		return m.OldMenuType(ctx)
	case menu.FieldPath:
		return m.OldPath(ctx)
	case menu.FieldName:
		return m.OldName(ctx)
	case menu.FieldRedirect:
		return m.OldRedirect(ctx)
	case menu.FieldComponent:
		return m.OldComponent(ctx)
	case menu.FieldDisabled:
		return m.OldDisabled(ctx)
	case menu.FieldServiceName:
		return m.OldServiceName(ctx)
	case menu.FieldPermission:
		return m.OldPermission(ctx)
	case menu.FieldTitle:
		return m.OldTitle(ctx)
	case menu.FieldIcon:
		return m.OldIcon(ctx)
	case menu.FieldHideMenu:
		return m.OldHideMenu(ctx)
	case menu.FieldHideBreadcrumb:
		return m.OldHideBreadcrumb(ctx)
	case menu.FieldIgnoreKeepAlive:
		return m.OldIgnoreKeepAlive(ctx)
	case menu.FieldHideTab:
		return m.OldHideTab(ctx)
	case menu.FieldFrameSrc:
		return m.OldFrameSrc(ctx)
	case menu.FieldCarryParam:
		return m.OldCarryParam(ctx)
	case menu.FieldHideChildrenInMenu:
		return m.OldHideChildrenInMenu(ctx)
	case menu.FieldAffix:
		return m.OldAffix(ctx)
	case menu.FieldDynamicLevel:
		return m.OldDynamicLevel(ctx)
	case menu.FieldRealPath:
		return m.OldRealPath(ctx)
	case menu.FieldParams:
		return m.OldParams(ctx)
	}
	return nil, fmt.Errorf("unknown Menu field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MenuMutation) SetField(name string, value ent.Value) error {
	switch name {
	case menu.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case menu.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case menu.FieldSort:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	case menu.FieldTenantID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case menu.FieldParentID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case menu.FieldMenuLevel:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMenuLevel(v)
		return nil
	case menu.FieldMenuType:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMenuType(v)
		return nil
	case menu.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case menu.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case menu.FieldRedirect:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRedirect(v)
		return nil
	case menu.FieldComponent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComponent(v)
		return nil
	case menu.FieldDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabled(v)
		return nil
	case menu.FieldServiceName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServiceName(v)
		return nil
	case menu.FieldPermission:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPermission(v)
		return nil
	case menu.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case menu.FieldIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcon(v)
		return nil
	case menu.FieldHideMenu:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHideMenu(v)
		return nil
	case menu.FieldHideBreadcrumb:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHideBreadcrumb(v)
		return nil
	case menu.FieldIgnoreKeepAlive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIgnoreKeepAlive(v)
		return nil
	case menu.FieldHideTab:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHideTab(v)
		return nil
	case menu.FieldFrameSrc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFrameSrc(v)
		return nil
	case menu.FieldCarryParam:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarryParam(v)
		return nil
	case menu.FieldHideChildrenInMenu:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHideChildrenInMenu(v)
		return nil
	case menu.FieldAffix:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAffix(v)
		return nil
	case menu.FieldDynamicLevel:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDynamicLevel(v)
		return nil
	case menu.FieldRealPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRealPath(v)
		return nil
	case menu.FieldParams:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParams(v)
		return nil
	}
	return fmt.Errorf("unknown Menu field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MenuMutation) AddedFields() []string {
	var fields []string
	if m.addsort != nil {
		fields = append(fields, menu.FieldSort)
	}
	if m.addtenant_id != nil {
		fields = append(fields, menu.FieldTenantID)
	}
	if m.addmenu_level != nil {
		fields = append(fields, menu.FieldMenuLevel)
	}
	if m.addmenu_type != nil {
		fields = append(fields, menu.FieldMenuType)
	}
	if m.adddynamic_level != nil {
		fields = append(fields, menu.FieldDynamicLevel)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MenuMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case menu.FieldSort:
		return m.AddedSort()
	case menu.FieldTenantID:
		return m.AddedTenantID()
	case menu.FieldMenuLevel:
		return m.AddedMenuLevel()
	case menu.FieldMenuType:
		return m.AddedMenuType()
	case menu.FieldDynamicLevel:
		return m.AddedDynamicLevel()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MenuMutation) AddField(name string, value ent.Value) error {
	switch name {
	case menu.FieldSort:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSort(v)
		return nil
	case menu.FieldTenantID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case menu.FieldMenuLevel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMenuLevel(v)
		return nil
	case menu.FieldMenuType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMenuType(v)
		return nil
	case menu.FieldDynamicLevel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDynamicLevel(v)
		return nil
	}
	return fmt.Errorf("unknown Menu numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MenuMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(menu.FieldParentID) {
		fields = append(fields, menu.FieldParentID)
	}
	if m.FieldCleared(menu.FieldPath) {
		fields = append(fields, menu.FieldPath)
	}
	if m.FieldCleared(menu.FieldRedirect) {
		fields = append(fields, menu.FieldRedirect)
	}
	if m.FieldCleared(menu.FieldComponent) {
		fields = append(fields, menu.FieldComponent)
	}
	if m.FieldCleared(menu.FieldDisabled) {
		fields = append(fields, menu.FieldDisabled)
	}
	if m.FieldCleared(menu.FieldServiceName) {
		fields = append(fields, menu.FieldServiceName)
	}
	if m.FieldCleared(menu.FieldPermission) {
		fields = append(fields, menu.FieldPermission)
	}
	if m.FieldCleared(menu.FieldHideMenu) {
		fields = append(fields, menu.FieldHideMenu)
	}
	if m.FieldCleared(menu.FieldHideBreadcrumb) {
		fields = append(fields, menu.FieldHideBreadcrumb)
	}
	if m.FieldCleared(menu.FieldIgnoreKeepAlive) {
		fields = append(fields, menu.FieldIgnoreKeepAlive)
	}
	if m.FieldCleared(menu.FieldHideTab) {
		fields = append(fields, menu.FieldHideTab)
	}
	if m.FieldCleared(menu.FieldFrameSrc) {
		fields = append(fields, menu.FieldFrameSrc)
	}
	if m.FieldCleared(menu.FieldCarryParam) {
		fields = append(fields, menu.FieldCarryParam)
	}
	if m.FieldCleared(menu.FieldHideChildrenInMenu) {
		fields = append(fields, menu.FieldHideChildrenInMenu)
	}
	if m.FieldCleared(menu.FieldAffix) {
		fields = append(fields, menu.FieldAffix)
	}
	if m.FieldCleared(menu.FieldDynamicLevel) {
		fields = append(fields, menu.FieldDynamicLevel)
	}
	if m.FieldCleared(menu.FieldRealPath) {
		fields = append(fields, menu.FieldRealPath)
	}
	if m.FieldCleared(menu.FieldParams) {
		fields = append(fields, menu.FieldParams)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MenuMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MenuMutation) ClearField(name string) error {
	switch name {
	case menu.FieldParentID:
		m.ClearParentID()
		return nil
	case menu.FieldPath:
		m.ClearPath()
		return nil
	case menu.FieldRedirect:
		m.ClearRedirect()
		return nil
	case menu.FieldComponent:
		m.ClearComponent()
		return nil
	case menu.FieldDisabled:
		m.ClearDisabled()
		return nil
	case menu.FieldServiceName:
		m.ClearServiceName()
		return nil
	case menu.FieldPermission:
		m.ClearPermission()
		return nil
	case menu.FieldHideMenu:
		m.ClearHideMenu()
		return nil
	case menu.FieldHideBreadcrumb:
		m.ClearHideBreadcrumb()
		return nil
	case menu.FieldIgnoreKeepAlive:
		m.ClearIgnoreKeepAlive()
		return nil
	case menu.FieldHideTab:
		m.ClearHideTab()
		return nil
	case menu.FieldFrameSrc:
		m.ClearFrameSrc()
		return nil
	case menu.FieldCarryParam:
		m.ClearCarryParam()
		return nil
	case menu.FieldHideChildrenInMenu:
		m.ClearHideChildrenInMenu()
		return nil
	case menu.FieldAffix:
		m.ClearAffix()
		return nil
	case menu.FieldDynamicLevel:
		m.ClearDynamicLevel()
		return nil
	case menu.FieldRealPath:
		m.ClearRealPath()
		return nil
	case menu.FieldParams:
		m.ClearParams()
		return nil
	}
	return fmt.Errorf("unknown Menu nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MenuMutation) ResetField(name string) error {
	switch name {
	case menu.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case menu.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case menu.FieldSort:
		m.ResetSort()
		return nil
	case menu.FieldTenantID:
		m.ResetTenantID()
		return nil
	case menu.FieldParentID:
		m.ResetParentID()
		return nil
	case menu.FieldMenuLevel:
		m.ResetMenuLevel()
		return nil
	case menu.FieldMenuType:
		m.ResetMenuType()
		return nil
	case menu.FieldPath:
		m.ResetPath()
		return nil
	case menu.FieldName:
		m.ResetName()
		return nil
	case menu.FieldRedirect:
		m.ResetRedirect()
		return nil
	case menu.FieldComponent:
		m.ResetComponent()
		return nil
	case menu.FieldDisabled:
		m.ResetDisabled()
		return nil
	case menu.FieldServiceName:
		m.ResetServiceName()
		return nil
	case menu.FieldPermission:
		m.ResetPermission()
		return nil
	case menu.FieldTitle:
		m.ResetTitle()
		return nil
	case menu.FieldIcon:
		m.ResetIcon()
		return nil
	case menu.FieldHideMenu:
		m.ResetHideMenu()
		return nil
	case menu.FieldHideBreadcrumb:
		m.ResetHideBreadcrumb()
		return nil
	case menu.FieldIgnoreKeepAlive:
		m.ResetIgnoreKeepAlive()
		return nil
	case menu.FieldHideTab:
		m.ResetHideTab()
		return nil
	case menu.FieldFrameSrc:
		m.ResetFrameSrc()
		return nil
	case menu.FieldCarryParam:
		m.ResetCarryParam()
		return nil
	case menu.FieldHideChildrenInMenu:
		m.ResetHideChildrenInMenu()
		return nil
	case menu.FieldAffix:
		m.ResetAffix()
		return nil
	case menu.FieldDynamicLevel:
		m.ResetDynamicLevel()
		return nil
	case menu.FieldRealPath:
		m.ResetRealPath()
		return nil
	case menu.FieldParams:
		m.ResetParams()
		return nil
	}
	return fmt.Errorf("unknown Menu field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MenuMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.roles != nil {
		edges = append(edges, menu.EdgeRoles)
	}
	if m.parent != nil {
		edges = append(edges, menu.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, menu.EdgeChildren)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MenuMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case menu.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.roles))
		for id := range m.roles {
			ids = append(ids, id)
		}
		return ids
	case menu.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case menu.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MenuMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedroles != nil {
		edges = append(edges, menu.EdgeRoles)
	}
	if m.removedchildren != nil {
		edges = append(edges, menu.EdgeChildren)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MenuMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case menu.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.removedroles))
		for id := range m.removedroles {
			ids = append(ids, id)
		}
		return ids
	case menu.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MenuMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedroles {
		edges = append(edges, menu.EdgeRoles)
	}
	if m.clearedparent {
		edges = append(edges, menu.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, menu.EdgeChildren)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MenuMutation) EdgeCleared(name string) bool {
	switch name {
	case menu.EdgeRoles:
		return m.clearedroles
	case menu.EdgeParent:
		return m.clearedparent
	case menu.EdgeChildren:
		return m.clearedchildren
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MenuMutation) ClearEdge(name string) error {
	switch name {
	case menu.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown Menu unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MenuMutation) ResetEdge(name string) error {
	switch name {
	case menu.EdgeRoles:
		m.ResetRoles()
		return nil
	case menu.EdgeParent:
		m.ResetParent()
		return nil
	case menu.EdgeChildren:
		m.ResetChildren()
		return nil
	}
	return fmt.Errorf("unknown Menu edge %s", name)
}

// OauthAccountMutation represents an operation that mutates the OauthAccount nodes in the graph.
type OauthAccountMutation struct {
	config
	op                Op
	typ               string
	id                *uint64
	created_at        *time.Time
	updated_at        *time.Time
	status            *uint8
	addstatus         *int8
	tenant_id         *uint64
	addtenant_id      *int64
	provider_type     *string
	provider_user_id  *string
	provider_username *string
	provider_nickname *string
	provider_email    *string
	provider_avatar   *string
	access_token      *string
	refresh_token     *string
	token_expires_at  *time.Time
	extra_data        *map[string]interface{}
	last_login_at     *time.Time
	last_login_ip     *string
	login_count       *uint32
	addlogin_count    *int32
	department_id     *uint64
	adddepartment_id  *int64
	clearedFields     map[string]struct{}
	user              *uuid.UUID
	cleareduser       bool
	provider          *uint64
	clearedprovider   bool
	done              bool
	oldValue          func(context.Context) (*OauthAccount, error)
	predicates        []predicate.OauthAccount
}

var _ ent.Mutation = (*OauthAccountMutation)(nil)

// oauthaccountOption allows management of the mutation configuration using functional options.
type oauthaccountOption func(*OauthAccountMutation)

// newOauthAccountMutation creates new mutation for the OauthAccount entity.
func newOauthAccountMutation(c config, op Op, opts ...oauthaccountOption) *OauthAccountMutation {
	m := &OauthAccountMutation{
		config:        c,
		op:            op,
		typ:           TypeOauthAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOauthAccountID sets the ID field of the mutation.
func withOauthAccountID(id uint64) oauthaccountOption {
	return func(m *OauthAccountMutation) {
		var (
			err   error
			once  sync.Once
			value *OauthAccount
		)
		m.oldValue = func(ctx context.Context) (*OauthAccount, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OauthAccount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOauthAccount sets the old OauthAccount of the mutation.
func withOauthAccount(node *OauthAccount) oauthaccountOption {
	return func(m *OauthAccountMutation) {
		m.oldValue = func(context.Context) (*OauthAccount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OauthAccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OauthAccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OauthAccount entities.
func (m *OauthAccountMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OauthAccountMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OauthAccountMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OauthAccount.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OauthAccountMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OauthAccountMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OauthAccount entity.
// If the OauthAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthAccountMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OauthAccountMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OauthAccountMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OauthAccountMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OauthAccount entity.
// If the OauthAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthAccountMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OauthAccountMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *OauthAccountMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *OauthAccountMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the OauthAccount entity.
// If the OauthAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthAccountMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *OauthAccountMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *OauthAccountMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *OauthAccountMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[oauthaccount.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *OauthAccountMutation) StatusCleared() bool {
	_, ok := m.clearedFields[oauthaccount.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *OauthAccountMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, oauthaccount.FieldStatus)
}

// SetTenantID sets the "tenant_id" field.
func (m *OauthAccountMutation) SetTenantID(u uint64) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *OauthAccountMutation) TenantID() (r uint64, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the OauthAccount entity.
// If the OauthAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthAccountMutation) OldTenantID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *OauthAccountMutation) AddTenantID(u int64) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *OauthAccountMutation) AddedTenantID() (r int64, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *OauthAccountMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetUserID sets the "user_id" field.
func (m *OauthAccountMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *OauthAccountMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the OauthAccount entity.
// If the OauthAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthAccountMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *OauthAccountMutation) ResetUserID() {
	m.user = nil
}

// SetProviderID sets the "provider_id" field.
func (m *OauthAccountMutation) SetProviderID(u uint64) {
	m.provider = &u
}

// ProviderID returns the value of the "provider_id" field in the mutation.
func (m *OauthAccountMutation) ProviderID() (r uint64, exists bool) {
	v := m.provider
	if v == nil {
		return
	}
	return *v, true
}

// OldProviderID returns the old "provider_id" field's value of the OauthAccount entity.
// If the OauthAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthAccountMutation) OldProviderID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProviderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProviderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProviderID: %w", err)
	}
	return oldValue.ProviderID, nil
}

// ResetProviderID resets all changes to the "provider_id" field.
func (m *OauthAccountMutation) ResetProviderID() {
	m.provider = nil
}

// SetProviderType sets the "provider_type" field.
func (m *OauthAccountMutation) SetProviderType(s string) {
	m.provider_type = &s
}

// ProviderType returns the value of the "provider_type" field in the mutation.
func (m *OauthAccountMutation) ProviderType() (r string, exists bool) {
	v := m.provider_type
	if v == nil {
		return
	}
	return *v, true
}

// OldProviderType returns the old "provider_type" field's value of the OauthAccount entity.
// If the OauthAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthAccountMutation) OldProviderType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProviderType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProviderType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProviderType: %w", err)
	}
	return oldValue.ProviderType, nil
}

// ResetProviderType resets all changes to the "provider_type" field.
func (m *OauthAccountMutation) ResetProviderType() {
	m.provider_type = nil
}

// SetProviderUserID sets the "provider_user_id" field.
func (m *OauthAccountMutation) SetProviderUserID(s string) {
	m.provider_user_id = &s
}

// ProviderUserID returns the value of the "provider_user_id" field in the mutation.
func (m *OauthAccountMutation) ProviderUserID() (r string, exists bool) {
	v := m.provider_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProviderUserID returns the old "provider_user_id" field's value of the OauthAccount entity.
// If the OauthAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthAccountMutation) OldProviderUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProviderUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProviderUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProviderUserID: %w", err)
	}
	return oldValue.ProviderUserID, nil
}

// ResetProviderUserID resets all changes to the "provider_user_id" field.
func (m *OauthAccountMutation) ResetProviderUserID() {
	m.provider_user_id = nil
}

// SetProviderUsername sets the "provider_username" field.
func (m *OauthAccountMutation) SetProviderUsername(s string) {
	m.provider_username = &s
}

// ProviderUsername returns the value of the "provider_username" field in the mutation.
func (m *OauthAccountMutation) ProviderUsername() (r string, exists bool) {
	v := m.provider_username
	if v == nil {
		return
	}
	return *v, true
}

// OldProviderUsername returns the old "provider_username" field's value of the OauthAccount entity.
// If the OauthAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthAccountMutation) OldProviderUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProviderUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProviderUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProviderUsername: %w", err)
	}
	return oldValue.ProviderUsername, nil
}

// ClearProviderUsername clears the value of the "provider_username" field.
func (m *OauthAccountMutation) ClearProviderUsername() {
	m.provider_username = nil
	m.clearedFields[oauthaccount.FieldProviderUsername] = struct{}{}
}

// ProviderUsernameCleared returns if the "provider_username" field was cleared in this mutation.
func (m *OauthAccountMutation) ProviderUsernameCleared() bool {
	_, ok := m.clearedFields[oauthaccount.FieldProviderUsername]
	return ok
}

// ResetProviderUsername resets all changes to the "provider_username" field.
func (m *OauthAccountMutation) ResetProviderUsername() {
	m.provider_username = nil
	delete(m.clearedFields, oauthaccount.FieldProviderUsername)
}

// SetProviderNickname sets the "provider_nickname" field.
func (m *OauthAccountMutation) SetProviderNickname(s string) {
	m.provider_nickname = &s
}

// ProviderNickname returns the value of the "provider_nickname" field in the mutation.
func (m *OauthAccountMutation) ProviderNickname() (r string, exists bool) {
	v := m.provider_nickname
	if v == nil {
		return
	}
	return *v, true
}

// OldProviderNickname returns the old "provider_nickname" field's value of the OauthAccount entity.
// If the OauthAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthAccountMutation) OldProviderNickname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProviderNickname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProviderNickname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProviderNickname: %w", err)
	}
	return oldValue.ProviderNickname, nil
}

// ClearProviderNickname clears the value of the "provider_nickname" field.
func (m *OauthAccountMutation) ClearProviderNickname() {
	m.provider_nickname = nil
	m.clearedFields[oauthaccount.FieldProviderNickname] = struct{}{}
}

// ProviderNicknameCleared returns if the "provider_nickname" field was cleared in this mutation.
func (m *OauthAccountMutation) ProviderNicknameCleared() bool {
	_, ok := m.clearedFields[oauthaccount.FieldProviderNickname]
	return ok
}

// ResetProviderNickname resets all changes to the "provider_nickname" field.
func (m *OauthAccountMutation) ResetProviderNickname() {
	m.provider_nickname = nil
	delete(m.clearedFields, oauthaccount.FieldProviderNickname)
}

// SetProviderEmail sets the "provider_email" field.
func (m *OauthAccountMutation) SetProviderEmail(s string) {
	m.provider_email = &s
}

// ProviderEmail returns the value of the "provider_email" field in the mutation.
func (m *OauthAccountMutation) ProviderEmail() (r string, exists bool) {
	v := m.provider_email
	if v == nil {
		return
	}
	return *v, true
}

// OldProviderEmail returns the old "provider_email" field's value of the OauthAccount entity.
// If the OauthAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthAccountMutation) OldProviderEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProviderEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProviderEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProviderEmail: %w", err)
	}
	return oldValue.ProviderEmail, nil
}

// ClearProviderEmail clears the value of the "provider_email" field.
func (m *OauthAccountMutation) ClearProviderEmail() {
	m.provider_email = nil
	m.clearedFields[oauthaccount.FieldProviderEmail] = struct{}{}
}

// ProviderEmailCleared returns if the "provider_email" field was cleared in this mutation.
func (m *OauthAccountMutation) ProviderEmailCleared() bool {
	_, ok := m.clearedFields[oauthaccount.FieldProviderEmail]
	return ok
}

// ResetProviderEmail resets all changes to the "provider_email" field.
func (m *OauthAccountMutation) ResetProviderEmail() {
	m.provider_email = nil
	delete(m.clearedFields, oauthaccount.FieldProviderEmail)
}

// SetProviderAvatar sets the "provider_avatar" field.
func (m *OauthAccountMutation) SetProviderAvatar(s string) {
	m.provider_avatar = &s
}

// ProviderAvatar returns the value of the "provider_avatar" field in the mutation.
func (m *OauthAccountMutation) ProviderAvatar() (r string, exists bool) {
	v := m.provider_avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldProviderAvatar returns the old "provider_avatar" field's value of the OauthAccount entity.
// If the OauthAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthAccountMutation) OldProviderAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProviderAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProviderAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProviderAvatar: %w", err)
	}
	return oldValue.ProviderAvatar, nil
}

// ClearProviderAvatar clears the value of the "provider_avatar" field.
func (m *OauthAccountMutation) ClearProviderAvatar() {
	m.provider_avatar = nil
	m.clearedFields[oauthaccount.FieldProviderAvatar] = struct{}{}
}

// ProviderAvatarCleared returns if the "provider_avatar" field was cleared in this mutation.
func (m *OauthAccountMutation) ProviderAvatarCleared() bool {
	_, ok := m.clearedFields[oauthaccount.FieldProviderAvatar]
	return ok
}

// ResetProviderAvatar resets all changes to the "provider_avatar" field.
func (m *OauthAccountMutation) ResetProviderAvatar() {
	m.provider_avatar = nil
	delete(m.clearedFields, oauthaccount.FieldProviderAvatar)
}

// SetAccessToken sets the "access_token" field.
func (m *OauthAccountMutation) SetAccessToken(s string) {
	m.access_token = &s
}

// AccessToken returns the value of the "access_token" field in the mutation.
func (m *OauthAccountMutation) AccessToken() (r string, exists bool) {
	v := m.access_token
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessToken returns the old "access_token" field's value of the OauthAccount entity.
// If the OauthAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthAccountMutation) OldAccessToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccessToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccessToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessToken: %w", err)
	}
	return oldValue.AccessToken, nil
}

// ResetAccessToken resets all changes to the "access_token" field.
func (m *OauthAccountMutation) ResetAccessToken() {
	m.access_token = nil
}

// SetRefreshToken sets the "refresh_token" field.
func (m *OauthAccountMutation) SetRefreshToken(s string) {
	m.refresh_token = &s
}

// RefreshToken returns the value of the "refresh_token" field in the mutation.
func (m *OauthAccountMutation) RefreshToken() (r string, exists bool) {
	v := m.refresh_token
	if v == nil {
		return
	}
	return *v, true
}

// OldRefreshToken returns the old "refresh_token" field's value of the OauthAccount entity.
// If the OauthAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthAccountMutation) OldRefreshToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefreshToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefreshToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefreshToken: %w", err)
	}
	return oldValue.RefreshToken, nil
}

// ClearRefreshToken clears the value of the "refresh_token" field.
func (m *OauthAccountMutation) ClearRefreshToken() {
	m.refresh_token = nil
	m.clearedFields[oauthaccount.FieldRefreshToken] = struct{}{}
}

// RefreshTokenCleared returns if the "refresh_token" field was cleared in this mutation.
func (m *OauthAccountMutation) RefreshTokenCleared() bool {
	_, ok := m.clearedFields[oauthaccount.FieldRefreshToken]
	return ok
}

// ResetRefreshToken resets all changes to the "refresh_token" field.
func (m *OauthAccountMutation) ResetRefreshToken() {
	m.refresh_token = nil
	delete(m.clearedFields, oauthaccount.FieldRefreshToken)
}

// SetTokenExpiresAt sets the "token_expires_at" field.
func (m *OauthAccountMutation) SetTokenExpiresAt(t time.Time) {
	m.token_expires_at = &t
}

// TokenExpiresAt returns the value of the "token_expires_at" field in the mutation.
func (m *OauthAccountMutation) TokenExpiresAt() (r time.Time, exists bool) {
	v := m.token_expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenExpiresAt returns the old "token_expires_at" field's value of the OauthAccount entity.
// If the OauthAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthAccountMutation) OldTokenExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenExpiresAt: %w", err)
	}
	return oldValue.TokenExpiresAt, nil
}

// ClearTokenExpiresAt clears the value of the "token_expires_at" field.
func (m *OauthAccountMutation) ClearTokenExpiresAt() {
	m.token_expires_at = nil
	m.clearedFields[oauthaccount.FieldTokenExpiresAt] = struct{}{}
}

// TokenExpiresAtCleared returns if the "token_expires_at" field was cleared in this mutation.
func (m *OauthAccountMutation) TokenExpiresAtCleared() bool {
	_, ok := m.clearedFields[oauthaccount.FieldTokenExpiresAt]
	return ok
}

// ResetTokenExpiresAt resets all changes to the "token_expires_at" field.
func (m *OauthAccountMutation) ResetTokenExpiresAt() {
	m.token_expires_at = nil
	delete(m.clearedFields, oauthaccount.FieldTokenExpiresAt)
}

// SetExtraData sets the "extra_data" field.
func (m *OauthAccountMutation) SetExtraData(value map[string]interface{}) {
	m.extra_data = &value
}

// ExtraData returns the value of the "extra_data" field in the mutation.
func (m *OauthAccountMutation) ExtraData() (r map[string]interface{}, exists bool) {
	v := m.extra_data
	if v == nil {
		return
	}
	return *v, true
}

// OldExtraData returns the old "extra_data" field's value of the OauthAccount entity.
// If the OauthAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthAccountMutation) OldExtraData(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtraData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtraData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtraData: %w", err)
	}
	return oldValue.ExtraData, nil
}

// ClearExtraData clears the value of the "extra_data" field.
func (m *OauthAccountMutation) ClearExtraData() {
	m.extra_data = nil
	m.clearedFields[oauthaccount.FieldExtraData] = struct{}{}
}

// ExtraDataCleared returns if the "extra_data" field was cleared in this mutation.
func (m *OauthAccountMutation) ExtraDataCleared() bool {
	_, ok := m.clearedFields[oauthaccount.FieldExtraData]
	return ok
}

// ResetExtraData resets all changes to the "extra_data" field.
func (m *OauthAccountMutation) ResetExtraData() {
	m.extra_data = nil
	delete(m.clearedFields, oauthaccount.FieldExtraData)
}

// SetLastLoginAt sets the "last_login_at" field.
func (m *OauthAccountMutation) SetLastLoginAt(t time.Time) {
	m.last_login_at = &t
}

// LastLoginAt returns the value of the "last_login_at" field in the mutation.
func (m *OauthAccountMutation) LastLoginAt() (r time.Time, exists bool) {
	v := m.last_login_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLoginAt returns the old "last_login_at" field's value of the OauthAccount entity.
// If the OauthAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthAccountMutation) OldLastLoginAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLoginAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLoginAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLoginAt: %w", err)
	}
	return oldValue.LastLoginAt, nil
}

// ClearLastLoginAt clears the value of the "last_login_at" field.
func (m *OauthAccountMutation) ClearLastLoginAt() {
	m.last_login_at = nil
	m.clearedFields[oauthaccount.FieldLastLoginAt] = struct{}{}
}

// LastLoginAtCleared returns if the "last_login_at" field was cleared in this mutation.
func (m *OauthAccountMutation) LastLoginAtCleared() bool {
	_, ok := m.clearedFields[oauthaccount.FieldLastLoginAt]
	return ok
}

// ResetLastLoginAt resets all changes to the "last_login_at" field.
func (m *OauthAccountMutation) ResetLastLoginAt() {
	m.last_login_at = nil
	delete(m.clearedFields, oauthaccount.FieldLastLoginAt)
}

// SetLastLoginIP sets the "last_login_ip" field.
func (m *OauthAccountMutation) SetLastLoginIP(s string) {
	m.last_login_ip = &s
}

// LastLoginIP returns the value of the "last_login_ip" field in the mutation.
func (m *OauthAccountMutation) LastLoginIP() (r string, exists bool) {
	v := m.last_login_ip
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLoginIP returns the old "last_login_ip" field's value of the OauthAccount entity.
// If the OauthAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthAccountMutation) OldLastLoginIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLoginIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLoginIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLoginIP: %w", err)
	}
	return oldValue.LastLoginIP, nil
}

// ClearLastLoginIP clears the value of the "last_login_ip" field.
func (m *OauthAccountMutation) ClearLastLoginIP() {
	m.last_login_ip = nil
	m.clearedFields[oauthaccount.FieldLastLoginIP] = struct{}{}
}

// LastLoginIPCleared returns if the "last_login_ip" field was cleared in this mutation.
func (m *OauthAccountMutation) LastLoginIPCleared() bool {
	_, ok := m.clearedFields[oauthaccount.FieldLastLoginIP]
	return ok
}

// ResetLastLoginIP resets all changes to the "last_login_ip" field.
func (m *OauthAccountMutation) ResetLastLoginIP() {
	m.last_login_ip = nil
	delete(m.clearedFields, oauthaccount.FieldLastLoginIP)
}

// SetLoginCount sets the "login_count" field.
func (m *OauthAccountMutation) SetLoginCount(u uint32) {
	m.login_count = &u
	m.addlogin_count = nil
}

// LoginCount returns the value of the "login_count" field in the mutation.
func (m *OauthAccountMutation) LoginCount() (r uint32, exists bool) {
	v := m.login_count
	if v == nil {
		return
	}
	return *v, true
}

// OldLoginCount returns the old "login_count" field's value of the OauthAccount entity.
// If the OauthAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthAccountMutation) OldLoginCount(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLoginCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLoginCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLoginCount: %w", err)
	}
	return oldValue.LoginCount, nil
}

// AddLoginCount adds u to the "login_count" field.
func (m *OauthAccountMutation) AddLoginCount(u int32) {
	if m.addlogin_count != nil {
		*m.addlogin_count += u
	} else {
		m.addlogin_count = &u
	}
}

// AddedLoginCount returns the value that was added to the "login_count" field in this mutation.
func (m *OauthAccountMutation) AddedLoginCount() (r int32, exists bool) {
	v := m.addlogin_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetLoginCount resets all changes to the "login_count" field.
func (m *OauthAccountMutation) ResetLoginCount() {
	m.login_count = nil
	m.addlogin_count = nil
}

// SetDepartmentID sets the "department_id" field.
func (m *OauthAccountMutation) SetDepartmentID(u uint64) {
	m.department_id = &u
	m.adddepartment_id = nil
}

// DepartmentID returns the value of the "department_id" field in the mutation.
func (m *OauthAccountMutation) DepartmentID() (r uint64, exists bool) {
	v := m.department_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDepartmentID returns the old "department_id" field's value of the OauthAccount entity.
// If the OauthAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthAccountMutation) OldDepartmentID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDepartmentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDepartmentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepartmentID: %w", err)
	}
	return oldValue.DepartmentID, nil
}

// AddDepartmentID adds u to the "department_id" field.
func (m *OauthAccountMutation) AddDepartmentID(u int64) {
	if m.adddepartment_id != nil {
		*m.adddepartment_id += u
	} else {
		m.adddepartment_id = &u
	}
}

// AddedDepartmentID returns the value that was added to the "department_id" field in this mutation.
func (m *OauthAccountMutation) AddedDepartmentID() (r int64, exists bool) {
	v := m.adddepartment_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearDepartmentID clears the value of the "department_id" field.
func (m *OauthAccountMutation) ClearDepartmentID() {
	m.department_id = nil
	m.adddepartment_id = nil
	m.clearedFields[oauthaccount.FieldDepartmentID] = struct{}{}
}

// DepartmentIDCleared returns if the "department_id" field was cleared in this mutation.
func (m *OauthAccountMutation) DepartmentIDCleared() bool {
	_, ok := m.clearedFields[oauthaccount.FieldDepartmentID]
	return ok
}

// ResetDepartmentID resets all changes to the "department_id" field.
func (m *OauthAccountMutation) ResetDepartmentID() {
	m.department_id = nil
	m.adddepartment_id = nil
	delete(m.clearedFields, oauthaccount.FieldDepartmentID)
}

// ClearUser clears the "user" edge to the User entity.
func (m *OauthAccountMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[oauthaccount.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *OauthAccountMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *OauthAccountMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *OauthAccountMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearProvider clears the "provider" edge to the OauthProvider entity.
func (m *OauthAccountMutation) ClearProvider() {
	m.clearedprovider = true
	m.clearedFields[oauthaccount.FieldProviderID] = struct{}{}
}

// ProviderCleared reports if the "provider" edge to the OauthProvider entity was cleared.
func (m *OauthAccountMutation) ProviderCleared() bool {
	return m.clearedprovider
}

// ProviderIDs returns the "provider" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProviderID instead. It exists only for internal usage by the builders.
func (m *OauthAccountMutation) ProviderIDs() (ids []uint64) {
	if id := m.provider; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProvider resets all changes to the "provider" edge.
func (m *OauthAccountMutation) ResetProvider() {
	m.provider = nil
	m.clearedprovider = false
}

// Where appends a list predicates to the OauthAccountMutation builder.
func (m *OauthAccountMutation) Where(ps ...predicate.OauthAccount) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OauthAccountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OauthAccountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OauthAccount, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OauthAccountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OauthAccountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OauthAccount).
func (m *OauthAccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OauthAccountMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.created_at != nil {
		fields = append(fields, oauthaccount.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, oauthaccount.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, oauthaccount.FieldStatus)
	}
	if m.tenant_id != nil {
		fields = append(fields, oauthaccount.FieldTenantID)
	}
	if m.user != nil {
		fields = append(fields, oauthaccount.FieldUserID)
	}
	if m.provider != nil {
		fields = append(fields, oauthaccount.FieldProviderID)
	}
	if m.provider_type != nil {
		fields = append(fields, oauthaccount.FieldProviderType)
	}
	if m.provider_user_id != nil {
		fields = append(fields, oauthaccount.FieldProviderUserID)
	}
	if m.provider_username != nil {
		fields = append(fields, oauthaccount.FieldProviderUsername)
	}
	if m.provider_nickname != nil {
		fields = append(fields, oauthaccount.FieldProviderNickname)
	}
	if m.provider_email != nil {
		fields = append(fields, oauthaccount.FieldProviderEmail)
	}
	if m.provider_avatar != nil {
		fields = append(fields, oauthaccount.FieldProviderAvatar)
	}
	if m.access_token != nil {
		fields = append(fields, oauthaccount.FieldAccessToken)
	}
	if m.refresh_token != nil {
		fields = append(fields, oauthaccount.FieldRefreshToken)
	}
	if m.token_expires_at != nil {
		fields = append(fields, oauthaccount.FieldTokenExpiresAt)
	}
	if m.extra_data != nil {
		fields = append(fields, oauthaccount.FieldExtraData)
	}
	if m.last_login_at != nil {
		fields = append(fields, oauthaccount.FieldLastLoginAt)
	}
	if m.last_login_ip != nil {
		fields = append(fields, oauthaccount.FieldLastLoginIP)
	}
	if m.login_count != nil {
		fields = append(fields, oauthaccount.FieldLoginCount)
	}
	if m.department_id != nil {
		fields = append(fields, oauthaccount.FieldDepartmentID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OauthAccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case oauthaccount.FieldCreatedAt:
		return m.CreatedAt()
	case oauthaccount.FieldUpdatedAt:
		return m.UpdatedAt()
	case oauthaccount.FieldStatus:
		return m.Status()
	case oauthaccount.FieldTenantID:
		return m.TenantID()
	case oauthaccount.FieldUserID:
		return m.UserID()
	case oauthaccount.FieldProviderID:
		return m.ProviderID()
	case oauthaccount.FieldProviderType:
		return m.ProviderType()
	case oauthaccount.FieldProviderUserID:
		return m.ProviderUserID()
	case oauthaccount.FieldProviderUsername:
		return m.ProviderUsername()
	case oauthaccount.FieldProviderNickname:
		return m.ProviderNickname()
	case oauthaccount.FieldProviderEmail:
		return m.ProviderEmail()
	case oauthaccount.FieldProviderAvatar:
		return m.ProviderAvatar()
	case oauthaccount.FieldAccessToken:
		return m.AccessToken()
	case oauthaccount.FieldRefreshToken:
		return m.RefreshToken()
	case oauthaccount.FieldTokenExpiresAt:
		return m.TokenExpiresAt()
	case oauthaccount.FieldExtraData:
		return m.ExtraData()
	case oauthaccount.FieldLastLoginAt:
		return m.LastLoginAt()
	case oauthaccount.FieldLastLoginIP:
		return m.LastLoginIP()
	case oauthaccount.FieldLoginCount:
		return m.LoginCount()
	case oauthaccount.FieldDepartmentID:
		return m.DepartmentID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OauthAccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case oauthaccount.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case oauthaccount.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case oauthaccount.FieldStatus:
		return m.OldStatus(ctx)
	case oauthaccount.FieldTenantID:
		return m.OldTenantID(ctx)
	case oauthaccount.FieldUserID:
		return m.OldUserID(ctx)
	case oauthaccount.FieldProviderID:
		return m.OldProviderID(ctx)
	case oauthaccount.FieldProviderType:
		return m.OldProviderType(ctx)
	case oauthaccount.FieldProviderUserID:
		return m.OldProviderUserID(ctx)
	case oauthaccount.FieldProviderUsername:
		return m.OldProviderUsername(ctx)
	case oauthaccount.FieldProviderNickname:
		return m.OldProviderNickname(ctx)
	case oauthaccount.FieldProviderEmail:
		return m.OldProviderEmail(ctx)
	case oauthaccount.FieldProviderAvatar:
		return m.OldProviderAvatar(ctx)
	case oauthaccount.FieldAccessToken:
		return m.OldAccessToken(ctx)
	case oauthaccount.FieldRefreshToken:
		return m.OldRefreshToken(ctx)
	case oauthaccount.FieldTokenExpiresAt:
		return m.OldTokenExpiresAt(ctx)
	case oauthaccount.FieldExtraData:
		return m.OldExtraData(ctx)
	case oauthaccount.FieldLastLoginAt:
		return m.OldLastLoginAt(ctx)
	case oauthaccount.FieldLastLoginIP:
		return m.OldLastLoginIP(ctx)
	case oauthaccount.FieldLoginCount:
		return m.OldLoginCount(ctx)
	case oauthaccount.FieldDepartmentID:
		return m.OldDepartmentID(ctx)
	}
	return nil, fmt.Errorf("unknown OauthAccount field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OauthAccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case oauthaccount.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case oauthaccount.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case oauthaccount.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case oauthaccount.FieldTenantID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case oauthaccount.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case oauthaccount.FieldProviderID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProviderID(v)
		return nil
	case oauthaccount.FieldProviderType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProviderType(v)
		return nil
	case oauthaccount.FieldProviderUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProviderUserID(v)
		return nil
	case oauthaccount.FieldProviderUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProviderUsername(v)
		return nil
	case oauthaccount.FieldProviderNickname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProviderNickname(v)
		return nil
	case oauthaccount.FieldProviderEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProviderEmail(v)
		return nil
	case oauthaccount.FieldProviderAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProviderAvatar(v)
		return nil
	case oauthaccount.FieldAccessToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessToken(v)
		return nil
	case oauthaccount.FieldRefreshToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefreshToken(v)
		return nil
	case oauthaccount.FieldTokenExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenExpiresAt(v)
		return nil
	case oauthaccount.FieldExtraData:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtraData(v)
		return nil
	case oauthaccount.FieldLastLoginAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLoginAt(v)
		return nil
	case oauthaccount.FieldLastLoginIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLoginIP(v)
		return nil
	case oauthaccount.FieldLoginCount:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLoginCount(v)
		return nil
	case oauthaccount.FieldDepartmentID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepartmentID(v)
		return nil
	}
	return fmt.Errorf("unknown OauthAccount field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OauthAccountMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, oauthaccount.FieldStatus)
	}
	if m.addtenant_id != nil {
		fields = append(fields, oauthaccount.FieldTenantID)
	}
	if m.addlogin_count != nil {
		fields = append(fields, oauthaccount.FieldLoginCount)
	}
	if m.adddepartment_id != nil {
		fields = append(fields, oauthaccount.FieldDepartmentID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OauthAccountMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case oauthaccount.FieldStatus:
		return m.AddedStatus()
	case oauthaccount.FieldTenantID:
		return m.AddedTenantID()
	case oauthaccount.FieldLoginCount:
		return m.AddedLoginCount()
	case oauthaccount.FieldDepartmentID:
		return m.AddedDepartmentID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OauthAccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	case oauthaccount.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case oauthaccount.FieldTenantID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case oauthaccount.FieldLoginCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLoginCount(v)
		return nil
	case oauthaccount.FieldDepartmentID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDepartmentID(v)
		return nil
	}
	return fmt.Errorf("unknown OauthAccount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OauthAccountMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(oauthaccount.FieldStatus) {
		fields = append(fields, oauthaccount.FieldStatus)
	}
	if m.FieldCleared(oauthaccount.FieldProviderUsername) {
		fields = append(fields, oauthaccount.FieldProviderUsername)
	}
	if m.FieldCleared(oauthaccount.FieldProviderNickname) {
		fields = append(fields, oauthaccount.FieldProviderNickname)
	}
	if m.FieldCleared(oauthaccount.FieldProviderEmail) {
		fields = append(fields, oauthaccount.FieldProviderEmail)
	}
	if m.FieldCleared(oauthaccount.FieldProviderAvatar) {
		fields = append(fields, oauthaccount.FieldProviderAvatar)
	}
	if m.FieldCleared(oauthaccount.FieldRefreshToken) {
		fields = append(fields, oauthaccount.FieldRefreshToken)
	}
	if m.FieldCleared(oauthaccount.FieldTokenExpiresAt) {
		fields = append(fields, oauthaccount.FieldTokenExpiresAt)
	}
	if m.FieldCleared(oauthaccount.FieldExtraData) {
		fields = append(fields, oauthaccount.FieldExtraData)
	}
	if m.FieldCleared(oauthaccount.FieldLastLoginAt) {
		fields = append(fields, oauthaccount.FieldLastLoginAt)
	}
	if m.FieldCleared(oauthaccount.FieldLastLoginIP) {
		fields = append(fields, oauthaccount.FieldLastLoginIP)
	}
	if m.FieldCleared(oauthaccount.FieldDepartmentID) {
		fields = append(fields, oauthaccount.FieldDepartmentID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OauthAccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OauthAccountMutation) ClearField(name string) error {
	switch name {
	case oauthaccount.FieldStatus:
		m.ClearStatus()
		return nil
	case oauthaccount.FieldProviderUsername:
		m.ClearProviderUsername()
		return nil
	case oauthaccount.FieldProviderNickname:
		m.ClearProviderNickname()
		return nil
	case oauthaccount.FieldProviderEmail:
		m.ClearProviderEmail()
		return nil
	case oauthaccount.FieldProviderAvatar:
		m.ClearProviderAvatar()
		return nil
	case oauthaccount.FieldRefreshToken:
		m.ClearRefreshToken()
		return nil
	case oauthaccount.FieldTokenExpiresAt:
		m.ClearTokenExpiresAt()
		return nil
	case oauthaccount.FieldExtraData:
		m.ClearExtraData()
		return nil
	case oauthaccount.FieldLastLoginAt:
		m.ClearLastLoginAt()
		return nil
	case oauthaccount.FieldLastLoginIP:
		m.ClearLastLoginIP()
		return nil
	case oauthaccount.FieldDepartmentID:
		m.ClearDepartmentID()
		return nil
	}
	return fmt.Errorf("unknown OauthAccount nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OauthAccountMutation) ResetField(name string) error {
	switch name {
	case oauthaccount.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case oauthaccount.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case oauthaccount.FieldStatus:
		m.ResetStatus()
		return nil
	case oauthaccount.FieldTenantID:
		m.ResetTenantID()
		return nil
	case oauthaccount.FieldUserID:
		m.ResetUserID()
		return nil
	case oauthaccount.FieldProviderID:
		m.ResetProviderID()
		return nil
	case oauthaccount.FieldProviderType:
		m.ResetProviderType()
		return nil
	case oauthaccount.FieldProviderUserID:
		m.ResetProviderUserID()
		return nil
	case oauthaccount.FieldProviderUsername:
		m.ResetProviderUsername()
		return nil
	case oauthaccount.FieldProviderNickname:
		m.ResetProviderNickname()
		return nil
	case oauthaccount.FieldProviderEmail:
		m.ResetProviderEmail()
		return nil
	case oauthaccount.FieldProviderAvatar:
		m.ResetProviderAvatar()
		return nil
	case oauthaccount.FieldAccessToken:
		m.ResetAccessToken()
		return nil
	case oauthaccount.FieldRefreshToken:
		m.ResetRefreshToken()
		return nil
	case oauthaccount.FieldTokenExpiresAt:
		m.ResetTokenExpiresAt()
		return nil
	case oauthaccount.FieldExtraData:
		m.ResetExtraData()
		return nil
	case oauthaccount.FieldLastLoginAt:
		m.ResetLastLoginAt()
		return nil
	case oauthaccount.FieldLastLoginIP:
		m.ResetLastLoginIP()
		return nil
	case oauthaccount.FieldLoginCount:
		m.ResetLoginCount()
		return nil
	case oauthaccount.FieldDepartmentID:
		m.ResetDepartmentID()
		return nil
	}
	return fmt.Errorf("unknown OauthAccount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OauthAccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, oauthaccount.EdgeUser)
	}
	if m.provider != nil {
		edges = append(edges, oauthaccount.EdgeProvider)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OauthAccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case oauthaccount.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case oauthaccount.EdgeProvider:
		if id := m.provider; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OauthAccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OauthAccountMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OauthAccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, oauthaccount.EdgeUser)
	}
	if m.clearedprovider {
		edges = append(edges, oauthaccount.EdgeProvider)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OauthAccountMutation) EdgeCleared(name string) bool {
	switch name {
	case oauthaccount.EdgeUser:
		return m.cleareduser
	case oauthaccount.EdgeProvider:
		return m.clearedprovider
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OauthAccountMutation) ClearEdge(name string) error {
	switch name {
	case oauthaccount.EdgeUser:
		m.ClearUser()
		return nil
	case oauthaccount.EdgeProvider:
		m.ClearProvider()
		return nil
	}
	return fmt.Errorf("unknown OauthAccount unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OauthAccountMutation) ResetEdge(name string) error {
	switch name {
	case oauthaccount.EdgeUser:
		m.ResetUser()
		return nil
	case oauthaccount.EdgeProvider:
		m.ResetProvider()
		return nil
	}
	return fmt.Errorf("unknown OauthAccount edge %s", name)
}

// OauthProviderMutation represents an operation that mutates the OauthProvider nodes in the graph.
type OauthProviderMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uint64
	created_at            *time.Time
	updated_at            *time.Time
	status                *uint8
	addstatus             *int8
	tenant_id             *uint64
	addtenant_id          *int64
	name                  *string
	display_name          *string
	_type                 *string
	provider_type         *string
	client_id             *string
	client_secret         *string
	encrypted_secret      *string
	encryption_key_id     *string
	redirect_url          *string
	scopes                *string
	auth_url              *string
	token_url             *string
	info_url              *string
	auth_style            *int
	addauth_style         *int
	extra_config          *map[string]interface{}
	enabled               *bool
	sort                  *uint32
	addsort               *int32
	remark                *string
	support_pkce          *bool
	icon_url              *string
	cache_ttl             *int
	addcache_ttl          *int
	webhook_url           *string
	success_count         *int
	addsuccess_count      *int
	failure_count         *int
	addfailure_count      *int
	last_used_at          *time.Time
	clearedFields         map[string]struct{}
	oauth_accounts        map[uint64]struct{}
	removedoauth_accounts map[uint64]struct{}
	clearedoauth_accounts bool
	oauth_sessions        map[uint64]struct{}
	removedoauth_sessions map[uint64]struct{}
	clearedoauth_sessions bool
	done                  bool
	oldValue              func(context.Context) (*OauthProvider, error)
	predicates            []predicate.OauthProvider
}

var _ ent.Mutation = (*OauthProviderMutation)(nil)

// oauthproviderOption allows management of the mutation configuration using functional options.
type oauthproviderOption func(*OauthProviderMutation)

// newOauthProviderMutation creates new mutation for the OauthProvider entity.
func newOauthProviderMutation(c config, op Op, opts ...oauthproviderOption) *OauthProviderMutation {
	m := &OauthProviderMutation{
		config:        c,
		op:            op,
		typ:           TypeOauthProvider,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOauthProviderID sets the ID field of the mutation.
func withOauthProviderID(id uint64) oauthproviderOption {
	return func(m *OauthProviderMutation) {
		var (
			err   error
			once  sync.Once
			value *OauthProvider
		)
		m.oldValue = func(ctx context.Context) (*OauthProvider, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OauthProvider.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOauthProvider sets the old OauthProvider of the mutation.
func withOauthProvider(node *OauthProvider) oauthproviderOption {
	return func(m *OauthProviderMutation) {
		m.oldValue = func(context.Context) (*OauthProvider, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OauthProviderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OauthProviderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OauthProvider entities.
func (m *OauthProviderMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OauthProviderMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OauthProviderMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OauthProvider.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OauthProviderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OauthProviderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OauthProvider entity.
// If the OauthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OauthProviderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OauthProviderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OauthProviderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OauthProvider entity.
// If the OauthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OauthProviderMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *OauthProviderMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *OauthProviderMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the OauthProvider entity.
// If the OauthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *OauthProviderMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *OauthProviderMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *OauthProviderMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[oauthprovider.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *OauthProviderMutation) StatusCleared() bool {
	_, ok := m.clearedFields[oauthprovider.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *OauthProviderMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, oauthprovider.FieldStatus)
}

// SetTenantID sets the "tenant_id" field.
func (m *OauthProviderMutation) SetTenantID(u uint64) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *OauthProviderMutation) TenantID() (r uint64, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the OauthProvider entity.
// If the OauthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderMutation) OldTenantID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *OauthProviderMutation) AddTenantID(u int64) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *OauthProviderMutation) AddedTenantID() (r int64, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *OauthProviderMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetName sets the "name" field.
func (m *OauthProviderMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OauthProviderMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the OauthProvider entity.
// If the OauthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OauthProviderMutation) ResetName() {
	m.name = nil
}

// SetDisplayName sets the "display_name" field.
func (m *OauthProviderMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *OauthProviderMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the OauthProvider entity.
// If the OauthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *OauthProviderMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[oauthprovider.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *OauthProviderMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[oauthprovider.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *OauthProviderMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, oauthprovider.FieldDisplayName)
}

// SetType sets the "type" field.
func (m *OauthProviderMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *OauthProviderMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the OauthProvider entity.
// If the OauthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *OauthProviderMutation) ResetType() {
	m._type = nil
}

// SetProviderType sets the "provider_type" field.
func (m *OauthProviderMutation) SetProviderType(s string) {
	m.provider_type = &s
}

// ProviderType returns the value of the "provider_type" field in the mutation.
func (m *OauthProviderMutation) ProviderType() (r string, exists bool) {
	v := m.provider_type
	if v == nil {
		return
	}
	return *v, true
}

// OldProviderType returns the old "provider_type" field's value of the OauthProvider entity.
// If the OauthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderMutation) OldProviderType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProviderType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProviderType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProviderType: %w", err)
	}
	return oldValue.ProviderType, nil
}

// ResetProviderType resets all changes to the "provider_type" field.
func (m *OauthProviderMutation) ResetProviderType() {
	m.provider_type = nil
}

// SetClientID sets the "client_id" field.
func (m *OauthProviderMutation) SetClientID(s string) {
	m.client_id = &s
}

// ClientID returns the value of the "client_id" field in the mutation.
func (m *OauthProviderMutation) ClientID() (r string, exists bool) {
	v := m.client_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClientID returns the old "client_id" field's value of the OauthProvider entity.
// If the OauthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderMutation) OldClientID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientID: %w", err)
	}
	return oldValue.ClientID, nil
}

// ResetClientID resets all changes to the "client_id" field.
func (m *OauthProviderMutation) ResetClientID() {
	m.client_id = nil
}

// SetClientSecret sets the "client_secret" field.
func (m *OauthProviderMutation) SetClientSecret(s string) {
	m.client_secret = &s
}

// ClientSecret returns the value of the "client_secret" field in the mutation.
func (m *OauthProviderMutation) ClientSecret() (r string, exists bool) {
	v := m.client_secret
	if v == nil {
		return
	}
	return *v, true
}

// OldClientSecret returns the old "client_secret" field's value of the OauthProvider entity.
// If the OauthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderMutation) OldClientSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientSecret: %w", err)
	}
	return oldValue.ClientSecret, nil
}

// ResetClientSecret resets all changes to the "client_secret" field.
func (m *OauthProviderMutation) ResetClientSecret() {
	m.client_secret = nil
}

// SetEncryptedSecret sets the "encrypted_secret" field.
func (m *OauthProviderMutation) SetEncryptedSecret(s string) {
	m.encrypted_secret = &s
}

// EncryptedSecret returns the value of the "encrypted_secret" field in the mutation.
func (m *OauthProviderMutation) EncryptedSecret() (r string, exists bool) {
	v := m.encrypted_secret
	if v == nil {
		return
	}
	return *v, true
}

// OldEncryptedSecret returns the old "encrypted_secret" field's value of the OauthProvider entity.
// If the OauthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderMutation) OldEncryptedSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEncryptedSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEncryptedSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEncryptedSecret: %w", err)
	}
	return oldValue.EncryptedSecret, nil
}

// ClearEncryptedSecret clears the value of the "encrypted_secret" field.
func (m *OauthProviderMutation) ClearEncryptedSecret() {
	m.encrypted_secret = nil
	m.clearedFields[oauthprovider.FieldEncryptedSecret] = struct{}{}
}

// EncryptedSecretCleared returns if the "encrypted_secret" field was cleared in this mutation.
func (m *OauthProviderMutation) EncryptedSecretCleared() bool {
	_, ok := m.clearedFields[oauthprovider.FieldEncryptedSecret]
	return ok
}

// ResetEncryptedSecret resets all changes to the "encrypted_secret" field.
func (m *OauthProviderMutation) ResetEncryptedSecret() {
	m.encrypted_secret = nil
	delete(m.clearedFields, oauthprovider.FieldEncryptedSecret)
}

// SetEncryptionKeyID sets the "encryption_key_id" field.
func (m *OauthProviderMutation) SetEncryptionKeyID(s string) {
	m.encryption_key_id = &s
}

// EncryptionKeyID returns the value of the "encryption_key_id" field in the mutation.
func (m *OauthProviderMutation) EncryptionKeyID() (r string, exists bool) {
	v := m.encryption_key_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEncryptionKeyID returns the old "encryption_key_id" field's value of the OauthProvider entity.
// If the OauthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderMutation) OldEncryptionKeyID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEncryptionKeyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEncryptionKeyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEncryptionKeyID: %w", err)
	}
	return oldValue.EncryptionKeyID, nil
}

// ClearEncryptionKeyID clears the value of the "encryption_key_id" field.
func (m *OauthProviderMutation) ClearEncryptionKeyID() {
	m.encryption_key_id = nil
	m.clearedFields[oauthprovider.FieldEncryptionKeyID] = struct{}{}
}

// EncryptionKeyIDCleared returns if the "encryption_key_id" field was cleared in this mutation.
func (m *OauthProviderMutation) EncryptionKeyIDCleared() bool {
	_, ok := m.clearedFields[oauthprovider.FieldEncryptionKeyID]
	return ok
}

// ResetEncryptionKeyID resets all changes to the "encryption_key_id" field.
func (m *OauthProviderMutation) ResetEncryptionKeyID() {
	m.encryption_key_id = nil
	delete(m.clearedFields, oauthprovider.FieldEncryptionKeyID)
}

// SetRedirectURL sets the "redirect_url" field.
func (m *OauthProviderMutation) SetRedirectURL(s string) {
	m.redirect_url = &s
}

// RedirectURL returns the value of the "redirect_url" field in the mutation.
func (m *OauthProviderMutation) RedirectURL() (r string, exists bool) {
	v := m.redirect_url
	if v == nil {
		return
	}
	return *v, true
}

// OldRedirectURL returns the old "redirect_url" field's value of the OauthProvider entity.
// If the OauthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderMutation) OldRedirectURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRedirectURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRedirectURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRedirectURL: %w", err)
	}
	return oldValue.RedirectURL, nil
}

// ResetRedirectURL resets all changes to the "redirect_url" field.
func (m *OauthProviderMutation) ResetRedirectURL() {
	m.redirect_url = nil
}

// SetScopes sets the "scopes" field.
func (m *OauthProviderMutation) SetScopes(s string) {
	m.scopes = &s
}

// Scopes returns the value of the "scopes" field in the mutation.
func (m *OauthProviderMutation) Scopes() (r string, exists bool) {
	v := m.scopes
	if v == nil {
		return
	}
	return *v, true
}

// OldScopes returns the old "scopes" field's value of the OauthProvider entity.
// If the OauthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderMutation) OldScopes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScopes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScopes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScopes: %w", err)
	}
	return oldValue.Scopes, nil
}

// ClearScopes clears the value of the "scopes" field.
func (m *OauthProviderMutation) ClearScopes() {
	m.scopes = nil
	m.clearedFields[oauthprovider.FieldScopes] = struct{}{}
}

// ScopesCleared returns if the "scopes" field was cleared in this mutation.
func (m *OauthProviderMutation) ScopesCleared() bool {
	_, ok := m.clearedFields[oauthprovider.FieldScopes]
	return ok
}

// ResetScopes resets all changes to the "scopes" field.
func (m *OauthProviderMutation) ResetScopes() {
	m.scopes = nil
	delete(m.clearedFields, oauthprovider.FieldScopes)
}

// SetAuthURL sets the "auth_url" field.
func (m *OauthProviderMutation) SetAuthURL(s string) {
	m.auth_url = &s
}

// AuthURL returns the value of the "auth_url" field in the mutation.
func (m *OauthProviderMutation) AuthURL() (r string, exists bool) {
	v := m.auth_url
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthURL returns the old "auth_url" field's value of the OauthProvider entity.
// If the OauthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderMutation) OldAuthURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthURL: %w", err)
	}
	return oldValue.AuthURL, nil
}

// ResetAuthURL resets all changes to the "auth_url" field.
func (m *OauthProviderMutation) ResetAuthURL() {
	m.auth_url = nil
}

// SetTokenURL sets the "token_url" field.
func (m *OauthProviderMutation) SetTokenURL(s string) {
	m.token_url = &s
}

// TokenURL returns the value of the "token_url" field in the mutation.
func (m *OauthProviderMutation) TokenURL() (r string, exists bool) {
	v := m.token_url
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenURL returns the old "token_url" field's value of the OauthProvider entity.
// If the OauthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderMutation) OldTokenURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenURL: %w", err)
	}
	return oldValue.TokenURL, nil
}

// ResetTokenURL resets all changes to the "token_url" field.
func (m *OauthProviderMutation) ResetTokenURL() {
	m.token_url = nil
}

// SetInfoURL sets the "info_url" field.
func (m *OauthProviderMutation) SetInfoURL(s string) {
	m.info_url = &s
}

// InfoURL returns the value of the "info_url" field in the mutation.
func (m *OauthProviderMutation) InfoURL() (r string, exists bool) {
	v := m.info_url
	if v == nil {
		return
	}
	return *v, true
}

// OldInfoURL returns the old "info_url" field's value of the OauthProvider entity.
// If the OauthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderMutation) OldInfoURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInfoURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInfoURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInfoURL: %w", err)
	}
	return oldValue.InfoURL, nil
}

// ResetInfoURL resets all changes to the "info_url" field.
func (m *OauthProviderMutation) ResetInfoURL() {
	m.info_url = nil
}

// SetAuthStyle sets the "auth_style" field.
func (m *OauthProviderMutation) SetAuthStyle(i int) {
	m.auth_style = &i
	m.addauth_style = nil
}

// AuthStyle returns the value of the "auth_style" field in the mutation.
func (m *OauthProviderMutation) AuthStyle() (r int, exists bool) {
	v := m.auth_style
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthStyle returns the old "auth_style" field's value of the OauthProvider entity.
// If the OauthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderMutation) OldAuthStyle(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthStyle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthStyle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthStyle: %w", err)
	}
	return oldValue.AuthStyle, nil
}

// AddAuthStyle adds i to the "auth_style" field.
func (m *OauthProviderMutation) AddAuthStyle(i int) {
	if m.addauth_style != nil {
		*m.addauth_style += i
	} else {
		m.addauth_style = &i
	}
}

// AddedAuthStyle returns the value that was added to the "auth_style" field in this mutation.
func (m *OauthProviderMutation) AddedAuthStyle() (r int, exists bool) {
	v := m.addauth_style
	if v == nil {
		return
	}
	return *v, true
}

// ResetAuthStyle resets all changes to the "auth_style" field.
func (m *OauthProviderMutation) ResetAuthStyle() {
	m.auth_style = nil
	m.addauth_style = nil
}

// SetExtraConfig sets the "extra_config" field.
func (m *OauthProviderMutation) SetExtraConfig(value map[string]interface{}) {
	m.extra_config = &value
}

// ExtraConfig returns the value of the "extra_config" field in the mutation.
func (m *OauthProviderMutation) ExtraConfig() (r map[string]interface{}, exists bool) {
	v := m.extra_config
	if v == nil {
		return
	}
	return *v, true
}

// OldExtraConfig returns the old "extra_config" field's value of the OauthProvider entity.
// If the OauthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderMutation) OldExtraConfig(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtraConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtraConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtraConfig: %w", err)
	}
	return oldValue.ExtraConfig, nil
}

// ClearExtraConfig clears the value of the "extra_config" field.
func (m *OauthProviderMutation) ClearExtraConfig() {
	m.extra_config = nil
	m.clearedFields[oauthprovider.FieldExtraConfig] = struct{}{}
}

// ExtraConfigCleared returns if the "extra_config" field was cleared in this mutation.
func (m *OauthProviderMutation) ExtraConfigCleared() bool {
	_, ok := m.clearedFields[oauthprovider.FieldExtraConfig]
	return ok
}

// ResetExtraConfig resets all changes to the "extra_config" field.
func (m *OauthProviderMutation) ResetExtraConfig() {
	m.extra_config = nil
	delete(m.clearedFields, oauthprovider.FieldExtraConfig)
}

// SetEnabled sets the "enabled" field.
func (m *OauthProviderMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *OauthProviderMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the OauthProvider entity.
// If the OauthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *OauthProviderMutation) ResetEnabled() {
	m.enabled = nil
}

// SetSort sets the "sort" field.
func (m *OauthProviderMutation) SetSort(u uint32) {
	m.sort = &u
	m.addsort = nil
}

// Sort returns the value of the "sort" field in the mutation.
func (m *OauthProviderMutation) Sort() (r uint32, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the OauthProvider entity.
// If the OauthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderMutation) OldSort(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// AddSort adds u to the "sort" field.
func (m *OauthProviderMutation) AddSort(u int32) {
	if m.addsort != nil {
		*m.addsort += u
	} else {
		m.addsort = &u
	}
}

// AddedSort returns the value that was added to the "sort" field in this mutation.
func (m *OauthProviderMutation) AddedSort() (r int32, exists bool) {
	v := m.addsort
	if v == nil {
		return
	}
	return *v, true
}

// ResetSort resets all changes to the "sort" field.
func (m *OauthProviderMutation) ResetSort() {
	m.sort = nil
	m.addsort = nil
}

// SetRemark sets the "remark" field.
func (m *OauthProviderMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *OauthProviderMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the OauthProvider entity.
// If the OauthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *OauthProviderMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[oauthprovider.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *OauthProviderMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[oauthprovider.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *OauthProviderMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, oauthprovider.FieldRemark)
}

// SetSupportPkce sets the "support_pkce" field.
func (m *OauthProviderMutation) SetSupportPkce(b bool) {
	m.support_pkce = &b
}

// SupportPkce returns the value of the "support_pkce" field in the mutation.
func (m *OauthProviderMutation) SupportPkce() (r bool, exists bool) {
	v := m.support_pkce
	if v == nil {
		return
	}
	return *v, true
}

// OldSupportPkce returns the old "support_pkce" field's value of the OauthProvider entity.
// If the OauthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderMutation) OldSupportPkce(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupportPkce is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupportPkce requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupportPkce: %w", err)
	}
	return oldValue.SupportPkce, nil
}

// ResetSupportPkce resets all changes to the "support_pkce" field.
func (m *OauthProviderMutation) ResetSupportPkce() {
	m.support_pkce = nil
}

// SetIconURL sets the "icon_url" field.
func (m *OauthProviderMutation) SetIconURL(s string) {
	m.icon_url = &s
}

// IconURL returns the value of the "icon_url" field in the mutation.
func (m *OauthProviderMutation) IconURL() (r string, exists bool) {
	v := m.icon_url
	if v == nil {
		return
	}
	return *v, true
}

// OldIconURL returns the old "icon_url" field's value of the OauthProvider entity.
// If the OauthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderMutation) OldIconURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIconURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIconURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIconURL: %w", err)
	}
	return oldValue.IconURL, nil
}

// ClearIconURL clears the value of the "icon_url" field.
func (m *OauthProviderMutation) ClearIconURL() {
	m.icon_url = nil
	m.clearedFields[oauthprovider.FieldIconURL] = struct{}{}
}

// IconURLCleared returns if the "icon_url" field was cleared in this mutation.
func (m *OauthProviderMutation) IconURLCleared() bool {
	_, ok := m.clearedFields[oauthprovider.FieldIconURL]
	return ok
}

// ResetIconURL resets all changes to the "icon_url" field.
func (m *OauthProviderMutation) ResetIconURL() {
	m.icon_url = nil
	delete(m.clearedFields, oauthprovider.FieldIconURL)
}

// SetCacheTTL sets the "cache_ttl" field.
func (m *OauthProviderMutation) SetCacheTTL(i int) {
	m.cache_ttl = &i
	m.addcache_ttl = nil
}

// CacheTTL returns the value of the "cache_ttl" field in the mutation.
func (m *OauthProviderMutation) CacheTTL() (r int, exists bool) {
	v := m.cache_ttl
	if v == nil {
		return
	}
	return *v, true
}

// OldCacheTTL returns the old "cache_ttl" field's value of the OauthProvider entity.
// If the OauthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderMutation) OldCacheTTL(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCacheTTL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCacheTTL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCacheTTL: %w", err)
	}
	return oldValue.CacheTTL, nil
}

// AddCacheTTL adds i to the "cache_ttl" field.
func (m *OauthProviderMutation) AddCacheTTL(i int) {
	if m.addcache_ttl != nil {
		*m.addcache_ttl += i
	} else {
		m.addcache_ttl = &i
	}
}

// AddedCacheTTL returns the value that was added to the "cache_ttl" field in this mutation.
func (m *OauthProviderMutation) AddedCacheTTL() (r int, exists bool) {
	v := m.addcache_ttl
	if v == nil {
		return
	}
	return *v, true
}

// ResetCacheTTL resets all changes to the "cache_ttl" field.
func (m *OauthProviderMutation) ResetCacheTTL() {
	m.cache_ttl = nil
	m.addcache_ttl = nil
}

// SetWebhookURL sets the "webhook_url" field.
func (m *OauthProviderMutation) SetWebhookURL(s string) {
	m.webhook_url = &s
}

// WebhookURL returns the value of the "webhook_url" field in the mutation.
func (m *OauthProviderMutation) WebhookURL() (r string, exists bool) {
	v := m.webhook_url
	if v == nil {
		return
	}
	return *v, true
}

// OldWebhookURL returns the old "webhook_url" field's value of the OauthProvider entity.
// If the OauthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderMutation) OldWebhookURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWebhookURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWebhookURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWebhookURL: %w", err)
	}
	return oldValue.WebhookURL, nil
}

// ClearWebhookURL clears the value of the "webhook_url" field.
func (m *OauthProviderMutation) ClearWebhookURL() {
	m.webhook_url = nil
	m.clearedFields[oauthprovider.FieldWebhookURL] = struct{}{}
}

// WebhookURLCleared returns if the "webhook_url" field was cleared in this mutation.
func (m *OauthProviderMutation) WebhookURLCleared() bool {
	_, ok := m.clearedFields[oauthprovider.FieldWebhookURL]
	return ok
}

// ResetWebhookURL resets all changes to the "webhook_url" field.
func (m *OauthProviderMutation) ResetWebhookURL() {
	m.webhook_url = nil
	delete(m.clearedFields, oauthprovider.FieldWebhookURL)
}

// SetSuccessCount sets the "success_count" field.
func (m *OauthProviderMutation) SetSuccessCount(i int) {
	m.success_count = &i
	m.addsuccess_count = nil
}

// SuccessCount returns the value of the "success_count" field in the mutation.
func (m *OauthProviderMutation) SuccessCount() (r int, exists bool) {
	v := m.success_count
	if v == nil {
		return
	}
	return *v, true
}

// OldSuccessCount returns the old "success_count" field's value of the OauthProvider entity.
// If the OauthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderMutation) OldSuccessCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuccessCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuccessCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuccessCount: %w", err)
	}
	return oldValue.SuccessCount, nil
}

// AddSuccessCount adds i to the "success_count" field.
func (m *OauthProviderMutation) AddSuccessCount(i int) {
	if m.addsuccess_count != nil {
		*m.addsuccess_count += i
	} else {
		m.addsuccess_count = &i
	}
}

// AddedSuccessCount returns the value that was added to the "success_count" field in this mutation.
func (m *OauthProviderMutation) AddedSuccessCount() (r int, exists bool) {
	v := m.addsuccess_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetSuccessCount resets all changes to the "success_count" field.
func (m *OauthProviderMutation) ResetSuccessCount() {
	m.success_count = nil
	m.addsuccess_count = nil
}

// SetFailureCount sets the "failure_count" field.
func (m *OauthProviderMutation) SetFailureCount(i int) {
	m.failure_count = &i
	m.addfailure_count = nil
}

// FailureCount returns the value of the "failure_count" field in the mutation.
func (m *OauthProviderMutation) FailureCount() (r int, exists bool) {
	v := m.failure_count
	if v == nil {
		return
	}
	return *v, true
}

// OldFailureCount returns the old "failure_count" field's value of the OauthProvider entity.
// If the OauthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderMutation) OldFailureCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFailureCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFailureCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFailureCount: %w", err)
	}
	return oldValue.FailureCount, nil
}

// AddFailureCount adds i to the "failure_count" field.
func (m *OauthProviderMutation) AddFailureCount(i int) {
	if m.addfailure_count != nil {
		*m.addfailure_count += i
	} else {
		m.addfailure_count = &i
	}
}

// AddedFailureCount returns the value that was added to the "failure_count" field in this mutation.
func (m *OauthProviderMutation) AddedFailureCount() (r int, exists bool) {
	v := m.addfailure_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetFailureCount resets all changes to the "failure_count" field.
func (m *OauthProviderMutation) ResetFailureCount() {
	m.failure_count = nil
	m.addfailure_count = nil
}

// SetLastUsedAt sets the "last_used_at" field.
func (m *OauthProviderMutation) SetLastUsedAt(t time.Time) {
	m.last_used_at = &t
}

// LastUsedAt returns the value of the "last_used_at" field in the mutation.
func (m *OauthProviderMutation) LastUsedAt() (r time.Time, exists bool) {
	v := m.last_used_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUsedAt returns the old "last_used_at" field's value of the OauthProvider entity.
// If the OauthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderMutation) OldLastUsedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUsedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUsedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUsedAt: %w", err)
	}
	return oldValue.LastUsedAt, nil
}

// ClearLastUsedAt clears the value of the "last_used_at" field.
func (m *OauthProviderMutation) ClearLastUsedAt() {
	m.last_used_at = nil
	m.clearedFields[oauthprovider.FieldLastUsedAt] = struct{}{}
}

// LastUsedAtCleared returns if the "last_used_at" field was cleared in this mutation.
func (m *OauthProviderMutation) LastUsedAtCleared() bool {
	_, ok := m.clearedFields[oauthprovider.FieldLastUsedAt]
	return ok
}

// ResetLastUsedAt resets all changes to the "last_used_at" field.
func (m *OauthProviderMutation) ResetLastUsedAt() {
	m.last_used_at = nil
	delete(m.clearedFields, oauthprovider.FieldLastUsedAt)
}

// AddOauthAccountIDs adds the "oauth_accounts" edge to the OauthAccount entity by ids.
func (m *OauthProviderMutation) AddOauthAccountIDs(ids ...uint64) {
	if m.oauth_accounts == nil {
		m.oauth_accounts = make(map[uint64]struct{})
	}
	for i := range ids {
		m.oauth_accounts[ids[i]] = struct{}{}
	}
}

// ClearOauthAccounts clears the "oauth_accounts" edge to the OauthAccount entity.
func (m *OauthProviderMutation) ClearOauthAccounts() {
	m.clearedoauth_accounts = true
}

// OauthAccountsCleared reports if the "oauth_accounts" edge to the OauthAccount entity was cleared.
func (m *OauthProviderMutation) OauthAccountsCleared() bool {
	return m.clearedoauth_accounts
}

// RemoveOauthAccountIDs removes the "oauth_accounts" edge to the OauthAccount entity by IDs.
func (m *OauthProviderMutation) RemoveOauthAccountIDs(ids ...uint64) {
	if m.removedoauth_accounts == nil {
		m.removedoauth_accounts = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.oauth_accounts, ids[i])
		m.removedoauth_accounts[ids[i]] = struct{}{}
	}
}

// RemovedOauthAccounts returns the removed IDs of the "oauth_accounts" edge to the OauthAccount entity.
func (m *OauthProviderMutation) RemovedOauthAccountsIDs() (ids []uint64) {
	for id := range m.removedoauth_accounts {
		ids = append(ids, id)
	}
	return
}

// OauthAccountsIDs returns the "oauth_accounts" edge IDs in the mutation.
func (m *OauthProviderMutation) OauthAccountsIDs() (ids []uint64) {
	for id := range m.oauth_accounts {
		ids = append(ids, id)
	}
	return
}

// ResetOauthAccounts resets all changes to the "oauth_accounts" edge.
func (m *OauthProviderMutation) ResetOauthAccounts() {
	m.oauth_accounts = nil
	m.clearedoauth_accounts = false
	m.removedoauth_accounts = nil
}

// AddOauthSessionIDs adds the "oauth_sessions" edge to the OauthSession entity by ids.
func (m *OauthProviderMutation) AddOauthSessionIDs(ids ...uint64) {
	if m.oauth_sessions == nil {
		m.oauth_sessions = make(map[uint64]struct{})
	}
	for i := range ids {
		m.oauth_sessions[ids[i]] = struct{}{}
	}
}

// ClearOauthSessions clears the "oauth_sessions" edge to the OauthSession entity.
func (m *OauthProviderMutation) ClearOauthSessions() {
	m.clearedoauth_sessions = true
}

// OauthSessionsCleared reports if the "oauth_sessions" edge to the OauthSession entity was cleared.
func (m *OauthProviderMutation) OauthSessionsCleared() bool {
	return m.clearedoauth_sessions
}

// RemoveOauthSessionIDs removes the "oauth_sessions" edge to the OauthSession entity by IDs.
func (m *OauthProviderMutation) RemoveOauthSessionIDs(ids ...uint64) {
	if m.removedoauth_sessions == nil {
		m.removedoauth_sessions = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.oauth_sessions, ids[i])
		m.removedoauth_sessions[ids[i]] = struct{}{}
	}
}

// RemovedOauthSessions returns the removed IDs of the "oauth_sessions" edge to the OauthSession entity.
func (m *OauthProviderMutation) RemovedOauthSessionsIDs() (ids []uint64) {
	for id := range m.removedoauth_sessions {
		ids = append(ids, id)
	}
	return
}

// OauthSessionsIDs returns the "oauth_sessions" edge IDs in the mutation.
func (m *OauthProviderMutation) OauthSessionsIDs() (ids []uint64) {
	for id := range m.oauth_sessions {
		ids = append(ids, id)
	}
	return
}

// ResetOauthSessions resets all changes to the "oauth_sessions" edge.
func (m *OauthProviderMutation) ResetOauthSessions() {
	m.oauth_sessions = nil
	m.clearedoauth_sessions = false
	m.removedoauth_sessions = nil
}

// Where appends a list predicates to the OauthProviderMutation builder.
func (m *OauthProviderMutation) Where(ps ...predicate.OauthProvider) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OauthProviderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OauthProviderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OauthProvider, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OauthProviderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OauthProviderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OauthProvider).
func (m *OauthProviderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OauthProviderMutation) Fields() []string {
	fields := make([]string, 0, 29)
	if m.created_at != nil {
		fields = append(fields, oauthprovider.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, oauthprovider.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, oauthprovider.FieldStatus)
	}
	if m.tenant_id != nil {
		fields = append(fields, oauthprovider.FieldTenantID)
	}
	if m.name != nil {
		fields = append(fields, oauthprovider.FieldName)
	}
	if m.display_name != nil {
		fields = append(fields, oauthprovider.FieldDisplayName)
	}
	if m._type != nil {
		fields = append(fields, oauthprovider.FieldType)
	}
	if m.provider_type != nil {
		fields = append(fields, oauthprovider.FieldProviderType)
	}
	if m.client_id != nil {
		fields = append(fields, oauthprovider.FieldClientID)
	}
	if m.client_secret != nil {
		fields = append(fields, oauthprovider.FieldClientSecret)
	}
	if m.encrypted_secret != nil {
		fields = append(fields, oauthprovider.FieldEncryptedSecret)
	}
	if m.encryption_key_id != nil {
		fields = append(fields, oauthprovider.FieldEncryptionKeyID)
	}
	if m.redirect_url != nil {
		fields = append(fields, oauthprovider.FieldRedirectURL)
	}
	if m.scopes != nil {
		fields = append(fields, oauthprovider.FieldScopes)
	}
	if m.auth_url != nil {
		fields = append(fields, oauthprovider.FieldAuthURL)
	}
	if m.token_url != nil {
		fields = append(fields, oauthprovider.FieldTokenURL)
	}
	if m.info_url != nil {
		fields = append(fields, oauthprovider.FieldInfoURL)
	}
	if m.auth_style != nil {
		fields = append(fields, oauthprovider.FieldAuthStyle)
	}
	if m.extra_config != nil {
		fields = append(fields, oauthprovider.FieldExtraConfig)
	}
	if m.enabled != nil {
		fields = append(fields, oauthprovider.FieldEnabled)
	}
	if m.sort != nil {
		fields = append(fields, oauthprovider.FieldSort)
	}
	if m.remark != nil {
		fields = append(fields, oauthprovider.FieldRemark)
	}
	if m.support_pkce != nil {
		fields = append(fields, oauthprovider.FieldSupportPkce)
	}
	if m.icon_url != nil {
		fields = append(fields, oauthprovider.FieldIconURL)
	}
	if m.cache_ttl != nil {
		fields = append(fields, oauthprovider.FieldCacheTTL)
	}
	if m.webhook_url != nil {
		fields = append(fields, oauthprovider.FieldWebhookURL)
	}
	if m.success_count != nil {
		fields = append(fields, oauthprovider.FieldSuccessCount)
	}
	if m.failure_count != nil {
		fields = append(fields, oauthprovider.FieldFailureCount)
	}
	if m.last_used_at != nil {
		fields = append(fields, oauthprovider.FieldLastUsedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OauthProviderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case oauthprovider.FieldCreatedAt:
		return m.CreatedAt()
	case oauthprovider.FieldUpdatedAt:
		return m.UpdatedAt()
	case oauthprovider.FieldStatus:
		return m.Status()
	case oauthprovider.FieldTenantID:
		return m.TenantID()
	case oauthprovider.FieldName:
		return m.Name()
	case oauthprovider.FieldDisplayName:
		return m.DisplayName()
	case oauthprovider.FieldType:
		return m.GetType()
	case oauthprovider.FieldProviderType:
		return m.ProviderType()
	case oauthprovider.FieldClientID:
		return m.ClientID()
	case oauthprovider.FieldClientSecret:
		return m.ClientSecret()
	case oauthprovider.FieldEncryptedSecret:
		return m.EncryptedSecret()
	case oauthprovider.FieldEncryptionKeyID:
		return m.EncryptionKeyID()
	case oauthprovider.FieldRedirectURL:
		return m.RedirectURL()
	case oauthprovider.FieldScopes:
		return m.Scopes()
	case oauthprovider.FieldAuthURL:
		return m.AuthURL()
	case oauthprovider.FieldTokenURL:
		return m.TokenURL()
	case oauthprovider.FieldInfoURL:
		return m.InfoURL()
	case oauthprovider.FieldAuthStyle:
		return m.AuthStyle()
	case oauthprovider.FieldExtraConfig:
		return m.ExtraConfig()
	case oauthprovider.FieldEnabled:
		return m.Enabled()
	case oauthprovider.FieldSort:
		return m.Sort()
	case oauthprovider.FieldRemark:
		return m.Remark()
	case oauthprovider.FieldSupportPkce:
		return m.SupportPkce()
	case oauthprovider.FieldIconURL:
		return m.IconURL()
	case oauthprovider.FieldCacheTTL:
		return m.CacheTTL()
	case oauthprovider.FieldWebhookURL:
		return m.WebhookURL()
	case oauthprovider.FieldSuccessCount:
		return m.SuccessCount()
	case oauthprovider.FieldFailureCount:
		return m.FailureCount()
	case oauthprovider.FieldLastUsedAt:
		return m.LastUsedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OauthProviderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case oauthprovider.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case oauthprovider.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case oauthprovider.FieldStatus:
		return m.OldStatus(ctx)
	case oauthprovider.FieldTenantID:
		return m.OldTenantID(ctx)
	case oauthprovider.FieldName:
		return m.OldName(ctx)
	case oauthprovider.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case oauthprovider.FieldType:
		return m.OldType(ctx)
	case oauthprovider.FieldProviderType:
		return m.OldProviderType(ctx)
	case oauthprovider.FieldClientID:
		return m.OldClientID(ctx)
	case oauthprovider.FieldClientSecret:
		return m.OldClientSecret(ctx)
	case oauthprovider.FieldEncryptedSecret:
		return m.OldEncryptedSecret(ctx)
	case oauthprovider.FieldEncryptionKeyID:
		return m.OldEncryptionKeyID(ctx)
	case oauthprovider.FieldRedirectURL:
		return m.OldRedirectURL(ctx)
	case oauthprovider.FieldScopes:
		return m.OldScopes(ctx)
	case oauthprovider.FieldAuthURL:
		return m.OldAuthURL(ctx)
	case oauthprovider.FieldTokenURL:
		return m.OldTokenURL(ctx)
	case oauthprovider.FieldInfoURL:
		return m.OldInfoURL(ctx)
	case oauthprovider.FieldAuthStyle:
		return m.OldAuthStyle(ctx)
	case oauthprovider.FieldExtraConfig:
		return m.OldExtraConfig(ctx)
	case oauthprovider.FieldEnabled:
		return m.OldEnabled(ctx)
	case oauthprovider.FieldSort:
		return m.OldSort(ctx)
	case oauthprovider.FieldRemark:
		return m.OldRemark(ctx)
	case oauthprovider.FieldSupportPkce:
		return m.OldSupportPkce(ctx)
	case oauthprovider.FieldIconURL:
		return m.OldIconURL(ctx)
	case oauthprovider.FieldCacheTTL:
		return m.OldCacheTTL(ctx)
	case oauthprovider.FieldWebhookURL:
		return m.OldWebhookURL(ctx)
	case oauthprovider.FieldSuccessCount:
		return m.OldSuccessCount(ctx)
	case oauthprovider.FieldFailureCount:
		return m.OldFailureCount(ctx)
	case oauthprovider.FieldLastUsedAt:
		return m.OldLastUsedAt(ctx)
	}
	return nil, fmt.Errorf("unknown OauthProvider field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OauthProviderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case oauthprovider.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case oauthprovider.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case oauthprovider.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case oauthprovider.FieldTenantID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case oauthprovider.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case oauthprovider.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case oauthprovider.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case oauthprovider.FieldProviderType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProviderType(v)
		return nil
	case oauthprovider.FieldClientID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientID(v)
		return nil
	case oauthprovider.FieldClientSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientSecret(v)
		return nil
	case oauthprovider.FieldEncryptedSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEncryptedSecret(v)
		return nil
	case oauthprovider.FieldEncryptionKeyID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEncryptionKeyID(v)
		return nil
	case oauthprovider.FieldRedirectURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRedirectURL(v)
		return nil
	case oauthprovider.FieldScopes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScopes(v)
		return nil
	case oauthprovider.FieldAuthURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthURL(v)
		return nil
	case oauthprovider.FieldTokenURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenURL(v)
		return nil
	case oauthprovider.FieldInfoURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInfoURL(v)
		return nil
	case oauthprovider.FieldAuthStyle:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthStyle(v)
		return nil
	case oauthprovider.FieldExtraConfig:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtraConfig(v)
		return nil
	case oauthprovider.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case oauthprovider.FieldSort:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	case oauthprovider.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case oauthprovider.FieldSupportPkce:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupportPkce(v)
		return nil
	case oauthprovider.FieldIconURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIconURL(v)
		return nil
	case oauthprovider.FieldCacheTTL:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCacheTTL(v)
		return nil
	case oauthprovider.FieldWebhookURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWebhookURL(v)
		return nil
	case oauthprovider.FieldSuccessCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuccessCount(v)
		return nil
	case oauthprovider.FieldFailureCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFailureCount(v)
		return nil
	case oauthprovider.FieldLastUsedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUsedAt(v)
		return nil
	}
	return fmt.Errorf("unknown OauthProvider field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OauthProviderMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, oauthprovider.FieldStatus)
	}
	if m.addtenant_id != nil {
		fields = append(fields, oauthprovider.FieldTenantID)
	}
	if m.addauth_style != nil {
		fields = append(fields, oauthprovider.FieldAuthStyle)
	}
	if m.addsort != nil {
		fields = append(fields, oauthprovider.FieldSort)
	}
	if m.addcache_ttl != nil {
		fields = append(fields, oauthprovider.FieldCacheTTL)
	}
	if m.addsuccess_count != nil {
		fields = append(fields, oauthprovider.FieldSuccessCount)
	}
	if m.addfailure_count != nil {
		fields = append(fields, oauthprovider.FieldFailureCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OauthProviderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case oauthprovider.FieldStatus:
		return m.AddedStatus()
	case oauthprovider.FieldTenantID:
		return m.AddedTenantID()
	case oauthprovider.FieldAuthStyle:
		return m.AddedAuthStyle()
	case oauthprovider.FieldSort:
		return m.AddedSort()
	case oauthprovider.FieldCacheTTL:
		return m.AddedCacheTTL()
	case oauthprovider.FieldSuccessCount:
		return m.AddedSuccessCount()
	case oauthprovider.FieldFailureCount:
		return m.AddedFailureCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OauthProviderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case oauthprovider.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case oauthprovider.FieldTenantID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case oauthprovider.FieldAuthStyle:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAuthStyle(v)
		return nil
	case oauthprovider.FieldSort:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSort(v)
		return nil
	case oauthprovider.FieldCacheTTL:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCacheTTL(v)
		return nil
	case oauthprovider.FieldSuccessCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSuccessCount(v)
		return nil
	case oauthprovider.FieldFailureCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFailureCount(v)
		return nil
	}
	return fmt.Errorf("unknown OauthProvider numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OauthProviderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(oauthprovider.FieldStatus) {
		fields = append(fields, oauthprovider.FieldStatus)
	}
	if m.FieldCleared(oauthprovider.FieldDisplayName) {
		fields = append(fields, oauthprovider.FieldDisplayName)
	}
	if m.FieldCleared(oauthprovider.FieldEncryptedSecret) {
		fields = append(fields, oauthprovider.FieldEncryptedSecret)
	}
	if m.FieldCleared(oauthprovider.FieldEncryptionKeyID) {
		fields = append(fields, oauthprovider.FieldEncryptionKeyID)
	}
	if m.FieldCleared(oauthprovider.FieldScopes) {
		fields = append(fields, oauthprovider.FieldScopes)
	}
	if m.FieldCleared(oauthprovider.FieldExtraConfig) {
		fields = append(fields, oauthprovider.FieldExtraConfig)
	}
	if m.FieldCleared(oauthprovider.FieldRemark) {
		fields = append(fields, oauthprovider.FieldRemark)
	}
	if m.FieldCleared(oauthprovider.FieldIconURL) {
		fields = append(fields, oauthprovider.FieldIconURL)
	}
	if m.FieldCleared(oauthprovider.FieldWebhookURL) {
		fields = append(fields, oauthprovider.FieldWebhookURL)
	}
	if m.FieldCleared(oauthprovider.FieldLastUsedAt) {
		fields = append(fields, oauthprovider.FieldLastUsedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OauthProviderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OauthProviderMutation) ClearField(name string) error {
	switch name {
	case oauthprovider.FieldStatus:
		m.ClearStatus()
		return nil
	case oauthprovider.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case oauthprovider.FieldEncryptedSecret:
		m.ClearEncryptedSecret()
		return nil
	case oauthprovider.FieldEncryptionKeyID:
		m.ClearEncryptionKeyID()
		return nil
	case oauthprovider.FieldScopes:
		m.ClearScopes()
		return nil
	case oauthprovider.FieldExtraConfig:
		m.ClearExtraConfig()
		return nil
	case oauthprovider.FieldRemark:
		m.ClearRemark()
		return nil
	case oauthprovider.FieldIconURL:
		m.ClearIconURL()
		return nil
	case oauthprovider.FieldWebhookURL:
		m.ClearWebhookURL()
		return nil
	case oauthprovider.FieldLastUsedAt:
		m.ClearLastUsedAt()
		return nil
	}
	return fmt.Errorf("unknown OauthProvider nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OauthProviderMutation) ResetField(name string) error {
	switch name {
	case oauthprovider.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case oauthprovider.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case oauthprovider.FieldStatus:
		m.ResetStatus()
		return nil
	case oauthprovider.FieldTenantID:
		m.ResetTenantID()
		return nil
	case oauthprovider.FieldName:
		m.ResetName()
		return nil
	case oauthprovider.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case oauthprovider.FieldType:
		m.ResetType()
		return nil
	case oauthprovider.FieldProviderType:
		m.ResetProviderType()
		return nil
	case oauthprovider.FieldClientID:
		m.ResetClientID()
		return nil
	case oauthprovider.FieldClientSecret:
		m.ResetClientSecret()
		return nil
	case oauthprovider.FieldEncryptedSecret:
		m.ResetEncryptedSecret()
		return nil
	case oauthprovider.FieldEncryptionKeyID:
		m.ResetEncryptionKeyID()
		return nil
	case oauthprovider.FieldRedirectURL:
		m.ResetRedirectURL()
		return nil
	case oauthprovider.FieldScopes:
		m.ResetScopes()
		return nil
	case oauthprovider.FieldAuthURL:
		m.ResetAuthURL()
		return nil
	case oauthprovider.FieldTokenURL:
		m.ResetTokenURL()
		return nil
	case oauthprovider.FieldInfoURL:
		m.ResetInfoURL()
		return nil
	case oauthprovider.FieldAuthStyle:
		m.ResetAuthStyle()
		return nil
	case oauthprovider.FieldExtraConfig:
		m.ResetExtraConfig()
		return nil
	case oauthprovider.FieldEnabled:
		m.ResetEnabled()
		return nil
	case oauthprovider.FieldSort:
		m.ResetSort()
		return nil
	case oauthprovider.FieldRemark:
		m.ResetRemark()
		return nil
	case oauthprovider.FieldSupportPkce:
		m.ResetSupportPkce()
		return nil
	case oauthprovider.FieldIconURL:
		m.ResetIconURL()
		return nil
	case oauthprovider.FieldCacheTTL:
		m.ResetCacheTTL()
		return nil
	case oauthprovider.FieldWebhookURL:
		m.ResetWebhookURL()
		return nil
	case oauthprovider.FieldSuccessCount:
		m.ResetSuccessCount()
		return nil
	case oauthprovider.FieldFailureCount:
		m.ResetFailureCount()
		return nil
	case oauthprovider.FieldLastUsedAt:
		m.ResetLastUsedAt()
		return nil
	}
	return fmt.Errorf("unknown OauthProvider field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OauthProviderMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.oauth_accounts != nil {
		edges = append(edges, oauthprovider.EdgeOauthAccounts)
	}
	if m.oauth_sessions != nil {
		edges = append(edges, oauthprovider.EdgeOauthSessions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OauthProviderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case oauthprovider.EdgeOauthAccounts:
		ids := make([]ent.Value, 0, len(m.oauth_accounts))
		for id := range m.oauth_accounts {
			ids = append(ids, id)
		}
		return ids
	case oauthprovider.EdgeOauthSessions:
		ids := make([]ent.Value, 0, len(m.oauth_sessions))
		for id := range m.oauth_sessions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OauthProviderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedoauth_accounts != nil {
		edges = append(edges, oauthprovider.EdgeOauthAccounts)
	}
	if m.removedoauth_sessions != nil {
		edges = append(edges, oauthprovider.EdgeOauthSessions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OauthProviderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case oauthprovider.EdgeOauthAccounts:
		ids := make([]ent.Value, 0, len(m.removedoauth_accounts))
		for id := range m.removedoauth_accounts {
			ids = append(ids, id)
		}
		return ids
	case oauthprovider.EdgeOauthSessions:
		ids := make([]ent.Value, 0, len(m.removedoauth_sessions))
		for id := range m.removedoauth_sessions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OauthProviderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedoauth_accounts {
		edges = append(edges, oauthprovider.EdgeOauthAccounts)
	}
	if m.clearedoauth_sessions {
		edges = append(edges, oauthprovider.EdgeOauthSessions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OauthProviderMutation) EdgeCleared(name string) bool {
	switch name {
	case oauthprovider.EdgeOauthAccounts:
		return m.clearedoauth_accounts
	case oauthprovider.EdgeOauthSessions:
		return m.clearedoauth_sessions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OauthProviderMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown OauthProvider unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OauthProviderMutation) ResetEdge(name string) error {
	switch name {
	case oauthprovider.EdgeOauthAccounts:
		m.ResetOauthAccounts()
		return nil
	case oauthprovider.EdgeOauthSessions:
		m.ResetOauthSessions()
		return nil
	}
	return fmt.Errorf("unknown OauthProvider edge %s", name)
}

// OauthSessionMutation represents an operation that mutates the OauthSession nodes in the graph.
type OauthSessionMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uint64
	created_at            *time.Time
	updated_at            *time.Time
	status                *uint8
	addstatus             *int8
	tenant_id             *uint64
	addtenant_id          *int64
	session_id            *string
	state                 *string
	redirect_uri          *string
	scope                 *string
	code_challenge        *string
	code_challenge_method *string
	code_verifier         *string
	expires_at            *time.Time
	client_ip             *string
	user_agent            *string
	authorization_code    *string
	code_received_at      *time.Time
	callback_data         *map[string]interface{}
	error_code            *string
	error_description     *string
	retry_count           *int
	addretry_count        *int
	department_id         *uint64
	adddepartment_id      *int64
	clearedFields         map[string]struct{}
	provider              *uint64
	clearedprovider       bool
	user                  *uuid.UUID
	cleareduser           bool
	done                  bool
	oldValue              func(context.Context) (*OauthSession, error)
	predicates            []predicate.OauthSession
}

var _ ent.Mutation = (*OauthSessionMutation)(nil)

// oauthsessionOption allows management of the mutation configuration using functional options.
type oauthsessionOption func(*OauthSessionMutation)

// newOauthSessionMutation creates new mutation for the OauthSession entity.
func newOauthSessionMutation(c config, op Op, opts ...oauthsessionOption) *OauthSessionMutation {
	m := &OauthSessionMutation{
		config:        c,
		op:            op,
		typ:           TypeOauthSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOauthSessionID sets the ID field of the mutation.
func withOauthSessionID(id uint64) oauthsessionOption {
	return func(m *OauthSessionMutation) {
		var (
			err   error
			once  sync.Once
			value *OauthSession
		)
		m.oldValue = func(ctx context.Context) (*OauthSession, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OauthSession.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOauthSession sets the old OauthSession of the mutation.
func withOauthSession(node *OauthSession) oauthsessionOption {
	return func(m *OauthSessionMutation) {
		m.oldValue = func(context.Context) (*OauthSession, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OauthSessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OauthSessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OauthSession entities.
func (m *OauthSessionMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OauthSessionMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OauthSessionMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OauthSession.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OauthSessionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OauthSessionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OauthSession entity.
// If the OauthSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthSessionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OauthSessionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OauthSessionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OauthSessionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OauthSession entity.
// If the OauthSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthSessionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OauthSessionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *OauthSessionMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *OauthSessionMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the OauthSession entity.
// If the OauthSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthSessionMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *OauthSessionMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *OauthSessionMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *OauthSessionMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[oauthsession.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *OauthSessionMutation) StatusCleared() bool {
	_, ok := m.clearedFields[oauthsession.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *OauthSessionMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, oauthsession.FieldStatus)
}

// SetTenantID sets the "tenant_id" field.
func (m *OauthSessionMutation) SetTenantID(u uint64) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *OauthSessionMutation) TenantID() (r uint64, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the OauthSession entity.
// If the OauthSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthSessionMutation) OldTenantID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *OauthSessionMutation) AddTenantID(u int64) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *OauthSessionMutation) AddedTenantID() (r int64, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *OauthSessionMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetSessionID sets the "session_id" field.
func (m *OauthSessionMutation) SetSessionID(s string) {
	m.session_id = &s
}

// SessionID returns the value of the "session_id" field in the mutation.
func (m *OauthSessionMutation) SessionID() (r string, exists bool) {
	v := m.session_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionID returns the old "session_id" field's value of the OauthSession entity.
// If the OauthSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthSessionMutation) OldSessionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSessionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSessionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionID: %w", err)
	}
	return oldValue.SessionID, nil
}

// ResetSessionID resets all changes to the "session_id" field.
func (m *OauthSessionMutation) ResetSessionID() {
	m.session_id = nil
}

// SetState sets the "state" field.
func (m *OauthSessionMutation) SetState(s string) {
	m.state = &s
}

// State returns the value of the "state" field in the mutation.
func (m *OauthSessionMutation) State() (r string, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the OauthSession entity.
// If the OauthSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthSessionMutation) OldState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *OauthSessionMutation) ResetState() {
	m.state = nil
}

// SetProviderID sets the "provider_id" field.
func (m *OauthSessionMutation) SetProviderID(u uint64) {
	m.provider = &u
}

// ProviderID returns the value of the "provider_id" field in the mutation.
func (m *OauthSessionMutation) ProviderID() (r uint64, exists bool) {
	v := m.provider
	if v == nil {
		return
	}
	return *v, true
}

// OldProviderID returns the old "provider_id" field's value of the OauthSession entity.
// If the OauthSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthSessionMutation) OldProviderID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProviderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProviderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProviderID: %w", err)
	}
	return oldValue.ProviderID, nil
}

// ResetProviderID resets all changes to the "provider_id" field.
func (m *OauthSessionMutation) ResetProviderID() {
	m.provider = nil
}

// SetUserID sets the "user_id" field.
func (m *OauthSessionMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *OauthSessionMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the OauthSession entity.
// If the OauthSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthSessionMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *OauthSessionMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[oauthsession.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *OauthSessionMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[oauthsession.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *OauthSessionMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, oauthsession.FieldUserID)
}

// SetRedirectURI sets the "redirect_uri" field.
func (m *OauthSessionMutation) SetRedirectURI(s string) {
	m.redirect_uri = &s
}

// RedirectURI returns the value of the "redirect_uri" field in the mutation.
func (m *OauthSessionMutation) RedirectURI() (r string, exists bool) {
	v := m.redirect_uri
	if v == nil {
		return
	}
	return *v, true
}

// OldRedirectURI returns the old "redirect_uri" field's value of the OauthSession entity.
// If the OauthSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthSessionMutation) OldRedirectURI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRedirectURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRedirectURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRedirectURI: %w", err)
	}
	return oldValue.RedirectURI, nil
}

// ResetRedirectURI resets all changes to the "redirect_uri" field.
func (m *OauthSessionMutation) ResetRedirectURI() {
	m.redirect_uri = nil
}

// SetScope sets the "scope" field.
func (m *OauthSessionMutation) SetScope(s string) {
	m.scope = &s
}

// Scope returns the value of the "scope" field in the mutation.
func (m *OauthSessionMutation) Scope() (r string, exists bool) {
	v := m.scope
	if v == nil {
		return
	}
	return *v, true
}

// OldScope returns the old "scope" field's value of the OauthSession entity.
// If the OauthSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthSessionMutation) OldScope(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScope is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScope requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScope: %w", err)
	}
	return oldValue.Scope, nil
}

// ClearScope clears the value of the "scope" field.
func (m *OauthSessionMutation) ClearScope() {
	m.scope = nil
	m.clearedFields[oauthsession.FieldScope] = struct{}{}
}

// ScopeCleared returns if the "scope" field was cleared in this mutation.
func (m *OauthSessionMutation) ScopeCleared() bool {
	_, ok := m.clearedFields[oauthsession.FieldScope]
	return ok
}

// ResetScope resets all changes to the "scope" field.
func (m *OauthSessionMutation) ResetScope() {
	m.scope = nil
	delete(m.clearedFields, oauthsession.FieldScope)
}

// SetCodeChallenge sets the "code_challenge" field.
func (m *OauthSessionMutation) SetCodeChallenge(s string) {
	m.code_challenge = &s
}

// CodeChallenge returns the value of the "code_challenge" field in the mutation.
func (m *OauthSessionMutation) CodeChallenge() (r string, exists bool) {
	v := m.code_challenge
	if v == nil {
		return
	}
	return *v, true
}

// OldCodeChallenge returns the old "code_challenge" field's value of the OauthSession entity.
// If the OauthSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthSessionMutation) OldCodeChallenge(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCodeChallenge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCodeChallenge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCodeChallenge: %w", err)
	}
	return oldValue.CodeChallenge, nil
}

// ClearCodeChallenge clears the value of the "code_challenge" field.
func (m *OauthSessionMutation) ClearCodeChallenge() {
	m.code_challenge = nil
	m.clearedFields[oauthsession.FieldCodeChallenge] = struct{}{}
}

// CodeChallengeCleared returns if the "code_challenge" field was cleared in this mutation.
func (m *OauthSessionMutation) CodeChallengeCleared() bool {
	_, ok := m.clearedFields[oauthsession.FieldCodeChallenge]
	return ok
}

// ResetCodeChallenge resets all changes to the "code_challenge" field.
func (m *OauthSessionMutation) ResetCodeChallenge() {
	m.code_challenge = nil
	delete(m.clearedFields, oauthsession.FieldCodeChallenge)
}

// SetCodeChallengeMethod sets the "code_challenge_method" field.
func (m *OauthSessionMutation) SetCodeChallengeMethod(s string) {
	m.code_challenge_method = &s
}

// CodeChallengeMethod returns the value of the "code_challenge_method" field in the mutation.
func (m *OauthSessionMutation) CodeChallengeMethod() (r string, exists bool) {
	v := m.code_challenge_method
	if v == nil {
		return
	}
	return *v, true
}

// OldCodeChallengeMethod returns the old "code_challenge_method" field's value of the OauthSession entity.
// If the OauthSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthSessionMutation) OldCodeChallengeMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCodeChallengeMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCodeChallengeMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCodeChallengeMethod: %w", err)
	}
	return oldValue.CodeChallengeMethod, nil
}

// ClearCodeChallengeMethod clears the value of the "code_challenge_method" field.
func (m *OauthSessionMutation) ClearCodeChallengeMethod() {
	m.code_challenge_method = nil
	m.clearedFields[oauthsession.FieldCodeChallengeMethod] = struct{}{}
}

// CodeChallengeMethodCleared returns if the "code_challenge_method" field was cleared in this mutation.
func (m *OauthSessionMutation) CodeChallengeMethodCleared() bool {
	_, ok := m.clearedFields[oauthsession.FieldCodeChallengeMethod]
	return ok
}

// ResetCodeChallengeMethod resets all changes to the "code_challenge_method" field.
func (m *OauthSessionMutation) ResetCodeChallengeMethod() {
	m.code_challenge_method = nil
	delete(m.clearedFields, oauthsession.FieldCodeChallengeMethod)
}

// SetCodeVerifier sets the "code_verifier" field.
func (m *OauthSessionMutation) SetCodeVerifier(s string) {
	m.code_verifier = &s
}

// CodeVerifier returns the value of the "code_verifier" field in the mutation.
func (m *OauthSessionMutation) CodeVerifier() (r string, exists bool) {
	v := m.code_verifier
	if v == nil {
		return
	}
	return *v, true
}

// OldCodeVerifier returns the old "code_verifier" field's value of the OauthSession entity.
// If the OauthSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthSessionMutation) OldCodeVerifier(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCodeVerifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCodeVerifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCodeVerifier: %w", err)
	}
	return oldValue.CodeVerifier, nil
}

// ClearCodeVerifier clears the value of the "code_verifier" field.
func (m *OauthSessionMutation) ClearCodeVerifier() {
	m.code_verifier = nil
	m.clearedFields[oauthsession.FieldCodeVerifier] = struct{}{}
}

// CodeVerifierCleared returns if the "code_verifier" field was cleared in this mutation.
func (m *OauthSessionMutation) CodeVerifierCleared() bool {
	_, ok := m.clearedFields[oauthsession.FieldCodeVerifier]
	return ok
}

// ResetCodeVerifier resets all changes to the "code_verifier" field.
func (m *OauthSessionMutation) ResetCodeVerifier() {
	m.code_verifier = nil
	delete(m.clearedFields, oauthsession.FieldCodeVerifier)
}

// SetExpiresAt sets the "expires_at" field.
func (m *OauthSessionMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *OauthSessionMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the OauthSession entity.
// If the OauthSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthSessionMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *OauthSessionMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetClientIP sets the "client_ip" field.
func (m *OauthSessionMutation) SetClientIP(s string) {
	m.client_ip = &s
}

// ClientIP returns the value of the "client_ip" field in the mutation.
func (m *OauthSessionMutation) ClientIP() (r string, exists bool) {
	v := m.client_ip
	if v == nil {
		return
	}
	return *v, true
}

// OldClientIP returns the old "client_ip" field's value of the OauthSession entity.
// If the OauthSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthSessionMutation) OldClientIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientIP: %w", err)
	}
	return oldValue.ClientIP, nil
}

// ClearClientIP clears the value of the "client_ip" field.
func (m *OauthSessionMutation) ClearClientIP() {
	m.client_ip = nil
	m.clearedFields[oauthsession.FieldClientIP] = struct{}{}
}

// ClientIPCleared returns if the "client_ip" field was cleared in this mutation.
func (m *OauthSessionMutation) ClientIPCleared() bool {
	_, ok := m.clearedFields[oauthsession.FieldClientIP]
	return ok
}

// ResetClientIP resets all changes to the "client_ip" field.
func (m *OauthSessionMutation) ResetClientIP() {
	m.client_ip = nil
	delete(m.clearedFields, oauthsession.FieldClientIP)
}

// SetUserAgent sets the "user_agent" field.
func (m *OauthSessionMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *OauthSessionMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the OauthSession entity.
// If the OauthSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthSessionMutation) OldUserAgent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "user_agent" field.
func (m *OauthSessionMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[oauthsession.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "user_agent" field was cleared in this mutation.
func (m *OauthSessionMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[oauthsession.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *OauthSessionMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, oauthsession.FieldUserAgent)
}

// SetAuthorizationCode sets the "authorization_code" field.
func (m *OauthSessionMutation) SetAuthorizationCode(s string) {
	m.authorization_code = &s
}

// AuthorizationCode returns the value of the "authorization_code" field in the mutation.
func (m *OauthSessionMutation) AuthorizationCode() (r string, exists bool) {
	v := m.authorization_code
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthorizationCode returns the old "authorization_code" field's value of the OauthSession entity.
// If the OauthSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthSessionMutation) OldAuthorizationCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthorizationCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthorizationCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthorizationCode: %w", err)
	}
	return oldValue.AuthorizationCode, nil
}

// ClearAuthorizationCode clears the value of the "authorization_code" field.
func (m *OauthSessionMutation) ClearAuthorizationCode() {
	m.authorization_code = nil
	m.clearedFields[oauthsession.FieldAuthorizationCode] = struct{}{}
}

// AuthorizationCodeCleared returns if the "authorization_code" field was cleared in this mutation.
func (m *OauthSessionMutation) AuthorizationCodeCleared() bool {
	_, ok := m.clearedFields[oauthsession.FieldAuthorizationCode]
	return ok
}

// ResetAuthorizationCode resets all changes to the "authorization_code" field.
func (m *OauthSessionMutation) ResetAuthorizationCode() {
	m.authorization_code = nil
	delete(m.clearedFields, oauthsession.FieldAuthorizationCode)
}

// SetCodeReceivedAt sets the "code_received_at" field.
func (m *OauthSessionMutation) SetCodeReceivedAt(t time.Time) {
	m.code_received_at = &t
}

// CodeReceivedAt returns the value of the "code_received_at" field in the mutation.
func (m *OauthSessionMutation) CodeReceivedAt() (r time.Time, exists bool) {
	v := m.code_received_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCodeReceivedAt returns the old "code_received_at" field's value of the OauthSession entity.
// If the OauthSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthSessionMutation) OldCodeReceivedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCodeReceivedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCodeReceivedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCodeReceivedAt: %w", err)
	}
	return oldValue.CodeReceivedAt, nil
}

// ClearCodeReceivedAt clears the value of the "code_received_at" field.
func (m *OauthSessionMutation) ClearCodeReceivedAt() {
	m.code_received_at = nil
	m.clearedFields[oauthsession.FieldCodeReceivedAt] = struct{}{}
}

// CodeReceivedAtCleared returns if the "code_received_at" field was cleared in this mutation.
func (m *OauthSessionMutation) CodeReceivedAtCleared() bool {
	_, ok := m.clearedFields[oauthsession.FieldCodeReceivedAt]
	return ok
}

// ResetCodeReceivedAt resets all changes to the "code_received_at" field.
func (m *OauthSessionMutation) ResetCodeReceivedAt() {
	m.code_received_at = nil
	delete(m.clearedFields, oauthsession.FieldCodeReceivedAt)
}

// SetCallbackData sets the "callback_data" field.
func (m *OauthSessionMutation) SetCallbackData(value map[string]interface{}) {
	m.callback_data = &value
}

// CallbackData returns the value of the "callback_data" field in the mutation.
func (m *OauthSessionMutation) CallbackData() (r map[string]interface{}, exists bool) {
	v := m.callback_data
	if v == nil {
		return
	}
	return *v, true
}

// OldCallbackData returns the old "callback_data" field's value of the OauthSession entity.
// If the OauthSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthSessionMutation) OldCallbackData(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCallbackData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCallbackData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCallbackData: %w", err)
	}
	return oldValue.CallbackData, nil
}

// ClearCallbackData clears the value of the "callback_data" field.
func (m *OauthSessionMutation) ClearCallbackData() {
	m.callback_data = nil
	m.clearedFields[oauthsession.FieldCallbackData] = struct{}{}
}

// CallbackDataCleared returns if the "callback_data" field was cleared in this mutation.
func (m *OauthSessionMutation) CallbackDataCleared() bool {
	_, ok := m.clearedFields[oauthsession.FieldCallbackData]
	return ok
}

// ResetCallbackData resets all changes to the "callback_data" field.
func (m *OauthSessionMutation) ResetCallbackData() {
	m.callback_data = nil
	delete(m.clearedFields, oauthsession.FieldCallbackData)
}

// SetErrorCode sets the "error_code" field.
func (m *OauthSessionMutation) SetErrorCode(s string) {
	m.error_code = &s
}

// ErrorCode returns the value of the "error_code" field in the mutation.
func (m *OauthSessionMutation) ErrorCode() (r string, exists bool) {
	v := m.error_code
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorCode returns the old "error_code" field's value of the OauthSession entity.
// If the OauthSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthSessionMutation) OldErrorCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorCode: %w", err)
	}
	return oldValue.ErrorCode, nil
}

// ClearErrorCode clears the value of the "error_code" field.
func (m *OauthSessionMutation) ClearErrorCode() {
	m.error_code = nil
	m.clearedFields[oauthsession.FieldErrorCode] = struct{}{}
}

// ErrorCodeCleared returns if the "error_code" field was cleared in this mutation.
func (m *OauthSessionMutation) ErrorCodeCleared() bool {
	_, ok := m.clearedFields[oauthsession.FieldErrorCode]
	return ok
}

// ResetErrorCode resets all changes to the "error_code" field.
func (m *OauthSessionMutation) ResetErrorCode() {
	m.error_code = nil
	delete(m.clearedFields, oauthsession.FieldErrorCode)
}

// SetErrorDescription sets the "error_description" field.
func (m *OauthSessionMutation) SetErrorDescription(s string) {
	m.error_description = &s
}

// ErrorDescription returns the value of the "error_description" field in the mutation.
func (m *OauthSessionMutation) ErrorDescription() (r string, exists bool) {
	v := m.error_description
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorDescription returns the old "error_description" field's value of the OauthSession entity.
// If the OauthSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthSessionMutation) OldErrorDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorDescription: %w", err)
	}
	return oldValue.ErrorDescription, nil
}

// ClearErrorDescription clears the value of the "error_description" field.
func (m *OauthSessionMutation) ClearErrorDescription() {
	m.error_description = nil
	m.clearedFields[oauthsession.FieldErrorDescription] = struct{}{}
}

// ErrorDescriptionCleared returns if the "error_description" field was cleared in this mutation.
func (m *OauthSessionMutation) ErrorDescriptionCleared() bool {
	_, ok := m.clearedFields[oauthsession.FieldErrorDescription]
	return ok
}

// ResetErrorDescription resets all changes to the "error_description" field.
func (m *OauthSessionMutation) ResetErrorDescription() {
	m.error_description = nil
	delete(m.clearedFields, oauthsession.FieldErrorDescription)
}

// SetRetryCount sets the "retry_count" field.
func (m *OauthSessionMutation) SetRetryCount(i int) {
	m.retry_count = &i
	m.addretry_count = nil
}

// RetryCount returns the value of the "retry_count" field in the mutation.
func (m *OauthSessionMutation) RetryCount() (r int, exists bool) {
	v := m.retry_count
	if v == nil {
		return
	}
	return *v, true
}

// OldRetryCount returns the old "retry_count" field's value of the OauthSession entity.
// If the OauthSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthSessionMutation) OldRetryCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRetryCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRetryCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRetryCount: %w", err)
	}
	return oldValue.RetryCount, nil
}

// AddRetryCount adds i to the "retry_count" field.
func (m *OauthSessionMutation) AddRetryCount(i int) {
	if m.addretry_count != nil {
		*m.addretry_count += i
	} else {
		m.addretry_count = &i
	}
}

// AddedRetryCount returns the value that was added to the "retry_count" field in this mutation.
func (m *OauthSessionMutation) AddedRetryCount() (r int, exists bool) {
	v := m.addretry_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetRetryCount resets all changes to the "retry_count" field.
func (m *OauthSessionMutation) ResetRetryCount() {
	m.retry_count = nil
	m.addretry_count = nil
}

// SetDepartmentID sets the "department_id" field.
func (m *OauthSessionMutation) SetDepartmentID(u uint64) {
	m.department_id = &u
	m.adddepartment_id = nil
}

// DepartmentID returns the value of the "department_id" field in the mutation.
func (m *OauthSessionMutation) DepartmentID() (r uint64, exists bool) {
	v := m.department_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDepartmentID returns the old "department_id" field's value of the OauthSession entity.
// If the OauthSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthSessionMutation) OldDepartmentID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDepartmentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDepartmentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepartmentID: %w", err)
	}
	return oldValue.DepartmentID, nil
}

// AddDepartmentID adds u to the "department_id" field.
func (m *OauthSessionMutation) AddDepartmentID(u int64) {
	if m.adddepartment_id != nil {
		*m.adddepartment_id += u
	} else {
		m.adddepartment_id = &u
	}
}

// AddedDepartmentID returns the value that was added to the "department_id" field in this mutation.
func (m *OauthSessionMutation) AddedDepartmentID() (r int64, exists bool) {
	v := m.adddepartment_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearDepartmentID clears the value of the "department_id" field.
func (m *OauthSessionMutation) ClearDepartmentID() {
	m.department_id = nil
	m.adddepartment_id = nil
	m.clearedFields[oauthsession.FieldDepartmentID] = struct{}{}
}

// DepartmentIDCleared returns if the "department_id" field was cleared in this mutation.
func (m *OauthSessionMutation) DepartmentIDCleared() bool {
	_, ok := m.clearedFields[oauthsession.FieldDepartmentID]
	return ok
}

// ResetDepartmentID resets all changes to the "department_id" field.
func (m *OauthSessionMutation) ResetDepartmentID() {
	m.department_id = nil
	m.adddepartment_id = nil
	delete(m.clearedFields, oauthsession.FieldDepartmentID)
}

// ClearProvider clears the "provider" edge to the OauthProvider entity.
func (m *OauthSessionMutation) ClearProvider() {
	m.clearedprovider = true
	m.clearedFields[oauthsession.FieldProviderID] = struct{}{}
}

// ProviderCleared reports if the "provider" edge to the OauthProvider entity was cleared.
func (m *OauthSessionMutation) ProviderCleared() bool {
	return m.clearedprovider
}

// ProviderIDs returns the "provider" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProviderID instead. It exists only for internal usage by the builders.
func (m *OauthSessionMutation) ProviderIDs() (ids []uint64) {
	if id := m.provider; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProvider resets all changes to the "provider" edge.
func (m *OauthSessionMutation) ResetProvider() {
	m.provider = nil
	m.clearedprovider = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *OauthSessionMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[oauthsession.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *OauthSessionMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *OauthSessionMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *OauthSessionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the OauthSessionMutation builder.
func (m *OauthSessionMutation) Where(ps ...predicate.OauthSession) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OauthSessionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OauthSessionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OauthSession, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OauthSessionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OauthSessionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OauthSession).
func (m *OauthSessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OauthSessionMutation) Fields() []string {
	fields := make([]string, 0, 23)
	if m.created_at != nil {
		fields = append(fields, oauthsession.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, oauthsession.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, oauthsession.FieldStatus)
	}
	if m.tenant_id != nil {
		fields = append(fields, oauthsession.FieldTenantID)
	}
	if m.session_id != nil {
		fields = append(fields, oauthsession.FieldSessionID)
	}
	if m.state != nil {
		fields = append(fields, oauthsession.FieldState)
	}
	if m.provider != nil {
		fields = append(fields, oauthsession.FieldProviderID)
	}
	if m.user != nil {
		fields = append(fields, oauthsession.FieldUserID)
	}
	if m.redirect_uri != nil {
		fields = append(fields, oauthsession.FieldRedirectURI)
	}
	if m.scope != nil {
		fields = append(fields, oauthsession.FieldScope)
	}
	if m.code_challenge != nil {
		fields = append(fields, oauthsession.FieldCodeChallenge)
	}
	if m.code_challenge_method != nil {
		fields = append(fields, oauthsession.FieldCodeChallengeMethod)
	}
	if m.code_verifier != nil {
		fields = append(fields, oauthsession.FieldCodeVerifier)
	}
	if m.expires_at != nil {
		fields = append(fields, oauthsession.FieldExpiresAt)
	}
	if m.client_ip != nil {
		fields = append(fields, oauthsession.FieldClientIP)
	}
	if m.user_agent != nil {
		fields = append(fields, oauthsession.FieldUserAgent)
	}
	if m.authorization_code != nil {
		fields = append(fields, oauthsession.FieldAuthorizationCode)
	}
	if m.code_received_at != nil {
		fields = append(fields, oauthsession.FieldCodeReceivedAt)
	}
	if m.callback_data != nil {
		fields = append(fields, oauthsession.FieldCallbackData)
	}
	if m.error_code != nil {
		fields = append(fields, oauthsession.FieldErrorCode)
	}
	if m.error_description != nil {
		fields = append(fields, oauthsession.FieldErrorDescription)
	}
	if m.retry_count != nil {
		fields = append(fields, oauthsession.FieldRetryCount)
	}
	if m.department_id != nil {
		fields = append(fields, oauthsession.FieldDepartmentID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OauthSessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case oauthsession.FieldCreatedAt:
		return m.CreatedAt()
	case oauthsession.FieldUpdatedAt:
		return m.UpdatedAt()
	case oauthsession.FieldStatus:
		return m.Status()
	case oauthsession.FieldTenantID:
		return m.TenantID()
	case oauthsession.FieldSessionID:
		return m.SessionID()
	case oauthsession.FieldState:
		return m.State()
	case oauthsession.FieldProviderID:
		return m.ProviderID()
	case oauthsession.FieldUserID:
		return m.UserID()
	case oauthsession.FieldRedirectURI:
		return m.RedirectURI()
	case oauthsession.FieldScope:
		return m.Scope()
	case oauthsession.FieldCodeChallenge:
		return m.CodeChallenge()
	case oauthsession.FieldCodeChallengeMethod:
		return m.CodeChallengeMethod()
	case oauthsession.FieldCodeVerifier:
		return m.CodeVerifier()
	case oauthsession.FieldExpiresAt:
		return m.ExpiresAt()
	case oauthsession.FieldClientIP:
		return m.ClientIP()
	case oauthsession.FieldUserAgent:
		return m.UserAgent()
	case oauthsession.FieldAuthorizationCode:
		return m.AuthorizationCode()
	case oauthsession.FieldCodeReceivedAt:
		return m.CodeReceivedAt()
	case oauthsession.FieldCallbackData:
		return m.CallbackData()
	case oauthsession.FieldErrorCode:
		return m.ErrorCode()
	case oauthsession.FieldErrorDescription:
		return m.ErrorDescription()
	case oauthsession.FieldRetryCount:
		return m.RetryCount()
	case oauthsession.FieldDepartmentID:
		return m.DepartmentID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OauthSessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case oauthsession.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case oauthsession.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case oauthsession.FieldStatus:
		return m.OldStatus(ctx)
	case oauthsession.FieldTenantID:
		return m.OldTenantID(ctx)
	case oauthsession.FieldSessionID:
		return m.OldSessionID(ctx)
	case oauthsession.FieldState:
		return m.OldState(ctx)
	case oauthsession.FieldProviderID:
		return m.OldProviderID(ctx)
	case oauthsession.FieldUserID:
		return m.OldUserID(ctx)
	case oauthsession.FieldRedirectURI:
		return m.OldRedirectURI(ctx)
	case oauthsession.FieldScope:
		return m.OldScope(ctx)
	case oauthsession.FieldCodeChallenge:
		return m.OldCodeChallenge(ctx)
	case oauthsession.FieldCodeChallengeMethod:
		return m.OldCodeChallengeMethod(ctx)
	case oauthsession.FieldCodeVerifier:
		return m.OldCodeVerifier(ctx)
	case oauthsession.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case oauthsession.FieldClientIP:
		return m.OldClientIP(ctx)
	case oauthsession.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case oauthsession.FieldAuthorizationCode:
		return m.OldAuthorizationCode(ctx)
	case oauthsession.FieldCodeReceivedAt:
		return m.OldCodeReceivedAt(ctx)
	case oauthsession.FieldCallbackData:
		return m.OldCallbackData(ctx)
	case oauthsession.FieldErrorCode:
		return m.OldErrorCode(ctx)
	case oauthsession.FieldErrorDescription:
		return m.OldErrorDescription(ctx)
	case oauthsession.FieldRetryCount:
		return m.OldRetryCount(ctx)
	case oauthsession.FieldDepartmentID:
		return m.OldDepartmentID(ctx)
	}
	return nil, fmt.Errorf("unknown OauthSession field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OauthSessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case oauthsession.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case oauthsession.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case oauthsession.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case oauthsession.FieldTenantID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case oauthsession.FieldSessionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionID(v)
		return nil
	case oauthsession.FieldState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case oauthsession.FieldProviderID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProviderID(v)
		return nil
	case oauthsession.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case oauthsession.FieldRedirectURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRedirectURI(v)
		return nil
	case oauthsession.FieldScope:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScope(v)
		return nil
	case oauthsession.FieldCodeChallenge:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCodeChallenge(v)
		return nil
	case oauthsession.FieldCodeChallengeMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCodeChallengeMethod(v)
		return nil
	case oauthsession.FieldCodeVerifier:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCodeVerifier(v)
		return nil
	case oauthsession.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case oauthsession.FieldClientIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientIP(v)
		return nil
	case oauthsession.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case oauthsession.FieldAuthorizationCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthorizationCode(v)
		return nil
	case oauthsession.FieldCodeReceivedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCodeReceivedAt(v)
		return nil
	case oauthsession.FieldCallbackData:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCallbackData(v)
		return nil
	case oauthsession.FieldErrorCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorCode(v)
		return nil
	case oauthsession.FieldErrorDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorDescription(v)
		return nil
	case oauthsession.FieldRetryCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRetryCount(v)
		return nil
	case oauthsession.FieldDepartmentID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepartmentID(v)
		return nil
	}
	return fmt.Errorf("unknown OauthSession field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OauthSessionMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, oauthsession.FieldStatus)
	}
	if m.addtenant_id != nil {
		fields = append(fields, oauthsession.FieldTenantID)
	}
	if m.addretry_count != nil {
		fields = append(fields, oauthsession.FieldRetryCount)
	}
	if m.adddepartment_id != nil {
		fields = append(fields, oauthsession.FieldDepartmentID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OauthSessionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case oauthsession.FieldStatus:
		return m.AddedStatus()
	case oauthsession.FieldTenantID:
		return m.AddedTenantID()
	case oauthsession.FieldRetryCount:
		return m.AddedRetryCount()
	case oauthsession.FieldDepartmentID:
		return m.AddedDepartmentID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OauthSessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case oauthsession.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case oauthsession.FieldTenantID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case oauthsession.FieldRetryCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRetryCount(v)
		return nil
	case oauthsession.FieldDepartmentID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDepartmentID(v)
		return nil
	}
	return fmt.Errorf("unknown OauthSession numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OauthSessionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(oauthsession.FieldStatus) {
		fields = append(fields, oauthsession.FieldStatus)
	}
	if m.FieldCleared(oauthsession.FieldUserID) {
		fields = append(fields, oauthsession.FieldUserID)
	}
	if m.FieldCleared(oauthsession.FieldScope) {
		fields = append(fields, oauthsession.FieldScope)
	}
	if m.FieldCleared(oauthsession.FieldCodeChallenge) {
		fields = append(fields, oauthsession.FieldCodeChallenge)
	}
	if m.FieldCleared(oauthsession.FieldCodeChallengeMethod) {
		fields = append(fields, oauthsession.FieldCodeChallengeMethod)
	}
	if m.FieldCleared(oauthsession.FieldCodeVerifier) {
		fields = append(fields, oauthsession.FieldCodeVerifier)
	}
	if m.FieldCleared(oauthsession.FieldClientIP) {
		fields = append(fields, oauthsession.FieldClientIP)
	}
	if m.FieldCleared(oauthsession.FieldUserAgent) {
		fields = append(fields, oauthsession.FieldUserAgent)
	}
	if m.FieldCleared(oauthsession.FieldAuthorizationCode) {
		fields = append(fields, oauthsession.FieldAuthorizationCode)
	}
	if m.FieldCleared(oauthsession.FieldCodeReceivedAt) {
		fields = append(fields, oauthsession.FieldCodeReceivedAt)
	}
	if m.FieldCleared(oauthsession.FieldCallbackData) {
		fields = append(fields, oauthsession.FieldCallbackData)
	}
	if m.FieldCleared(oauthsession.FieldErrorCode) {
		fields = append(fields, oauthsession.FieldErrorCode)
	}
	if m.FieldCleared(oauthsession.FieldErrorDescription) {
		fields = append(fields, oauthsession.FieldErrorDescription)
	}
	if m.FieldCleared(oauthsession.FieldDepartmentID) {
		fields = append(fields, oauthsession.FieldDepartmentID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OauthSessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OauthSessionMutation) ClearField(name string) error {
	switch name {
	case oauthsession.FieldStatus:
		m.ClearStatus()
		return nil
	case oauthsession.FieldUserID:
		m.ClearUserID()
		return nil
	case oauthsession.FieldScope:
		m.ClearScope()
		return nil
	case oauthsession.FieldCodeChallenge:
		m.ClearCodeChallenge()
		return nil
	case oauthsession.FieldCodeChallengeMethod:
		m.ClearCodeChallengeMethod()
		return nil
	case oauthsession.FieldCodeVerifier:
		m.ClearCodeVerifier()
		return nil
	case oauthsession.FieldClientIP:
		m.ClearClientIP()
		return nil
	case oauthsession.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	case oauthsession.FieldAuthorizationCode:
		m.ClearAuthorizationCode()
		return nil
	case oauthsession.FieldCodeReceivedAt:
		m.ClearCodeReceivedAt()
		return nil
	case oauthsession.FieldCallbackData:
		m.ClearCallbackData()
		return nil
	case oauthsession.FieldErrorCode:
		m.ClearErrorCode()
		return nil
	case oauthsession.FieldErrorDescription:
		m.ClearErrorDescription()
		return nil
	case oauthsession.FieldDepartmentID:
		m.ClearDepartmentID()
		return nil
	}
	return fmt.Errorf("unknown OauthSession nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OauthSessionMutation) ResetField(name string) error {
	switch name {
	case oauthsession.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case oauthsession.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case oauthsession.FieldStatus:
		m.ResetStatus()
		return nil
	case oauthsession.FieldTenantID:
		m.ResetTenantID()
		return nil
	case oauthsession.FieldSessionID:
		m.ResetSessionID()
		return nil
	case oauthsession.FieldState:
		m.ResetState()
		return nil
	case oauthsession.FieldProviderID:
		m.ResetProviderID()
		return nil
	case oauthsession.FieldUserID:
		m.ResetUserID()
		return nil
	case oauthsession.FieldRedirectURI:
		m.ResetRedirectURI()
		return nil
	case oauthsession.FieldScope:
		m.ResetScope()
		return nil
	case oauthsession.FieldCodeChallenge:
		m.ResetCodeChallenge()
		return nil
	case oauthsession.FieldCodeChallengeMethod:
		m.ResetCodeChallengeMethod()
		return nil
	case oauthsession.FieldCodeVerifier:
		m.ResetCodeVerifier()
		return nil
	case oauthsession.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case oauthsession.FieldClientIP:
		m.ResetClientIP()
		return nil
	case oauthsession.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case oauthsession.FieldAuthorizationCode:
		m.ResetAuthorizationCode()
		return nil
	case oauthsession.FieldCodeReceivedAt:
		m.ResetCodeReceivedAt()
		return nil
	case oauthsession.FieldCallbackData:
		m.ResetCallbackData()
		return nil
	case oauthsession.FieldErrorCode:
		m.ResetErrorCode()
		return nil
	case oauthsession.FieldErrorDescription:
		m.ResetErrorDescription()
		return nil
	case oauthsession.FieldRetryCount:
		m.ResetRetryCount()
		return nil
	case oauthsession.FieldDepartmentID:
		m.ResetDepartmentID()
		return nil
	}
	return fmt.Errorf("unknown OauthSession field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OauthSessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.provider != nil {
		edges = append(edges, oauthsession.EdgeProvider)
	}
	if m.user != nil {
		edges = append(edges, oauthsession.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OauthSessionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case oauthsession.EdgeProvider:
		if id := m.provider; id != nil {
			return []ent.Value{*id}
		}
	case oauthsession.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OauthSessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OauthSessionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OauthSessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedprovider {
		edges = append(edges, oauthsession.EdgeProvider)
	}
	if m.cleareduser {
		edges = append(edges, oauthsession.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OauthSessionMutation) EdgeCleared(name string) bool {
	switch name {
	case oauthsession.EdgeProvider:
		return m.clearedprovider
	case oauthsession.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OauthSessionMutation) ClearEdge(name string) error {
	switch name {
	case oauthsession.EdgeProvider:
		m.ClearProvider()
		return nil
	case oauthsession.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown OauthSession unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OauthSessionMutation) ResetEdge(name string) error {
	switch name {
	case oauthsession.EdgeProvider:
		m.ResetProvider()
		return nil
	case oauthsession.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown OauthSession edge %s", name)
}

// PositionMutation represents an operation that mutates the Position nodes in the graph.
type PositionMutation struct {
	config
	op                 Op
	typ                string
	id                 *uint64
	created_at         *time.Time
	updated_at         *time.Time
	status             *uint8
	addstatus          *int8
	sort               *uint32
	addsort            *int32
	tenant_id          *uint64
	addtenant_id       *int64
	name               *string
	code               *string
	remark             *string
	clearedFields      map[string]struct{}
	users              map[uuid.UUID]struct{}
	removedusers       map[uuid.UUID]struct{}
	clearedusers       bool
	departments        *uint64
	cleareddepartments bool
	done               bool
	oldValue           func(context.Context) (*Position, error)
	predicates         []predicate.Position
}

var _ ent.Mutation = (*PositionMutation)(nil)

// positionOption allows management of the mutation configuration using functional options.
type positionOption func(*PositionMutation)

// newPositionMutation creates new mutation for the Position entity.
func newPositionMutation(c config, op Op, opts ...positionOption) *PositionMutation {
	m := &PositionMutation{
		config:        c,
		op:            op,
		typ:           TypePosition,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPositionID sets the ID field of the mutation.
func withPositionID(id uint64) positionOption {
	return func(m *PositionMutation) {
		var (
			err   error
			once  sync.Once
			value *Position
		)
		m.oldValue = func(ctx context.Context) (*Position, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Position.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPosition sets the old Position of the mutation.
func withPosition(node *Position) positionOption {
	return func(m *PositionMutation) {
		m.oldValue = func(context.Context) (*Position, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PositionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PositionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Position entities.
func (m *PositionMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PositionMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PositionMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Position.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PositionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PositionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PositionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PositionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PositionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PositionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *PositionMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *PositionMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *PositionMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *PositionMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *PositionMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[position.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *PositionMutation) StatusCleared() bool {
	_, ok := m.clearedFields[position.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *PositionMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, position.FieldStatus)
}

// SetSort sets the "sort" field.
func (m *PositionMutation) SetSort(u uint32) {
	m.sort = &u
	m.addsort = nil
}

// Sort returns the value of the "sort" field in the mutation.
func (m *PositionMutation) Sort() (r uint32, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldSort(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// AddSort adds u to the "sort" field.
func (m *PositionMutation) AddSort(u int32) {
	if m.addsort != nil {
		*m.addsort += u
	} else {
		m.addsort = &u
	}
}

// AddedSort returns the value that was added to the "sort" field in this mutation.
func (m *PositionMutation) AddedSort() (r int32, exists bool) {
	v := m.addsort
	if v == nil {
		return
	}
	return *v, true
}

// ResetSort resets all changes to the "sort" field.
func (m *PositionMutation) ResetSort() {
	m.sort = nil
	m.addsort = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *PositionMutation) SetTenantID(u uint64) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *PositionMutation) TenantID() (r uint64, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldTenantID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *PositionMutation) AddTenantID(u int64) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *PositionMutation) AddedTenantID() (r int64, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *PositionMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetName sets the "name" field.
func (m *PositionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PositionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PositionMutation) ResetName() {
	m.name = nil
}

// SetCode sets the "code" field.
func (m *PositionMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *PositionMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *PositionMutation) ResetCode() {
	m.code = nil
}

// SetRemark sets the "remark" field.
func (m *PositionMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *PositionMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *PositionMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[position.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *PositionMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[position.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *PositionMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, position.FieldRemark)
}

// SetDeptID sets the "dept_id" field.
func (m *PositionMutation) SetDeptID(u uint64) {
	m.departments = &u
}

// DeptID returns the value of the "dept_id" field in the mutation.
func (m *PositionMutation) DeptID() (r uint64, exists bool) {
	v := m.departments
	if v == nil {
		return
	}
	return *v, true
}

// OldDeptID returns the old "dept_id" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldDeptID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeptID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeptID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeptID: %w", err)
	}
	return oldValue.DeptID, nil
}

// ClearDeptID clears the value of the "dept_id" field.
func (m *PositionMutation) ClearDeptID() {
	m.departments = nil
	m.clearedFields[position.FieldDeptID] = struct{}{}
}

// DeptIDCleared returns if the "dept_id" field was cleared in this mutation.
func (m *PositionMutation) DeptIDCleared() bool {
	_, ok := m.clearedFields[position.FieldDeptID]
	return ok
}

// ResetDeptID resets all changes to the "dept_id" field.
func (m *PositionMutation) ResetDeptID() {
	m.departments = nil
	delete(m.clearedFields, position.FieldDeptID)
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *PositionMutation) AddUserIDs(ids ...uuid.UUID) {
	if m.users == nil {
		m.users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *PositionMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *PositionMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *PositionMutation) RemoveUserIDs(ids ...uuid.UUID) {
	if m.removedusers == nil {
		m.removedusers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *PositionMutation) RemovedUsersIDs() (ids []uuid.UUID) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *PositionMutation) UsersIDs() (ids []uuid.UUID) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *PositionMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// SetDepartmentsID sets the "departments" edge to the Department entity by id.
func (m *PositionMutation) SetDepartmentsID(id uint64) {
	m.departments = &id
}

// ClearDepartments clears the "departments" edge to the Department entity.
func (m *PositionMutation) ClearDepartments() {
	m.cleareddepartments = true
	m.clearedFields[position.FieldDeptID] = struct{}{}
}

// DepartmentsCleared reports if the "departments" edge to the Department entity was cleared.
func (m *PositionMutation) DepartmentsCleared() bool {
	return m.DeptIDCleared() || m.cleareddepartments
}

// DepartmentsID returns the "departments" edge ID in the mutation.
func (m *PositionMutation) DepartmentsID() (id uint64, exists bool) {
	if m.departments != nil {
		return *m.departments, true
	}
	return
}

// DepartmentsIDs returns the "departments" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DepartmentsID instead. It exists only for internal usage by the builders.
func (m *PositionMutation) DepartmentsIDs() (ids []uint64) {
	if id := m.departments; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDepartments resets all changes to the "departments" edge.
func (m *PositionMutation) ResetDepartments() {
	m.departments = nil
	m.cleareddepartments = false
}

// Where appends a list predicates to the PositionMutation builder.
func (m *PositionMutation) Where(ps ...predicate.Position) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PositionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PositionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Position, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PositionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PositionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Position).
func (m *PositionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PositionMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, position.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, position.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, position.FieldStatus)
	}
	if m.sort != nil {
		fields = append(fields, position.FieldSort)
	}
	if m.tenant_id != nil {
		fields = append(fields, position.FieldTenantID)
	}
	if m.name != nil {
		fields = append(fields, position.FieldName)
	}
	if m.code != nil {
		fields = append(fields, position.FieldCode)
	}
	if m.remark != nil {
		fields = append(fields, position.FieldRemark)
	}
	if m.departments != nil {
		fields = append(fields, position.FieldDeptID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PositionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case position.FieldCreatedAt:
		return m.CreatedAt()
	case position.FieldUpdatedAt:
		return m.UpdatedAt()
	case position.FieldStatus:
		return m.Status()
	case position.FieldSort:
		return m.Sort()
	case position.FieldTenantID:
		return m.TenantID()
	case position.FieldName:
		return m.Name()
	case position.FieldCode:
		return m.Code()
	case position.FieldRemark:
		return m.Remark()
	case position.FieldDeptID:
		return m.DeptID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PositionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case position.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case position.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case position.FieldStatus:
		return m.OldStatus(ctx)
	case position.FieldSort:
		return m.OldSort(ctx)
	case position.FieldTenantID:
		return m.OldTenantID(ctx)
	case position.FieldName:
		return m.OldName(ctx)
	case position.FieldCode:
		return m.OldCode(ctx)
	case position.FieldRemark:
		return m.OldRemark(ctx)
	case position.FieldDeptID:
		return m.OldDeptID(ctx)
	}
	return nil, fmt.Errorf("unknown Position field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PositionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case position.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case position.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case position.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case position.FieldSort:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	case position.FieldTenantID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case position.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case position.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case position.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case position.FieldDeptID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeptID(v)
		return nil
	}
	return fmt.Errorf("unknown Position field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PositionMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, position.FieldStatus)
	}
	if m.addsort != nil {
		fields = append(fields, position.FieldSort)
	}
	if m.addtenant_id != nil {
		fields = append(fields, position.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PositionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case position.FieldStatus:
		return m.AddedStatus()
	case position.FieldSort:
		return m.AddedSort()
	case position.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PositionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case position.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case position.FieldSort:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSort(v)
		return nil
	case position.FieldTenantID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown Position numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PositionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(position.FieldStatus) {
		fields = append(fields, position.FieldStatus)
	}
	if m.FieldCleared(position.FieldRemark) {
		fields = append(fields, position.FieldRemark)
	}
	if m.FieldCleared(position.FieldDeptID) {
		fields = append(fields, position.FieldDeptID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PositionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PositionMutation) ClearField(name string) error {
	switch name {
	case position.FieldStatus:
		m.ClearStatus()
		return nil
	case position.FieldRemark:
		m.ClearRemark()
		return nil
	case position.FieldDeptID:
		m.ClearDeptID()
		return nil
	}
	return fmt.Errorf("unknown Position nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PositionMutation) ResetField(name string) error {
	switch name {
	case position.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case position.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case position.FieldStatus:
		m.ResetStatus()
		return nil
	case position.FieldSort:
		m.ResetSort()
		return nil
	case position.FieldTenantID:
		m.ResetTenantID()
		return nil
	case position.FieldName:
		m.ResetName()
		return nil
	case position.FieldCode:
		m.ResetCode()
		return nil
	case position.FieldRemark:
		m.ResetRemark()
		return nil
	case position.FieldDeptID:
		m.ResetDeptID()
		return nil
	}
	return fmt.Errorf("unknown Position field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PositionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.users != nil {
		edges = append(edges, position.EdgeUsers)
	}
	if m.departments != nil {
		edges = append(edges, position.EdgeDepartments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PositionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case position.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case position.EdgeDepartments:
		if id := m.departments; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PositionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedusers != nil {
		edges = append(edges, position.EdgeUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PositionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case position.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PositionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedusers {
		edges = append(edges, position.EdgeUsers)
	}
	if m.cleareddepartments {
		edges = append(edges, position.EdgeDepartments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PositionMutation) EdgeCleared(name string) bool {
	switch name {
	case position.EdgeUsers:
		return m.clearedusers
	case position.EdgeDepartments:
		return m.cleareddepartments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PositionMutation) ClearEdge(name string) error {
	switch name {
	case position.EdgeDepartments:
		m.ClearDepartments()
		return nil
	}
	return fmt.Errorf("unknown Position unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PositionMutation) ResetEdge(name string) error {
	switch name {
	case position.EdgeUsers:
		m.ResetUsers()
		return nil
	case position.EdgeDepartments:
		m.ResetDepartments()
		return nil
	}
	return fmt.Errorf("unknown Position edge %s", name)
}

// RoleMutation represents an operation that mutates the Role nodes in the graph.
type RoleMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uint64
	created_at            *time.Time
	updated_at            *time.Time
	status                *uint8
	addstatus             *int8
	tenant_id             *uint64
	addtenant_id          *int64
	name                  *string
	code                  *string
	default_router        *string
	remark                *string
	sort                  *uint32
	addsort               *int32
	custom_dept_ids       *[]uint64
	appendcustom_dept_ids []uint64
	clearedFields         map[string]struct{}
	menus                 map[uint64]struct{}
	removedmenus          map[uint64]struct{}
	clearedmenus          bool
	users                 map[uuid.UUID]struct{}
	removedusers          map[uuid.UUID]struct{}
	clearedusers          bool
	done                  bool
	oldValue              func(context.Context) (*Role, error)
	predicates            []predicate.Role
}

var _ ent.Mutation = (*RoleMutation)(nil)

// roleOption allows management of the mutation configuration using functional options.
type roleOption func(*RoleMutation)

// newRoleMutation creates new mutation for the Role entity.
func newRoleMutation(c config, op Op, opts ...roleOption) *RoleMutation {
	m := &RoleMutation{
		config:        c,
		op:            op,
		typ:           TypeRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoleID sets the ID field of the mutation.
func withRoleID(id uint64) roleOption {
	return func(m *RoleMutation) {
		var (
			err   error
			once  sync.Once
			value *Role
		)
		m.oldValue = func(ctx context.Context) (*Role, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Role.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRole sets the old Role of the mutation.
func withRole(node *Role) roleOption {
	return func(m *RoleMutation) {
		m.oldValue = func(context.Context) (*Role, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Role entities.
func (m *RoleMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoleMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoleMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Role.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RoleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RoleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RoleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RoleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RoleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *RoleMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *RoleMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *RoleMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *RoleMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *RoleMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[role.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *RoleMutation) StatusCleared() bool {
	_, ok := m.clearedFields[role.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *RoleMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, role.FieldStatus)
}

// SetTenantID sets the "tenant_id" field.
func (m *RoleMutation) SetTenantID(u uint64) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *RoleMutation) TenantID() (r uint64, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldTenantID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *RoleMutation) AddTenantID(u int64) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *RoleMutation) AddedTenantID() (r int64, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *RoleMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetName sets the "name" field.
func (m *RoleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RoleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RoleMutation) ResetName() {
	m.name = nil
}

// SetCode sets the "code" field.
func (m *RoleMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *RoleMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *RoleMutation) ResetCode() {
	m.code = nil
}

// SetDefaultRouter sets the "default_router" field.
func (m *RoleMutation) SetDefaultRouter(s string) {
	m.default_router = &s
}

// DefaultRouter returns the value of the "default_router" field in the mutation.
func (m *RoleMutation) DefaultRouter() (r string, exists bool) {
	v := m.default_router
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultRouter returns the old "default_router" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldDefaultRouter(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultRouter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultRouter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultRouter: %w", err)
	}
	return oldValue.DefaultRouter, nil
}

// ResetDefaultRouter resets all changes to the "default_router" field.
func (m *RoleMutation) ResetDefaultRouter() {
	m.default_router = nil
}

// SetRemark sets the "remark" field.
func (m *RoleMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *RoleMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ResetRemark resets all changes to the "remark" field.
func (m *RoleMutation) ResetRemark() {
	m.remark = nil
}

// SetSort sets the "sort" field.
func (m *RoleMutation) SetSort(u uint32) {
	m.sort = &u
	m.addsort = nil
}

// Sort returns the value of the "sort" field in the mutation.
func (m *RoleMutation) Sort() (r uint32, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldSort(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// AddSort adds u to the "sort" field.
func (m *RoleMutation) AddSort(u int32) {
	if m.addsort != nil {
		*m.addsort += u
	} else {
		m.addsort = &u
	}
}

// AddedSort returns the value that was added to the "sort" field in this mutation.
func (m *RoleMutation) AddedSort() (r int32, exists bool) {
	v := m.addsort
	if v == nil {
		return
	}
	return *v, true
}

// ResetSort resets all changes to the "sort" field.
func (m *RoleMutation) ResetSort() {
	m.sort = nil
	m.addsort = nil
}

// SetCustomDeptIds sets the "custom_dept_ids" field.
func (m *RoleMutation) SetCustomDeptIds(u []uint64) {
	m.custom_dept_ids = &u
	m.appendcustom_dept_ids = nil
}

// CustomDeptIds returns the value of the "custom_dept_ids" field in the mutation.
func (m *RoleMutation) CustomDeptIds() (r []uint64, exists bool) {
	v := m.custom_dept_ids
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomDeptIds returns the old "custom_dept_ids" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldCustomDeptIds(ctx context.Context) (v []uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomDeptIds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomDeptIds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomDeptIds: %w", err)
	}
	return oldValue.CustomDeptIds, nil
}

// AppendCustomDeptIds adds u to the "custom_dept_ids" field.
func (m *RoleMutation) AppendCustomDeptIds(u []uint64) {
	m.appendcustom_dept_ids = append(m.appendcustom_dept_ids, u...)
}

// AppendedCustomDeptIds returns the list of values that were appended to the "custom_dept_ids" field in this mutation.
func (m *RoleMutation) AppendedCustomDeptIds() ([]uint64, bool) {
	if len(m.appendcustom_dept_ids) == 0 {
		return nil, false
	}
	return m.appendcustom_dept_ids, true
}

// ClearCustomDeptIds clears the value of the "custom_dept_ids" field.
func (m *RoleMutation) ClearCustomDeptIds() {
	m.custom_dept_ids = nil
	m.appendcustom_dept_ids = nil
	m.clearedFields[role.FieldCustomDeptIds] = struct{}{}
}

// CustomDeptIdsCleared returns if the "custom_dept_ids" field was cleared in this mutation.
func (m *RoleMutation) CustomDeptIdsCleared() bool {
	_, ok := m.clearedFields[role.FieldCustomDeptIds]
	return ok
}

// ResetCustomDeptIds resets all changes to the "custom_dept_ids" field.
func (m *RoleMutation) ResetCustomDeptIds() {
	m.custom_dept_ids = nil
	m.appendcustom_dept_ids = nil
	delete(m.clearedFields, role.FieldCustomDeptIds)
}

// AddMenuIDs adds the "menus" edge to the Menu entity by ids.
func (m *RoleMutation) AddMenuIDs(ids ...uint64) {
	if m.menus == nil {
		m.menus = make(map[uint64]struct{})
	}
	for i := range ids {
		m.menus[ids[i]] = struct{}{}
	}
}

// ClearMenus clears the "menus" edge to the Menu entity.
func (m *RoleMutation) ClearMenus() {
	m.clearedmenus = true
}

// MenusCleared reports if the "menus" edge to the Menu entity was cleared.
func (m *RoleMutation) MenusCleared() bool {
	return m.clearedmenus
}

// RemoveMenuIDs removes the "menus" edge to the Menu entity by IDs.
func (m *RoleMutation) RemoveMenuIDs(ids ...uint64) {
	if m.removedmenus == nil {
		m.removedmenus = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.menus, ids[i])
		m.removedmenus[ids[i]] = struct{}{}
	}
}

// RemovedMenus returns the removed IDs of the "menus" edge to the Menu entity.
func (m *RoleMutation) RemovedMenusIDs() (ids []uint64) {
	for id := range m.removedmenus {
		ids = append(ids, id)
	}
	return
}

// MenusIDs returns the "menus" edge IDs in the mutation.
func (m *RoleMutation) MenusIDs() (ids []uint64) {
	for id := range m.menus {
		ids = append(ids, id)
	}
	return
}

// ResetMenus resets all changes to the "menus" edge.
func (m *RoleMutation) ResetMenus() {
	m.menus = nil
	m.clearedmenus = false
	m.removedmenus = nil
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *RoleMutation) AddUserIDs(ids ...uuid.UUID) {
	if m.users == nil {
		m.users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *RoleMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *RoleMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *RoleMutation) RemoveUserIDs(ids ...uuid.UUID) {
	if m.removedusers == nil {
		m.removedusers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *RoleMutation) RemovedUsersIDs() (ids []uuid.UUID) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *RoleMutation) UsersIDs() (ids []uuid.UUID) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *RoleMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// Where appends a list predicates to the RoleMutation builder.
func (m *RoleMutation) Where(ps ...predicate.Role) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Role, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Role).
func (m *RoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoleMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, role.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, role.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, role.FieldStatus)
	}
	if m.tenant_id != nil {
		fields = append(fields, role.FieldTenantID)
	}
	if m.name != nil {
		fields = append(fields, role.FieldName)
	}
	if m.code != nil {
		fields = append(fields, role.FieldCode)
	}
	if m.default_router != nil {
		fields = append(fields, role.FieldDefaultRouter)
	}
	if m.remark != nil {
		fields = append(fields, role.FieldRemark)
	}
	if m.sort != nil {
		fields = append(fields, role.FieldSort)
	}
	if m.custom_dept_ids != nil {
		fields = append(fields, role.FieldCustomDeptIds)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case role.FieldCreatedAt:
		return m.CreatedAt()
	case role.FieldUpdatedAt:
		return m.UpdatedAt()
	case role.FieldStatus:
		return m.Status()
	case role.FieldTenantID:
		return m.TenantID()
	case role.FieldName:
		return m.Name()
	case role.FieldCode:
		return m.Code()
	case role.FieldDefaultRouter:
		return m.DefaultRouter()
	case role.FieldRemark:
		return m.Remark()
	case role.FieldSort:
		return m.Sort()
	case role.FieldCustomDeptIds:
		return m.CustomDeptIds()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case role.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case role.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case role.FieldStatus:
		return m.OldStatus(ctx)
	case role.FieldTenantID:
		return m.OldTenantID(ctx)
	case role.FieldName:
		return m.OldName(ctx)
	case role.FieldCode:
		return m.OldCode(ctx)
	case role.FieldDefaultRouter:
		return m.OldDefaultRouter(ctx)
	case role.FieldRemark:
		return m.OldRemark(ctx)
	case role.FieldSort:
		return m.OldSort(ctx)
	case role.FieldCustomDeptIds:
		return m.OldCustomDeptIds(ctx)
	}
	return nil, fmt.Errorf("unknown Role field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case role.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case role.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case role.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case role.FieldTenantID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case role.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case role.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case role.FieldDefaultRouter:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultRouter(v)
		return nil
	case role.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case role.FieldSort:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	case role.FieldCustomDeptIds:
		v, ok := value.([]uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomDeptIds(v)
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoleMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, role.FieldStatus)
	}
	if m.addtenant_id != nil {
		fields = append(fields, role.FieldTenantID)
	}
	if m.addsort != nil {
		fields = append(fields, role.FieldSort)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case role.FieldStatus:
		return m.AddedStatus()
	case role.FieldTenantID:
		return m.AddedTenantID()
	case role.FieldSort:
		return m.AddedSort()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case role.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case role.FieldTenantID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case role.FieldSort:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSort(v)
		return nil
	}
	return fmt.Errorf("unknown Role numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(role.FieldStatus) {
		fields = append(fields, role.FieldStatus)
	}
	if m.FieldCleared(role.FieldCustomDeptIds) {
		fields = append(fields, role.FieldCustomDeptIds)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleMutation) ClearField(name string) error {
	switch name {
	case role.FieldStatus:
		m.ClearStatus()
		return nil
	case role.FieldCustomDeptIds:
		m.ClearCustomDeptIds()
		return nil
	}
	return fmt.Errorf("unknown Role nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoleMutation) ResetField(name string) error {
	switch name {
	case role.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case role.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case role.FieldStatus:
		m.ResetStatus()
		return nil
	case role.FieldTenantID:
		m.ResetTenantID()
		return nil
	case role.FieldName:
		m.ResetName()
		return nil
	case role.FieldCode:
		m.ResetCode()
		return nil
	case role.FieldDefaultRouter:
		m.ResetDefaultRouter()
		return nil
	case role.FieldRemark:
		m.ResetRemark()
		return nil
	case role.FieldSort:
		m.ResetSort()
		return nil
	case role.FieldCustomDeptIds:
		m.ResetCustomDeptIds()
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.menus != nil {
		edges = append(edges, role.EdgeMenus)
	}
	if m.users != nil {
		edges = append(edges, role.EdgeUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeMenus:
		ids := make([]ent.Value, 0, len(m.menus))
		for id := range m.menus {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedmenus != nil {
		edges = append(edges, role.EdgeMenus)
	}
	if m.removedusers != nil {
		edges = append(edges, role.EdgeUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeMenus:
		ids := make([]ent.Value, 0, len(m.removedmenus))
		for id := range m.removedmenus {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmenus {
		edges = append(edges, role.EdgeMenus)
	}
	if m.clearedusers {
		edges = append(edges, role.EdgeUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoleMutation) EdgeCleared(name string) bool {
	switch name {
	case role.EdgeMenus:
		return m.clearedmenus
	case role.EdgeUsers:
		return m.clearedusers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Role unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoleMutation) ResetEdge(name string) error {
	switch name {
	case role.EdgeMenus:
		m.ResetMenus()
		return nil
	case role.EdgeUsers:
		m.ResetUsers()
		return nil
	}
	return fmt.Errorf("unknown Role edge %s", name)
}

// TenantMutation represents an operation that mutates the Tenant nodes in the graph.
type TenantMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	created_at    *time.Time
	updated_at    *time.Time
	status        *uint8
	addstatus     *int8
	name          *string
	code          *string
	description   *string
	expired_at    *time.Time
	_config       *map[string]interface{}
	created_by    *uint64
	addcreated_by *int64
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Tenant, error)
	predicates    []predicate.Tenant
}

var _ ent.Mutation = (*TenantMutation)(nil)

// tenantOption allows management of the mutation configuration using functional options.
type tenantOption func(*TenantMutation)

// newTenantMutation creates new mutation for the Tenant entity.
func newTenantMutation(c config, op Op, opts ...tenantOption) *TenantMutation {
	m := &TenantMutation{
		config:        c,
		op:            op,
		typ:           TypeTenant,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTenantID sets the ID field of the mutation.
func withTenantID(id uint64) tenantOption {
	return func(m *TenantMutation) {
		var (
			err   error
			once  sync.Once
			value *Tenant
		)
		m.oldValue = func(ctx context.Context) (*Tenant, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tenant.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTenant sets the old Tenant of the mutation.
func withTenant(node *Tenant) tenantOption {
	return func(m *TenantMutation) {
		m.oldValue = func(context.Context) (*Tenant, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TenantMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TenantMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Tenant entities.
func (m *TenantMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TenantMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TenantMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tenant.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TenantMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TenantMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TenantMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TenantMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TenantMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TenantMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *TenantMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *TenantMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *TenantMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *TenantMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *TenantMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[tenant.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *TenantMutation) StatusCleared() bool {
	_, ok := m.clearedFields[tenant.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *TenantMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, tenant.FieldStatus)
}

// SetName sets the "name" field.
func (m *TenantMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TenantMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TenantMutation) ResetName() {
	m.name = nil
}

// SetCode sets the "code" field.
func (m *TenantMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *TenantMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *TenantMutation) ResetCode() {
	m.code = nil
}

// SetDescription sets the "description" field.
func (m *TenantMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TenantMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TenantMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[tenant.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TenantMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[tenant.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TenantMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, tenant.FieldDescription)
}

// SetExpiredAt sets the "expired_at" field.
func (m *TenantMutation) SetExpiredAt(t time.Time) {
	m.expired_at = &t
}

// ExpiredAt returns the value of the "expired_at" field in the mutation.
func (m *TenantMutation) ExpiredAt() (r time.Time, exists bool) {
	v := m.expired_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiredAt returns the old "expired_at" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldExpiredAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiredAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiredAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiredAt: %w", err)
	}
	return oldValue.ExpiredAt, nil
}

// ClearExpiredAt clears the value of the "expired_at" field.
func (m *TenantMutation) ClearExpiredAt() {
	m.expired_at = nil
	m.clearedFields[tenant.FieldExpiredAt] = struct{}{}
}

// ExpiredAtCleared returns if the "expired_at" field was cleared in this mutation.
func (m *TenantMutation) ExpiredAtCleared() bool {
	_, ok := m.clearedFields[tenant.FieldExpiredAt]
	return ok
}

// ResetExpiredAt resets all changes to the "expired_at" field.
func (m *TenantMutation) ResetExpiredAt() {
	m.expired_at = nil
	delete(m.clearedFields, tenant.FieldExpiredAt)
}

// SetConfig sets the "config" field.
func (m *TenantMutation) SetConfig(value map[string]interface{}) {
	m._config = &value
}

// Config returns the value of the "config" field in the mutation.
func (m *TenantMutation) Config() (r map[string]interface{}, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldConfig(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ClearConfig clears the value of the "config" field.
func (m *TenantMutation) ClearConfig() {
	m._config = nil
	m.clearedFields[tenant.FieldConfig] = struct{}{}
}

// ConfigCleared returns if the "config" field was cleared in this mutation.
func (m *TenantMutation) ConfigCleared() bool {
	_, ok := m.clearedFields[tenant.FieldConfig]
	return ok
}

// ResetConfig resets all changes to the "config" field.
func (m *TenantMutation) ResetConfig() {
	m._config = nil
	delete(m.clearedFields, tenant.FieldConfig)
}

// SetCreatedBy sets the "created_by" field.
func (m *TenantMutation) SetCreatedBy(u uint64) {
	m.created_by = &u
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *TenantMutation) CreatedBy() (r uint64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldCreatedBy(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds u to the "created_by" field.
func (m *TenantMutation) AddCreatedBy(u int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += u
	} else {
		m.addcreated_by = &u
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *TenantMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *TenantMutation) ClearCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	m.clearedFields[tenant.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *TenantMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[tenant.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *TenantMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	delete(m.clearedFields, tenant.FieldCreatedBy)
}

// Where appends a list predicates to the TenantMutation builder.
func (m *TenantMutation) Where(ps ...predicate.Tenant) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TenantMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TenantMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Tenant, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TenantMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TenantMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Tenant).
func (m *TenantMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TenantMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, tenant.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tenant.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, tenant.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, tenant.FieldName)
	}
	if m.code != nil {
		fields = append(fields, tenant.FieldCode)
	}
	if m.description != nil {
		fields = append(fields, tenant.FieldDescription)
	}
	if m.expired_at != nil {
		fields = append(fields, tenant.FieldExpiredAt)
	}
	if m._config != nil {
		fields = append(fields, tenant.FieldConfig)
	}
	if m.created_by != nil {
		fields = append(fields, tenant.FieldCreatedBy)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TenantMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tenant.FieldCreatedAt:
		return m.CreatedAt()
	case tenant.FieldUpdatedAt:
		return m.UpdatedAt()
	case tenant.FieldStatus:
		return m.Status()
	case tenant.FieldName:
		return m.Name()
	case tenant.FieldCode:
		return m.Code()
	case tenant.FieldDescription:
		return m.Description()
	case tenant.FieldExpiredAt:
		return m.ExpiredAt()
	case tenant.FieldConfig:
		return m.Config()
	case tenant.FieldCreatedBy:
		return m.CreatedBy()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TenantMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tenant.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tenant.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tenant.FieldStatus:
		return m.OldStatus(ctx)
	case tenant.FieldName:
		return m.OldName(ctx)
	case tenant.FieldCode:
		return m.OldCode(ctx)
	case tenant.FieldDescription:
		return m.OldDescription(ctx)
	case tenant.FieldExpiredAt:
		return m.OldExpiredAt(ctx)
	case tenant.FieldConfig:
		return m.OldConfig(ctx)
	case tenant.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	}
	return nil, fmt.Errorf("unknown Tenant field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TenantMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tenant.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tenant.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tenant.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case tenant.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case tenant.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case tenant.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case tenant.FieldExpiredAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiredAt(v)
		return nil
	case tenant.FieldConfig:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	case tenant.FieldCreatedBy:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown Tenant field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TenantMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, tenant.FieldStatus)
	}
	if m.addcreated_by != nil {
		fields = append(fields, tenant.FieldCreatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TenantMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tenant.FieldStatus:
		return m.AddedStatus()
	case tenant.FieldCreatedBy:
		return m.AddedCreatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TenantMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tenant.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case tenant.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown Tenant numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TenantMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tenant.FieldStatus) {
		fields = append(fields, tenant.FieldStatus)
	}
	if m.FieldCleared(tenant.FieldDescription) {
		fields = append(fields, tenant.FieldDescription)
	}
	if m.FieldCleared(tenant.FieldExpiredAt) {
		fields = append(fields, tenant.FieldExpiredAt)
	}
	if m.FieldCleared(tenant.FieldConfig) {
		fields = append(fields, tenant.FieldConfig)
	}
	if m.FieldCleared(tenant.FieldCreatedBy) {
		fields = append(fields, tenant.FieldCreatedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TenantMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TenantMutation) ClearField(name string) error {
	switch name {
	case tenant.FieldStatus:
		m.ClearStatus()
		return nil
	case tenant.FieldDescription:
		m.ClearDescription()
		return nil
	case tenant.FieldExpiredAt:
		m.ClearExpiredAt()
		return nil
	case tenant.FieldConfig:
		m.ClearConfig()
		return nil
	case tenant.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	}
	return fmt.Errorf("unknown Tenant nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TenantMutation) ResetField(name string) error {
	switch name {
	case tenant.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tenant.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tenant.FieldStatus:
		m.ResetStatus()
		return nil
	case tenant.FieldName:
		m.ResetName()
		return nil
	case tenant.FieldCode:
		m.ResetCode()
		return nil
	case tenant.FieldDescription:
		m.ResetDescription()
		return nil
	case tenant.FieldExpiredAt:
		m.ResetExpiredAt()
		return nil
	case tenant.FieldConfig:
		m.ResetConfig()
		return nil
	case tenant.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	}
	return fmt.Errorf("unknown Tenant field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TenantMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TenantMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TenantMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TenantMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TenantMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TenantMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TenantMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Tenant unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TenantMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Tenant edge %s", name)
}

// TokenMutation represents an operation that mutates the Token nodes in the graph.
type TokenMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	created_at       *time.Time
	updated_at       *time.Time
	status           *uint8
	addstatus        *int8
	tenant_id        *uint64
	addtenant_id     *int64
	uuid             *uuid.UUID
	username         *string
	token            *string
	source           *string
	expired_at       *time.Time
	department_id    *uint64
	adddepartment_id *int64
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*Token, error)
	predicates       []predicate.Token
}

var _ ent.Mutation = (*TokenMutation)(nil)

// tokenOption allows management of the mutation configuration using functional options.
type tokenOption func(*TokenMutation)

// newTokenMutation creates new mutation for the Token entity.
func newTokenMutation(c config, op Op, opts ...tokenOption) *TokenMutation {
	m := &TokenMutation{
		config:        c,
		op:            op,
		typ:           TypeToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTokenID sets the ID field of the mutation.
func withTokenID(id uuid.UUID) tokenOption {
	return func(m *TokenMutation) {
		var (
			err   error
			once  sync.Once
			value *Token
		)
		m.oldValue = func(ctx context.Context) (*Token, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Token.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withToken sets the old Token of the mutation.
func withToken(node *Token) tokenOption {
	return func(m *TokenMutation) {
		m.oldValue = func(context.Context) (*Token, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Token entities.
func (m *TokenMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TokenMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TokenMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Token.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TokenMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TokenMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TokenMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TokenMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TokenMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TokenMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *TokenMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *TokenMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *TokenMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *TokenMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *TokenMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[token.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *TokenMutation) StatusCleared() bool {
	_, ok := m.clearedFields[token.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *TokenMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, token.FieldStatus)
}

// SetTenantID sets the "tenant_id" field.
func (m *TokenMutation) SetTenantID(u uint64) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *TokenMutation) TenantID() (r uint64, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldTenantID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *TokenMutation) AddTenantID(u int64) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *TokenMutation) AddedTenantID() (r int64, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *TokenMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetUUID sets the "uuid" field.
func (m *TokenMutation) SetUUID(u uuid.UUID) {
	m.uuid = &u
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *TokenMutation) UUID() (r uuid.UUID, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldUUID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *TokenMutation) ResetUUID() {
	m.uuid = nil
}

// SetUsername sets the "username" field.
func (m *TokenMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *TokenMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *TokenMutation) ResetUsername() {
	m.username = nil
}

// SetToken sets the "token" field.
func (m *TokenMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *TokenMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *TokenMutation) ResetToken() {
	m.token = nil
}

// SetSource sets the "source" field.
func (m *TokenMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *TokenMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *TokenMutation) ResetSource() {
	m.source = nil
}

// SetExpiredAt sets the "expired_at" field.
func (m *TokenMutation) SetExpiredAt(t time.Time) {
	m.expired_at = &t
}

// ExpiredAt returns the value of the "expired_at" field in the mutation.
func (m *TokenMutation) ExpiredAt() (r time.Time, exists bool) {
	v := m.expired_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiredAt returns the old "expired_at" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldExpiredAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiredAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiredAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiredAt: %w", err)
	}
	return oldValue.ExpiredAt, nil
}

// ResetExpiredAt resets all changes to the "expired_at" field.
func (m *TokenMutation) ResetExpiredAt() {
	m.expired_at = nil
}

// SetDepartmentID sets the "department_id" field.
func (m *TokenMutation) SetDepartmentID(u uint64) {
	m.department_id = &u
	m.adddepartment_id = nil
}

// DepartmentID returns the value of the "department_id" field in the mutation.
func (m *TokenMutation) DepartmentID() (r uint64, exists bool) {
	v := m.department_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDepartmentID returns the old "department_id" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldDepartmentID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDepartmentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDepartmentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepartmentID: %w", err)
	}
	return oldValue.DepartmentID, nil
}

// AddDepartmentID adds u to the "department_id" field.
func (m *TokenMutation) AddDepartmentID(u int64) {
	if m.adddepartment_id != nil {
		*m.adddepartment_id += u
	} else {
		m.adddepartment_id = &u
	}
}

// AddedDepartmentID returns the value that was added to the "department_id" field in this mutation.
func (m *TokenMutation) AddedDepartmentID() (r int64, exists bool) {
	v := m.adddepartment_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearDepartmentID clears the value of the "department_id" field.
func (m *TokenMutation) ClearDepartmentID() {
	m.department_id = nil
	m.adddepartment_id = nil
	m.clearedFields[token.FieldDepartmentID] = struct{}{}
}

// DepartmentIDCleared returns if the "department_id" field was cleared in this mutation.
func (m *TokenMutation) DepartmentIDCleared() bool {
	_, ok := m.clearedFields[token.FieldDepartmentID]
	return ok
}

// ResetDepartmentID resets all changes to the "department_id" field.
func (m *TokenMutation) ResetDepartmentID() {
	m.department_id = nil
	m.adddepartment_id = nil
	delete(m.clearedFields, token.FieldDepartmentID)
}

// Where appends a list predicates to the TokenMutation builder.
func (m *TokenMutation) Where(ps ...predicate.Token) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Token, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Token).
func (m *TokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TokenMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, token.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, token.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, token.FieldStatus)
	}
	if m.tenant_id != nil {
		fields = append(fields, token.FieldTenantID)
	}
	if m.uuid != nil {
		fields = append(fields, token.FieldUUID)
	}
	if m.username != nil {
		fields = append(fields, token.FieldUsername)
	}
	if m.token != nil {
		fields = append(fields, token.FieldToken)
	}
	if m.source != nil {
		fields = append(fields, token.FieldSource)
	}
	if m.expired_at != nil {
		fields = append(fields, token.FieldExpiredAt)
	}
	if m.department_id != nil {
		fields = append(fields, token.FieldDepartmentID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case token.FieldCreatedAt:
		return m.CreatedAt()
	case token.FieldUpdatedAt:
		return m.UpdatedAt()
	case token.FieldStatus:
		return m.Status()
	case token.FieldTenantID:
		return m.TenantID()
	case token.FieldUUID:
		return m.UUID()
	case token.FieldUsername:
		return m.Username()
	case token.FieldToken:
		return m.Token()
	case token.FieldSource:
		return m.Source()
	case token.FieldExpiredAt:
		return m.ExpiredAt()
	case token.FieldDepartmentID:
		return m.DepartmentID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case token.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case token.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case token.FieldStatus:
		return m.OldStatus(ctx)
	case token.FieldTenantID:
		return m.OldTenantID(ctx)
	case token.FieldUUID:
		return m.OldUUID(ctx)
	case token.FieldUsername:
		return m.OldUsername(ctx)
	case token.FieldToken:
		return m.OldToken(ctx)
	case token.FieldSource:
		return m.OldSource(ctx)
	case token.FieldExpiredAt:
		return m.OldExpiredAt(ctx)
	case token.FieldDepartmentID:
		return m.OldDepartmentID(ctx)
	}
	return nil, fmt.Errorf("unknown Token field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case token.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case token.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case token.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case token.FieldTenantID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case token.FieldUUID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case token.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case token.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case token.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case token.FieldExpiredAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiredAt(v)
		return nil
	case token.FieldDepartmentID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepartmentID(v)
		return nil
	}
	return fmt.Errorf("unknown Token field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TokenMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, token.FieldStatus)
	}
	if m.addtenant_id != nil {
		fields = append(fields, token.FieldTenantID)
	}
	if m.adddepartment_id != nil {
		fields = append(fields, token.FieldDepartmentID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TokenMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case token.FieldStatus:
		return m.AddedStatus()
	case token.FieldTenantID:
		return m.AddedTenantID()
	case token.FieldDepartmentID:
		return m.AddedDepartmentID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	case token.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case token.FieldTenantID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case token.FieldDepartmentID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDepartmentID(v)
		return nil
	}
	return fmt.Errorf("unknown Token numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TokenMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(token.FieldStatus) {
		fields = append(fields, token.FieldStatus)
	}
	if m.FieldCleared(token.FieldDepartmentID) {
		fields = append(fields, token.FieldDepartmentID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TokenMutation) ClearField(name string) error {
	switch name {
	case token.FieldStatus:
		m.ClearStatus()
		return nil
	case token.FieldDepartmentID:
		m.ClearDepartmentID()
		return nil
	}
	return fmt.Errorf("unknown Token nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TokenMutation) ResetField(name string) error {
	switch name {
	case token.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case token.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case token.FieldStatus:
		m.ResetStatus()
		return nil
	case token.FieldTenantID:
		m.ResetTenantID()
		return nil
	case token.FieldUUID:
		m.ResetUUID()
		return nil
	case token.FieldUsername:
		m.ResetUsername()
		return nil
	case token.FieldToken:
		m.ResetToken()
		return nil
	case token.FieldSource:
		m.ResetSource()
		return nil
	case token.FieldExpiredAt:
		m.ResetExpiredAt()
		return nil
	case token.FieldDepartmentID:
		m.ResetDepartmentID()
		return nil
	}
	return fmt.Errorf("unknown Token field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TokenMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TokenMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TokenMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Token unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TokenMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Token edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uuid.UUID
	created_at            *time.Time
	updated_at            *time.Time
	status                *uint8
	addstatus             *int8
	tenant_id             *uint64
	addtenant_id          *int64
	username              *string
	password              *string
	nickname              *string
	description           *string
	home_path             *string
	mobile                *string
	email                 *string
	avatar                *string
	clearedFields         map[string]struct{}
	departments           *uint64
	cleareddepartments    bool
	positions             map[uint64]struct{}
	removedpositions      map[uint64]struct{}
	clearedpositions      bool
	roles                 map[uint64]struct{}
	removedroles          map[uint64]struct{}
	clearedroles          bool
	oauth_accounts        map[uint64]struct{}
	removedoauth_accounts map[uint64]struct{}
	clearedoauth_accounts bool
	oauth_sessions        map[uint64]struct{}
	removedoauth_sessions map[uint64]struct{}
	clearedoauth_sessions bool
	done                  bool
	oldValue              func(context.Context) (*User, error)
	predicates            []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *UserMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *UserMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *UserMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *UserMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *UserMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[user.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *UserMutation) StatusCleared() bool {
	_, ok := m.clearedFields[user.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *UserMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, user.FieldStatus)
}

// SetTenantID sets the "tenant_id" field.
func (m *UserMutation) SetTenantID(u uint64) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *UserMutation) TenantID() (r uint64, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldTenantID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *UserMutation) AddTenantID(u int64) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *UserMutation) AddedTenantID() (r int64, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *UserMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetNickname sets the "nickname" field.
func (m *UserMutation) SetNickname(s string) {
	m.nickname = &s
}

// Nickname returns the value of the "nickname" field in the mutation.
func (m *UserMutation) Nickname() (r string, exists bool) {
	v := m.nickname
	if v == nil {
		return
	}
	return *v, true
}

// OldNickname returns the old "nickname" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldNickname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNickname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNickname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickname: %w", err)
	}
	return oldValue.Nickname, nil
}

// ResetNickname resets all changes to the "nickname" field.
func (m *UserMutation) ResetNickname() {
	m.nickname = nil
}

// SetDescription sets the "description" field.
func (m *UserMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *UserMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *UserMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[user.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *UserMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[user.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *UserMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, user.FieldDescription)
}

// SetHomePath sets the "home_path" field.
func (m *UserMutation) SetHomePath(s string) {
	m.home_path = &s
}

// HomePath returns the value of the "home_path" field in the mutation.
func (m *UserMutation) HomePath() (r string, exists bool) {
	v := m.home_path
	if v == nil {
		return
	}
	return *v, true
}

// OldHomePath returns the old "home_path" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldHomePath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHomePath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHomePath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHomePath: %w", err)
	}
	return oldValue.HomePath, nil
}

// ResetHomePath resets all changes to the "home_path" field.
func (m *UserMutation) ResetHomePath() {
	m.home_path = nil
}

// SetMobile sets the "mobile" field.
func (m *UserMutation) SetMobile(s string) {
	m.mobile = &s
}

// Mobile returns the value of the "mobile" field in the mutation.
func (m *UserMutation) Mobile() (r string, exists bool) {
	v := m.mobile
	if v == nil {
		return
	}
	return *v, true
}

// OldMobile returns the old "mobile" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldMobile(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobile: %w", err)
	}
	return oldValue.Mobile, nil
}

// ClearMobile clears the value of the "mobile" field.
func (m *UserMutation) ClearMobile() {
	m.mobile = nil
	m.clearedFields[user.FieldMobile] = struct{}{}
}

// MobileCleared returns if the "mobile" field was cleared in this mutation.
func (m *UserMutation) MobileCleared() bool {
	_, ok := m.clearedFields[user.FieldMobile]
	return ok
}

// ResetMobile resets all changes to the "mobile" field.
func (m *UserMutation) ResetMobile() {
	m.mobile = nil
	delete(m.clearedFields, user.FieldMobile)
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *UserMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[user.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *UserMutation) EmailCleared() bool {
	_, ok := m.clearedFields[user.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, user.FieldEmail)
}

// SetAvatar sets the "avatar" field.
func (m *UserMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *UserMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ClearAvatar clears the value of the "avatar" field.
func (m *UserMutation) ClearAvatar() {
	m.avatar = nil
	m.clearedFields[user.FieldAvatar] = struct{}{}
}

// AvatarCleared returns if the "avatar" field was cleared in this mutation.
func (m *UserMutation) AvatarCleared() bool {
	_, ok := m.clearedFields[user.FieldAvatar]
	return ok
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *UserMutation) ResetAvatar() {
	m.avatar = nil
	delete(m.clearedFields, user.FieldAvatar)
}

// SetDepartmentID sets the "department_id" field.
func (m *UserMutation) SetDepartmentID(u uint64) {
	m.departments = &u
}

// DepartmentID returns the value of the "department_id" field in the mutation.
func (m *UserMutation) DepartmentID() (r uint64, exists bool) {
	v := m.departments
	if v == nil {
		return
	}
	return *v, true
}

// OldDepartmentID returns the old "department_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDepartmentID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDepartmentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDepartmentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepartmentID: %w", err)
	}
	return oldValue.DepartmentID, nil
}

// ClearDepartmentID clears the value of the "department_id" field.
func (m *UserMutation) ClearDepartmentID() {
	m.departments = nil
	m.clearedFields[user.FieldDepartmentID] = struct{}{}
}

// DepartmentIDCleared returns if the "department_id" field was cleared in this mutation.
func (m *UserMutation) DepartmentIDCleared() bool {
	_, ok := m.clearedFields[user.FieldDepartmentID]
	return ok
}

// ResetDepartmentID resets all changes to the "department_id" field.
func (m *UserMutation) ResetDepartmentID() {
	m.departments = nil
	delete(m.clearedFields, user.FieldDepartmentID)
}

// SetDepartmentsID sets the "departments" edge to the Department entity by id.
func (m *UserMutation) SetDepartmentsID(id uint64) {
	m.departments = &id
}

// ClearDepartments clears the "departments" edge to the Department entity.
func (m *UserMutation) ClearDepartments() {
	m.cleareddepartments = true
	m.clearedFields[user.FieldDepartmentID] = struct{}{}
}

// DepartmentsCleared reports if the "departments" edge to the Department entity was cleared.
func (m *UserMutation) DepartmentsCleared() bool {
	return m.DepartmentIDCleared() || m.cleareddepartments
}

// DepartmentsID returns the "departments" edge ID in the mutation.
func (m *UserMutation) DepartmentsID() (id uint64, exists bool) {
	if m.departments != nil {
		return *m.departments, true
	}
	return
}

// DepartmentsIDs returns the "departments" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DepartmentsID instead. It exists only for internal usage by the builders.
func (m *UserMutation) DepartmentsIDs() (ids []uint64) {
	if id := m.departments; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDepartments resets all changes to the "departments" edge.
func (m *UserMutation) ResetDepartments() {
	m.departments = nil
	m.cleareddepartments = false
}

// AddPositionIDs adds the "positions" edge to the Position entity by ids.
func (m *UserMutation) AddPositionIDs(ids ...uint64) {
	if m.positions == nil {
		m.positions = make(map[uint64]struct{})
	}
	for i := range ids {
		m.positions[ids[i]] = struct{}{}
	}
}

// ClearPositions clears the "positions" edge to the Position entity.
func (m *UserMutation) ClearPositions() {
	m.clearedpositions = true
}

// PositionsCleared reports if the "positions" edge to the Position entity was cleared.
func (m *UserMutation) PositionsCleared() bool {
	return m.clearedpositions
}

// RemovePositionIDs removes the "positions" edge to the Position entity by IDs.
func (m *UserMutation) RemovePositionIDs(ids ...uint64) {
	if m.removedpositions == nil {
		m.removedpositions = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.positions, ids[i])
		m.removedpositions[ids[i]] = struct{}{}
	}
}

// RemovedPositions returns the removed IDs of the "positions" edge to the Position entity.
func (m *UserMutation) RemovedPositionsIDs() (ids []uint64) {
	for id := range m.removedpositions {
		ids = append(ids, id)
	}
	return
}

// PositionsIDs returns the "positions" edge IDs in the mutation.
func (m *UserMutation) PositionsIDs() (ids []uint64) {
	for id := range m.positions {
		ids = append(ids, id)
	}
	return
}

// ResetPositions resets all changes to the "positions" edge.
func (m *UserMutation) ResetPositions() {
	m.positions = nil
	m.clearedpositions = false
	m.removedpositions = nil
}

// AddRoleIDs adds the "roles" edge to the Role entity by ids.
func (m *UserMutation) AddRoleIDs(ids ...uint64) {
	if m.roles == nil {
		m.roles = make(map[uint64]struct{})
	}
	for i := range ids {
		m.roles[ids[i]] = struct{}{}
	}
}

// ClearRoles clears the "roles" edge to the Role entity.
func (m *UserMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the Role entity was cleared.
func (m *UserMutation) RolesCleared() bool {
	return m.clearedroles
}

// RemoveRoleIDs removes the "roles" edge to the Role entity by IDs.
func (m *UserMutation) RemoveRoleIDs(ids ...uint64) {
	if m.removedroles == nil {
		m.removedroles = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.roles, ids[i])
		m.removedroles[ids[i]] = struct{}{}
	}
}

// RemovedRoles returns the removed IDs of the "roles" edge to the Role entity.
func (m *UserMutation) RemovedRolesIDs() (ids []uint64) {
	for id := range m.removedroles {
		ids = append(ids, id)
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
func (m *UserMutation) RolesIDs() (ids []uint64) {
	for id := range m.roles {
		ids = append(ids, id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *UserMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
	m.removedroles = nil
}

// AddOauthAccountIDs adds the "oauth_accounts" edge to the OauthAccount entity by ids.
func (m *UserMutation) AddOauthAccountIDs(ids ...uint64) {
	if m.oauth_accounts == nil {
		m.oauth_accounts = make(map[uint64]struct{})
	}
	for i := range ids {
		m.oauth_accounts[ids[i]] = struct{}{}
	}
}

// ClearOauthAccounts clears the "oauth_accounts" edge to the OauthAccount entity.
func (m *UserMutation) ClearOauthAccounts() {
	m.clearedoauth_accounts = true
}

// OauthAccountsCleared reports if the "oauth_accounts" edge to the OauthAccount entity was cleared.
func (m *UserMutation) OauthAccountsCleared() bool {
	return m.clearedoauth_accounts
}

// RemoveOauthAccountIDs removes the "oauth_accounts" edge to the OauthAccount entity by IDs.
func (m *UserMutation) RemoveOauthAccountIDs(ids ...uint64) {
	if m.removedoauth_accounts == nil {
		m.removedoauth_accounts = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.oauth_accounts, ids[i])
		m.removedoauth_accounts[ids[i]] = struct{}{}
	}
}

// RemovedOauthAccounts returns the removed IDs of the "oauth_accounts" edge to the OauthAccount entity.
func (m *UserMutation) RemovedOauthAccountsIDs() (ids []uint64) {
	for id := range m.removedoauth_accounts {
		ids = append(ids, id)
	}
	return
}

// OauthAccountsIDs returns the "oauth_accounts" edge IDs in the mutation.
func (m *UserMutation) OauthAccountsIDs() (ids []uint64) {
	for id := range m.oauth_accounts {
		ids = append(ids, id)
	}
	return
}

// ResetOauthAccounts resets all changes to the "oauth_accounts" edge.
func (m *UserMutation) ResetOauthAccounts() {
	m.oauth_accounts = nil
	m.clearedoauth_accounts = false
	m.removedoauth_accounts = nil
}

// AddOauthSessionIDs adds the "oauth_sessions" edge to the OauthSession entity by ids.
func (m *UserMutation) AddOauthSessionIDs(ids ...uint64) {
	if m.oauth_sessions == nil {
		m.oauth_sessions = make(map[uint64]struct{})
	}
	for i := range ids {
		m.oauth_sessions[ids[i]] = struct{}{}
	}
}

// ClearOauthSessions clears the "oauth_sessions" edge to the OauthSession entity.
func (m *UserMutation) ClearOauthSessions() {
	m.clearedoauth_sessions = true
}

// OauthSessionsCleared reports if the "oauth_sessions" edge to the OauthSession entity was cleared.
func (m *UserMutation) OauthSessionsCleared() bool {
	return m.clearedoauth_sessions
}

// RemoveOauthSessionIDs removes the "oauth_sessions" edge to the OauthSession entity by IDs.
func (m *UserMutation) RemoveOauthSessionIDs(ids ...uint64) {
	if m.removedoauth_sessions == nil {
		m.removedoauth_sessions = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.oauth_sessions, ids[i])
		m.removedoauth_sessions[ids[i]] = struct{}{}
	}
}

// RemovedOauthSessions returns the removed IDs of the "oauth_sessions" edge to the OauthSession entity.
func (m *UserMutation) RemovedOauthSessionsIDs() (ids []uint64) {
	for id := range m.removedoauth_sessions {
		ids = append(ids, id)
	}
	return
}

// OauthSessionsIDs returns the "oauth_sessions" edge IDs in the mutation.
func (m *UserMutation) OauthSessionsIDs() (ids []uint64) {
	for id := range m.oauth_sessions {
		ids = append(ids, id)
	}
	return
}

// ResetOauthSessions resets all changes to the "oauth_sessions" edge.
func (m *UserMutation) ResetOauthSessions() {
	m.oauth_sessions = nil
	m.clearedoauth_sessions = false
	m.removedoauth_sessions = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, user.FieldStatus)
	}
	if m.tenant_id != nil {
		fields = append(fields, user.FieldTenantID)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.nickname != nil {
		fields = append(fields, user.FieldNickname)
	}
	if m.description != nil {
		fields = append(fields, user.FieldDescription)
	}
	if m.home_path != nil {
		fields = append(fields, user.FieldHomePath)
	}
	if m.mobile != nil {
		fields = append(fields, user.FieldMobile)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.avatar != nil {
		fields = append(fields, user.FieldAvatar)
	}
	if m.departments != nil {
		fields = append(fields, user.FieldDepartmentID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldStatus:
		return m.Status()
	case user.FieldTenantID:
		return m.TenantID()
	case user.FieldUsername:
		return m.Username()
	case user.FieldPassword:
		return m.Password()
	case user.FieldNickname:
		return m.Nickname()
	case user.FieldDescription:
		return m.Description()
	case user.FieldHomePath:
		return m.HomePath()
	case user.FieldMobile:
		return m.Mobile()
	case user.FieldEmail:
		return m.Email()
	case user.FieldAvatar:
		return m.Avatar()
	case user.FieldDepartmentID:
		return m.DepartmentID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldStatus:
		return m.OldStatus(ctx)
	case user.FieldTenantID:
		return m.OldTenantID(ctx)
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldNickname:
		return m.OldNickname(ctx)
	case user.FieldDescription:
		return m.OldDescription(ctx)
	case user.FieldHomePath:
		return m.OldHomePath(ctx)
	case user.FieldMobile:
		return m.OldMobile(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldAvatar:
		return m.OldAvatar(ctx)
	case user.FieldDepartmentID:
		return m.OldDepartmentID(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case user.FieldTenantID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldNickname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickname(v)
		return nil
	case user.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case user.FieldHomePath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHomePath(v)
		return nil
	case user.FieldMobile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobile(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case user.FieldDepartmentID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepartmentID(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, user.FieldStatus)
	}
	if m.addtenant_id != nil {
		fields = append(fields, user.FieldTenantID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldStatus:
		return m.AddedStatus()
	case user.FieldTenantID:
		return m.AddedTenantID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case user.FieldTenantID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldStatus) {
		fields = append(fields, user.FieldStatus)
	}
	if m.FieldCleared(user.FieldDescription) {
		fields = append(fields, user.FieldDescription)
	}
	if m.FieldCleared(user.FieldMobile) {
		fields = append(fields, user.FieldMobile)
	}
	if m.FieldCleared(user.FieldEmail) {
		fields = append(fields, user.FieldEmail)
	}
	if m.FieldCleared(user.FieldAvatar) {
		fields = append(fields, user.FieldAvatar)
	}
	if m.FieldCleared(user.FieldDepartmentID) {
		fields = append(fields, user.FieldDepartmentID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldStatus:
		m.ClearStatus()
		return nil
	case user.FieldDescription:
		m.ClearDescription()
		return nil
	case user.FieldMobile:
		m.ClearMobile()
		return nil
	case user.FieldEmail:
		m.ClearEmail()
		return nil
	case user.FieldAvatar:
		m.ClearAvatar()
		return nil
	case user.FieldDepartmentID:
		m.ClearDepartmentID()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldStatus:
		m.ResetStatus()
		return nil
	case user.FieldTenantID:
		m.ResetTenantID()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldNickname:
		m.ResetNickname()
		return nil
	case user.FieldDescription:
		m.ResetDescription()
		return nil
	case user.FieldHomePath:
		m.ResetHomePath()
		return nil
	case user.FieldMobile:
		m.ResetMobile()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldAvatar:
		m.ResetAvatar()
		return nil
	case user.FieldDepartmentID:
		m.ResetDepartmentID()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.departments != nil {
		edges = append(edges, user.EdgeDepartments)
	}
	if m.positions != nil {
		edges = append(edges, user.EdgePositions)
	}
	if m.roles != nil {
		edges = append(edges, user.EdgeRoles)
	}
	if m.oauth_accounts != nil {
		edges = append(edges, user.EdgeOauthAccounts)
	}
	if m.oauth_sessions != nil {
		edges = append(edges, user.EdgeOauthSessions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeDepartments:
		if id := m.departments; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgePositions:
		ids := make([]ent.Value, 0, len(m.positions))
		for id := range m.positions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.roles))
		for id := range m.roles {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOauthAccounts:
		ids := make([]ent.Value, 0, len(m.oauth_accounts))
		for id := range m.oauth_accounts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOauthSessions:
		ids := make([]ent.Value, 0, len(m.oauth_sessions))
		for id := range m.oauth_sessions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedpositions != nil {
		edges = append(edges, user.EdgePositions)
	}
	if m.removedroles != nil {
		edges = append(edges, user.EdgeRoles)
	}
	if m.removedoauth_accounts != nil {
		edges = append(edges, user.EdgeOauthAccounts)
	}
	if m.removedoauth_sessions != nil {
		edges = append(edges, user.EdgeOauthSessions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgePositions:
		ids := make([]ent.Value, 0, len(m.removedpositions))
		for id := range m.removedpositions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.removedroles))
		for id := range m.removedroles {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOauthAccounts:
		ids := make([]ent.Value, 0, len(m.removedoauth_accounts))
		for id := range m.removedoauth_accounts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOauthSessions:
		ids := make([]ent.Value, 0, len(m.removedoauth_sessions))
		for id := range m.removedoauth_sessions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.cleareddepartments {
		edges = append(edges, user.EdgeDepartments)
	}
	if m.clearedpositions {
		edges = append(edges, user.EdgePositions)
	}
	if m.clearedroles {
		edges = append(edges, user.EdgeRoles)
	}
	if m.clearedoauth_accounts {
		edges = append(edges, user.EdgeOauthAccounts)
	}
	if m.clearedoauth_sessions {
		edges = append(edges, user.EdgeOauthSessions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeDepartments:
		return m.cleareddepartments
	case user.EdgePositions:
		return m.clearedpositions
	case user.EdgeRoles:
		return m.clearedroles
	case user.EdgeOauthAccounts:
		return m.clearedoauth_accounts
	case user.EdgeOauthSessions:
		return m.clearedoauth_sessions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeDepartments:
		m.ClearDepartments()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeDepartments:
		m.ResetDepartments()
		return nil
	case user.EdgePositions:
		m.ResetPositions()
		return nil
	case user.EdgeRoles:
		m.ResetRoles()
		return nil
	case user.EdgeOauthAccounts:
		m.ResetOauthAccounts()
		return nil
	case user.EdgeOauthSessions:
		m.ResetOauthSessions()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
